

<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    
        <title>resipy.Project | pyCATHY v0.1.1</title>
    

    
  <link href="../../_static/css/theme.css" rel="stylesheet">
  <link href="../../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-book-theme.css?digest=84ace793992934648b4de8eed757e5a2" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/thebelab.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-rendered-html.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css" />
    
  <link rel="preload" as="script" href="../../_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/thebelab-helper.js"></script>
    <script src="../../_static/design-tabs.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.1/dist/embed-amd.js"></script>
    <script src="../../_static/sphinx-book-theme.9d8b4a8b9bb19db25eeaddc40d639ba2.js"></script>
    <link rel="shortcut icon" href="../../_static/sphx_glr_pyCATHY_weilletal_thumb.png"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <!-- Plausible analytics for anonymous usage statistics -->
    <script defer data-domain="fatiando.org" src="https://plausible.io/js/plausible.js"></script>

  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<div class="col-12 col-md-3 bd-sidebar site-navigation " id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../../_static/sphx_glr_pyCATHY_weilletal_001.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">pyCATHY <span class="project-release">v0.1.1</span></h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Getting started
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../content/overview.html">
   Overview
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../content/installing.html">
   Installing
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../content/citing.html">
   Citing pyCATHY
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Gallery of examples
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../content/SSHydro/index.html">
   Surface subsurface hydrological model
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../content/SSHydro/plot_1_pyCATHY_weilletal.html">
     Weil et al example
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../content/SSHydro/plot_2_pyCATHY_inputs.html">
     Input plots
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../content/SSHydro/plot_3_meshing_from_weil.html">
     Meshing from a Digital Elevation Model (DEM)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../content/SSHydro/plot_3b_soil3d_from_weil.html">
     Soil 3d from a Digital Elevation Model (DEM)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../content/SSHydro/plot_4_pyCATHY_outputs.html">
     Output plots
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../content/DA/index.html">
   Data Assimilation
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../content/DA/plot_Weilletal_sensitivityAnalysis.html">
     Sensitivity analysis
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Reference documentation
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../content/api/api.html">
   API reference: The
   <code class="docutils literal notranslate">
    <span class="pre">
     pyCATHY
    </span>
   </code>
   package
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../content/api/generated/cathy_tools.html">
     <code class="docutils literal notranslate">
      <span class="pre">
       cathy_tools
      </span>
     </code>
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
    <label for="toctree-checkbox-4">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/cathy_tools.CATHY.html">
       cathy_tools.CATHY
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/cathy_tools.OrderedDict.html">
       cathy_tools.OrderedDict
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/cathy_tools.Repo.html">
       cathy_tools.Repo
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/cathy_tools.isfile.html">
       cathy_tools.isfile
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/cathy_tools.join.html">
       cathy_tools.join
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/cathy_tools.listdir.html">
       cathy_tools.listdir
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/cathy_tools.make_console.html">
       cathy_tools.make_console
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/cathy_tools.print.html">
       cathy_tools.print
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/cathy_tools.subprocess_run_multi.html">
       cathy_tools.subprocess_run_multi
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../content/api/generated/importers.cathy_outputs.html">
     <code class="docutils literal notranslate">
      <span class="pre">
       importers.cathy_outputs
      </span>
     </code>
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/>
    <label for="toctree-checkbox-5">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/importers.cathy_outputs.read_cumflowvol.html">
       importers.cathy_outputs.read_cumflowvol
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/importers.cathy_outputs.read_dtcoupling.html">
       importers.cathy_outputs.read_dtcoupling
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/importers.cathy_outputs.read_hgraph.html">
       importers.cathy_outputs.read_hgraph
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/importers.cathy_outputs.read_hgsfdet.html">
       importers.cathy_outputs.read_hgsfdet
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/importers.cathy_outputs.read_mbeconv.html">
       importers.cathy_outputs.read_mbeconv
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/importers.cathy_outputs.read_psi.html">
       importers.cathy_outputs.read_psi
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/importers.cathy_outputs.read_sw.html">
       importers.cathy_outputs.read_sw
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/importers.cathy_outputs.read_vp.html">
       importers.cathy_outputs.read_vp
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/importers.cathy_outputs.read_wtdepth.html">
       importers.cathy_outputs.read_wtdepth
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../content/api/generated/importers.cathy_inputs.html">
     <code class="docutils literal notranslate">
      <span class="pre">
       importers.cathy_inputs
      </span>
     </code>
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/>
    <label for="toctree-checkbox-6">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/importers.cathy_inputs.read_atmbc.html">
       importers.cathy_inputs.read_atmbc
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/importers.cathy_inputs.read_dem.html">
       importers.cathy_inputs.read_dem
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/importers.cathy_inputs.read_dem_parameters.html">
       importers.cathy_inputs.read_dem_parameters
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/importers.cathy_inputs.read_grid3d.html">
       importers.cathy_inputs.read_grid3d
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/importers.cathy_inputs.read_raster.html">
       importers.cathy_inputs.read_raster
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/importers.cathy_inputs.read_root_map.html">
       importers.cathy_inputs.read_root_map
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/importers.cathy_inputs.read_soil.html">
       importers.cathy_inputs.read_soil
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/importers.cathy_inputs.read_zone.html">
       importers.cathy_inputs.read_zone
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../content/api/generated/DA.cathy_DA.html">
     <code class="docutils literal notranslate">
      <span class="pre">
       DA.cathy_DA
      </span>
     </code>
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/>
    <label for="toctree-checkbox-7">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/DA.cathy_DA.CATHY.html">
       DA.cathy_DA.CATHY
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/DA.cathy_DA.DA.html">
       DA.cathy_DA.DA
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/DA.cathy_DA.partial.html">
       DA.cathy_DA.partial
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/DA.cathy_DA.Archie_pert_rules.html">
       DA.cathy_DA.Archie_pert_rules
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/DA.cathy_DA.Carsel_Parrish_VGN_pert.html">
       DA.cathy_DA.Carsel_Parrish_VGN_pert
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/DA.cathy_DA.Evensen2003.html">
       DA.cathy_DA.Evensen2003
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/DA.cathy_DA.Johnson1970.html">
       DA.cathy_DA.Johnson1970
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/DA.cathy_DA.VG_pert_rules.html">
       DA.cathy_DA.VG_pert_rules
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/DA.cathy_DA.atmbc_pert_rules.html">
       DA.cathy_DA.atmbc_pert_rules
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/DA.cathy_DA.build_dict_attributes_pert.html">
       DA.cathy_DA.build_dict_attributes_pert
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/DA.cathy_DA.dictObs_2pd.html">
       DA.cathy_DA.dictObs_2pd
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/DA.cathy_DA.perturbate_dist.html">
       DA.cathy_DA.perturbate_dist
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/DA.cathy_DA.perturbate_parm.html">
       DA.cathy_DA.perturbate_parm
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/DA.cathy_DA.resynchronise_times.html">
       DA.cathy_DA.resynchronise_times
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/DA.cathy_DA.run_analysis.html">
       DA.cathy_DA.run_analysis
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/DA.cathy_DA.sampling_dist.html">
       DA.cathy_DA.sampling_dist
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/DA.cathy_DA.sampling_dist_trunc.html">
       DA.cathy_DA.sampling_dist_trunc
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/DA.cathy_DA.subprocess_run_multi.html">
       DA.cathy_DA.subprocess_run_multi
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/DA.cathy_DA.track.html">
       DA.cathy_DA.track
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../content/api/generated/ERT.petro_Archie.html">
     <code class="docutils literal notranslate">
      <span class="pre">
       ERT.petro_Archie
      </span>
     </code>
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" type="checkbox"/>
    <label for="toctree-checkbox-8">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/ERT.petro_Archie.Archie_rho_DA.html">
       ERT.petro_Archie.Archie_rho_DA
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/ERT.petro_Archie.CATHY_2_Resipy.html">
       ERT.petro_Archie.CATHY_2_Resipy
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/ERT.petro_Archie.CATHY_2_pg.html">
       ERT.petro_Archie.CATHY_2_pg
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/ERT.petro_Archie.SW_2_ERa_DA.html">
       ERT.petro_Archie.SW_2_ERa_DA
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/ERT.petro_Archie.get_Archie_ens_i.html">
       ERT.petro_Archie.get_Archie_ens_i
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/ERT.petro_Archie.get_sw_ens_i.html">
       ERT.petro_Archie.get_sw_ens_i
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/ERT.petro_Archie.print.html">
       ERT.petro_Archie.print
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../content/api/generated/ERT.simulate_ERT.html">
     <code class="docutils literal notranslate">
      <span class="pre">
       ERT.simulate_ERT
      </span>
     </code>
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" type="checkbox"/>
    <label for="toctree-checkbox-9">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/ERT.simulate_ERT.R2.html">
       ERT.simulate_ERT.R2
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/ERT.simulate_ERT.Archie_ERT.html">
       ERT.simulate_ERT.Archie_ERT
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/ERT.simulate_ERT.create_ERT_survey_Resipy.html">
       ERT.simulate_ERT.create_ERT_survey_Resipy
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/ERT.simulate_ERT.create_ERT_survey_pg.html">
       ERT.simulate_ERT.create_ERT_survey_pg
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/ERT.simulate_ERT.fwd_ERT_survey.html">
       ERT.simulate_ERT.fwd_ERT_survey
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/ERT.simulate_ERT.invert_ERT_survey.html">
       ERT.simulate_ERT.invert_ERT_survey
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../content/api/generated/sensitivity.html">
     <code class="docutils literal notranslate">
      <span class="pre">
       sensitivity
      </span>
     </code>
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" type="checkbox"/>
    <label for="toctree-checkbox-10">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/sensitivity.analysis_Morris.html">
       sensitivity.analysis_Morris
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/sensitivity.define_Morris.html">
       sensitivity.define_Morris
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/sensitivity.df_Morris.html">
       sensitivity.df_Morris
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/sensitivity.err_weighted_rmse.html">
       sensitivity.err_weighted_rmse
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/sensitivity.plot_Morris.html">
       sensitivity.plot_Morris
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/sensitivity.print_Morris_out.html">
       sensitivity.print_Morris_out
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/sensitivity.run_sensitivity_analysis.html">
       sensitivity.run_sensitivity_analysis
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/sensitivity.samples_generation.html">
       sensitivity.samples_generation
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../content/api/generated/plotters.cathy_plots.html">
     <code class="docutils literal notranslate">
      <span class="pre">
       plotters.cathy_plots
      </span>
     </code>
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" type="checkbox"/>
    <label for="toctree-checkbox-11">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/plotters.cathy_plots.FormatStrFormatter.html">
       plotters.cathy_plots.FormatStrFormatter
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/plotters.cathy_plots.LogNorm.html">
       plotters.cathy_plots.LogNorm
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/plotters.cathy_plots.DA_RMS.html">
       plotters.cathy_plots.DA_RMS
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/plotters.cathy_plots.DA_plot_Archie.html">
       plotters.cathy_plots.DA_plot_Archie
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/plotters.cathy_plots.DA_plot_parm_dynamic.html">
       plotters.cathy_plots.DA_plot_parm_dynamic
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/plotters.cathy_plots.DA_plot_parm_dynamic_scatter.html">
       plotters.cathy_plots.DA_plot_parm_dynamic_scatter
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/plotters.cathy_plots.DA_plot_time_dynamic.html">
       plotters.cathy_plots.DA_plot_time_dynamic
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/plotters.cathy_plots.change_x2date.html">
       plotters.cathy_plots.change_x2date
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/plotters.cathy_plots.convert_time_units.html">
       plotters.cathy_plots.convert_time_units
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/plotters.cathy_plots.dem_plot_2d_top.html">
       plotters.cathy_plots.dem_plot_2d_top
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/plotters.cathy_plots.get_dem_coords.html">
       plotters.cathy_plots.get_dem_coords
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/plotters.cathy_plots.label_units.html">
       plotters.cathy_plots.label_units
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/plotters.cathy_plots.plot_VGP.html">
       plotters.cathy_plots.plot_VGP
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/plotters.cathy_plots.plot_hist_perturbated_parm.html">
       plotters.cathy_plots.plot_hist_perturbated_parm
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/plotters.cathy_plots.plot_mesh_bounds.html">
       plotters.cathy_plots.plot_mesh_bounds
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/plotters.cathy_plots.prepare_DA_plot_time_dynamic.html">
       plotters.cathy_plots.prepare_DA_plot_time_dynamic
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/plotters.cathy_plots.show_COCumflowvol.html">
       plotters.cathy_plots.show_COCumflowvol
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/plotters.cathy_plots.show_DA_process_ens.html">
       plotters.cathy_plots.show_DA_process_ens
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/plotters.cathy_plots.show_atmbc.html">
       plotters.cathy_plots.show_atmbc
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/plotters.cathy_plots.show_atmbc_3d.html">
       plotters.cathy_plots.show_atmbc_3d
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/plotters.cathy_plots.show_dem.html">
       plotters.cathy_plots.show_dem
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/plotters.cathy_plots.show_dtcoupling.html">
       plotters.cathy_plots.show_dtcoupling
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/plotters.cathy_plots.show_hgraph.html">
       plotters.cathy_plots.show_hgraph
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/plotters.cathy_plots.show_hgsfdet.html">
       plotters.cathy_plots.show_hgsfdet
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/plotters.cathy_plots.show_indice_veg.html">
       plotters.cathy_plots.show_indice_veg
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/plotters.cathy_plots.show_raster.html">
       plotters.cathy_plots.show_raster
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/plotters.cathy_plots.show_soil.html">
       plotters.cathy_plots.show_soil
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/plotters.cathy_plots.show_vp_DEPRECATED.html">
       plotters.cathy_plots.show_vp_DEPRECATED
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/plotters.cathy_plots.show_vtk.html">
       plotters.cathy_plots.show_vtk
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/plotters.cathy_plots.show_vtk_TL.html">
       plotters.cathy_plots.show_vtk_TL
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/plotters.cathy_plots.show_wtdepth.html">
       plotters.cathy_plots.show_wtdepth
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/plotters.cathy_plots.show_zone.html">
       plotters.cathy_plots.show_zone
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/plotters.cathy_plots.transform2_time_delta.html">
       plotters.cathy_plots.transform2_time_delta
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../content/api/generated/pyCATHY.cathy_utils.html">
     <code class="docutils literal notranslate">
      <span class="pre">
       pyCATHY.cathy_utils
      </span>
     </code>
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-12" name="toctree-checkbox-12" type="checkbox"/>
    <label for="toctree-checkbox-12">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/pyCATHY.cathy_utils.change_x2date.html">
       pyCATHY.cathy_utils.change_x2date
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/pyCATHY.cathy_utils.convert_time_units.html">
       pyCATHY.cathy_utils.convert_time_units
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/pyCATHY.cathy_utils.dictObs_2pd.html">
       pyCATHY.cathy_utils.dictObs_2pd
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/pyCATHY.cathy_utils.kPa2cm.html">
       pyCATHY.cathy_utils.kPa2cm
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/pyCATHY.cathy_utils.kPa2m.html">
       pyCATHY.cathy_utils.kPa2m
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/pyCATHY.cathy_utils.label_units.html">
       pyCATHY.cathy_utils.label_units
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/pyCATHY.cathy_utils.transform2_time_delta.html">
       pyCATHY.cathy_utils.transform2_time_delta
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../content/api/generated/pyCATHY.meshtools.html">
     <code class="docutils literal notranslate">
      <span class="pre">
       pyCATHY.meshtools
      </span>
     </code>
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-13" name="toctree-checkbox-13" type="checkbox"/>
    <label for="toctree-checkbox-13">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/pyCATHY.meshtools.CATHY_2_Resipy.html">
       pyCATHY.meshtools.CATHY_2_Resipy
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/pyCATHY.meshtools.CATHY_2_Simpeg.html">
       pyCATHY.meshtools.CATHY_2_Simpeg
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/pyCATHY.meshtools.CATHY_2_pg.html">
       pyCATHY.meshtools.CATHY_2_pg
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/pyCATHY.meshtools.add_attribute_2mesh.html">
       pyCATHY.meshtools.add_attribute_2mesh
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/pyCATHY.meshtools.add_markers2mesh.html">
       pyCATHY.meshtools.add_markers2mesh
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/pyCATHY.meshtools.create_layers_inzones3d.html">
       pyCATHY.meshtools.create_layers_inzones3d
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/pyCATHY.meshtools.find_nearest_node.html">
       pyCATHY.meshtools.find_nearest_node
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/pyCATHY.meshtools.get_layer_depth.html">
       pyCATHY.meshtools.get_layer_depth
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/pyCATHY.meshtools.get_layer_depths.html">
       pyCATHY.meshtools.get_layer_depths
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/pyCATHY.meshtools.get_zone3d_layer_depths.html">
       pyCATHY.meshtools.get_zone3d_layer_depths
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/pyCATHY.meshtools.het_soil_layers_mapping_generic.html">
       pyCATHY.meshtools.het_soil_layers_mapping_generic
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/pyCATHY.meshtools.map_layers_2_DEM.html">
       pyCATHY.meshtools.map_layers_2_DEM
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/pyCATHY.meshtools.plot_2d_interpolation_quality.html">
       pyCATHY.meshtools.plot_2d_interpolation_quality
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/pyCATHY.meshtools.plot_zones3d_layered.html">
       pyCATHY.meshtools.plot_zones3d_layered
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/pyCATHY.meshtools.set_interpolation_radius.html">
       pyCATHY.meshtools.set_interpolation_radius
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/pyCATHY.meshtools.trace_mesh.html">
       pyCATHY.meshtools.trace_mesh
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/pyCATHY.meshtools.trace_mesh_pg.html">
       pyCATHY.meshtools.trace_mesh_pg
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../content/api/generated/pyCATHY.meshtools.zone3d.html">
       pyCATHY.meshtools.zone3d
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../content/change_log.html">
   Change log
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../content/cathy_list_citation.html">
   Who uses CATHY ?
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../content/references.html">
   References
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Getting help and contributed
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../content/contribute.html">
   Contribute and support
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Theme by the <a href="https://ebp.jupyterbook.org">Executable Book Project</a>
</div>

</div>


          


          
<!-- This is an invisible pixel that we watch to see if we've scrolled. -->
<div class="sbt-scroll-pixel-helper"></div>
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            <div class="topbar-left">
                
                <label class="nav-toggle-button" for="__navigation">
                    <div class="visually-hidden">Toggle navigation</div>
                    <i class="fas fa-bars"></i>
                </label>
                
            </div>
            
            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/BenjMy/pycathy_wrapper"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        <a class="issues-button"
            href="https://github.com/BenjMy/pycathy_wrapper/issues/new?title=Issue%20on%20page%20%2F_modules/resipy/Project.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        
    </div>
</div>

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show noprint">
            
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1></h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                    </div>
                </div>
            </div>
            
              <div>
                
  <h1>Source code for resipy.Project</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This file is part of the ResIPy project (https://gitlab.com/hkex/resipy).</span>
<span class="sd">@licence: GPLv3</span>
<span class="sd">@author: ResIPy authors and contributors</span>

<span class="sd">The &#39;Project&#39; class wraps all main interactions between R* executables</span>
<span class="sd">and other filtering or meshing part of the code. It&#39;s the entry point for</span>
<span class="sd">the user.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="n">ResIPy_version</span> <span class="o">=</span> <span class="s1">&#39;3.4.1&#39;</span> <span class="c1"># ResIPy version (semantic versionning in use)</span>

<span class="c1">#import relevant modules</span>
<span class="kn">import</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">shutil</span><span class="o">,</span> <span class="nn">platform</span><span class="o">,</span> <span class="nn">warnings</span><span class="o">,</span> <span class="nn">time</span><span class="o">,</span> <span class="nn">glob</span> <span class="c1"># python standard libs</span>
<span class="kn">from</span> <span class="nn">subprocess</span> <span class="kn">import</span> <span class="n">PIPE</span><span class="p">,</span> <span class="n">call</span><span class="p">,</span> <span class="n">Popen</span>
<span class="kn">import</span> <span class="nn">psutil</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Thread</span>

<span class="c1"># used to download the binaries</span>
<span class="kn">import</span> <span class="nn">requests</span>
<span class="kn">import</span> <span class="nn">hashlib</span>

<span class="kn">import</span> <span class="nn">subprocess</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> <span class="c1"># import default 3rd party libaries (can be downloaded from conda repositry, incl with winpython)</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">matplotlib.tri</span> <span class="k">as</span> <span class="nn">tri</span>
<span class="kn">import</span> <span class="nn">matplotlib.patches</span> <span class="k">as</span> <span class="nn">mpatches</span>
<span class="kn">import</span> <span class="nn">matplotlib.path</span> <span class="k">as</span> <span class="nn">mpath</span>
<span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">cKDTree</span>

<span class="n">OS</span> <span class="o">=</span> <span class="n">platform</span><span class="o">.</span><span class="n">system</span><span class="p">()</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">relpath</span><span class="p">(</span><span class="s1">&#39;..&#39;</span><span class="p">))</span>

<span class="c1">#import ResIPy resipy packages</span>
<span class="kn">from</span> <span class="nn">resipy.Survey</span> <span class="kn">import</span> <span class="n">Survey</span>
<span class="kn">from</span> <span class="nn">resipy.parsers</span> <span class="kn">import</span> <span class="n">geomParser</span>
<span class="kn">from</span> <span class="nn">resipy.r2in</span> <span class="kn">import</span> <span class="n">write2in</span>
<span class="kn">import</span> <span class="nn">resipy.meshTools</span> <span class="k">as</span> <span class="nn">mt</span>
<span class="kn">from</span> <span class="nn">resipy.meshTools</span> <span class="kn">import</span> <span class="n">cropSurface</span>
<span class="kn">from</span> <span class="nn">resipy.template</span> <span class="kn">import</span> <span class="n">startAnmt</span><span class="p">,</span> <span class="n">endAnmt</span>
<span class="kn">from</span> <span class="nn">resipy.protocol</span> <span class="kn">import</span> <span class="p">(</span><span class="n">dpdp1</span><span class="p">,</span> <span class="n">dpdp2</span><span class="p">,</span> <span class="n">wenner_alpha</span><span class="p">,</span> <span class="n">wenner_beta</span><span class="p">,</span> <span class="n">wenner</span><span class="p">,</span>
                          <span class="n">wenner_gamma</span><span class="p">,</span> <span class="n">schlum1</span><span class="p">,</span> <span class="n">schlum2</span><span class="p">,</span> <span class="n">multigrad</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">resipy.SelectPoints</span> <span class="kn">import</span> <span class="n">SelectPoints</span>
<span class="kn">from</span> <span class="nn">resipy.saveData</span> <span class="kn">import</span> <span class="p">(</span><span class="n">write2Res2DInv</span><span class="p">,</span> <span class="n">write2csv</span><span class="p">,</span> <span class="n">writeSrv</span><span class="p">)</span>

<span class="n">apiPath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="vm">__file__</span><span class="p">),</span> <span class="s1">&#39;../&#39;</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;API path = &#39;</span><span class="p">,</span> <span class="n">apiPath</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ResIPy version = &#39;</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="n">ResIPy_version</span><span class="p">))</span>

<span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span><span class="p">)</span> <span class="c1"># this will show the deprecation warnings</span>

<span class="sd">&#39;&#39;&#39;NOTE</span>
<span class="sd">pre-processing and error models for unique, combined or multiple surveys:</span>
<span class="sd">    idea, using the value of the index argument to identify the scope of</span>
<span class="sd">    the function.</span>
<span class="sd">    index = -2 : apply/show data from combined survey (bigSurvey)</span>
<span class="sd">    index = -1 : apply to each datasets the same type of model</span>
<span class="sd">    index &gt; 0 : apply an error model to the selected unique survey</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="c1">#%% check executables are here</span>
<span class="k">def</span> <span class="nf">checkSHA1</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
    <span class="n">BUF_SIZE</span> <span class="o">=</span> <span class="mi">65536</span>  <span class="c1"># lets read stuff in 64kb chunks!</span>
    <span class="n">sha1</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">sha1</span><span class="p">()</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">BUF_SIZE</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">sha1</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sha1</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">checkExe</span><span class="p">(</span><span class="n">dirname</span><span class="p">):</span>
    <span class="n">exes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;cR2.exe&#39;</span><span class="p">,</span><span class="s1">&#39;R3t.exe&#39;</span><span class="p">,</span><span class="s1">&#39;cR3t.exe&#39;</span><span class="p">]</span><span class="c1">#,&#39;R2.exe&#39;,&#39;gmsh.exe&#39;]</span>
    <span class="n">hashes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;e35f0271439761726473fa2e696d63613226b2a5&#39;</span><span class="p">,</span>
              <span class="s1">&#39;44e47d7d7e7bb8e8e26be83da56819abbbfb89bc&#39;</span><span class="p">,</span>
              <span class="s1">&#39;9337435f018264771470d5d4312908b0d1242af1&#39;</span><span class="p">,</span>
              <span class="c1"># &#39;4aad36d5333ddf163c46bab9d3c2a799aa48716e&#39;,</span>
              <span class="c1"># &#39;91bd6e5fcb01a11d241456479c203624d0e681ed&#39;</span>
              <span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">exe</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">exes</span><span class="p">):</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirname</span><span class="p">,</span> <span class="n">exe</span><span class="p">)</span>
        <span class="n">download</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">download</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:s}</span><span class="s1"> not found, will download it...&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">exe</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># check if the file is up to date</span>
            <span class="n">sha1</span> <span class="o">=</span> <span class="n">checkSHA1</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sha1</span> <span class="o">!=</span> <span class="n">hashes</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">download</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:s}</span><span class="s1"> needs to be updated...&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">exe</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">download</span><span class="p">:</span>
            <span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;https://gitlab.com/hkex/resipy/-/raw/master/src/resipy/exe/&quot;</span> <span class="o">+</span> <span class="n">exe</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">content</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;done&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:s}</span><span class="s1"> found and up to date.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">exe</span><span class="p">))</span>

<span class="c1"># the below failed if no internet connection so let&#39;s put it in try/except                </span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">checkExe</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">apiPath</span><span class="p">,</span> <span class="s1">&#39;exe&#39;</span><span class="p">))</span>
<span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="k">pass</span>


<span class="c1"># little class for managing multiple processes (for parallel inversion)</span>
<span class="k">class</span> <span class="nc">ProcsManagement</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span> <span class="c1"># little class to handle the kill</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r2object</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r2</span> <span class="o">=</span> <span class="n">r2object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">killFlag</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">def</span> <span class="nf">kill</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">killFlag</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;killing...&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r2</span><span class="o">.</span><span class="n">irunParallel2</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># this will end the infinite loop</span>
        <span class="n">procs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r2</span><span class="o">.</span><span class="n">procs</span> <span class="c1"># and kill the running processes</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">procs</span><span class="p">:</span>
            <span class="n">p</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;all done&#39;</span><span class="p">)</span>
        
<span class="c1">#%% system check</span>
<span class="k">def</span> <span class="nf">getSysStat</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return processor speed and usage, and free RAM and usage. </span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cpu_speed: float</span>
<span class="sd">        in Mhz.</span>
<span class="sd">    cpu_usage: float</span>
<span class="sd">        in percent. </span>
<span class="sd">    ram_avail: float</span>
<span class="sd">        avialable memory.</span>
<span class="sd">    ram_usage: float</span>
<span class="sd">        in percent. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#processor info</span>
    <span class="k">try</span><span class="p">:</span> <span class="c1"># for Apple silicon</span>
        <span class="n">cpu_speed</span> <span class="o">=</span> <span class="n">psutil</span><span class="o">.</span><span class="n">cpu_freq</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">cpu_speed</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">cpu_usage</span> <span class="o">=</span> <span class="n">psutil</span><span class="o">.</span><span class="n">cpu_percent</span><span class="p">()</span>
        
    <span class="c1">#check the amount of ram avialable </span>
    <span class="n">ram</span> <span class="o">=</span> <span class="n">psutil</span><span class="o">.</span><span class="n">virtual_memory</span><span class="p">()</span>
    <span class="n">ram_avail</span> <span class="o">=</span> <span class="n">ram</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mf">9.31e-10</span>
    <span class="n">ram_usage</span> <span class="o">=</span> <span class="n">ram</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">cpu_speed</span><span class="p">,</span> <span class="n">cpu_usage</span><span class="p">,</span> <span class="n">ram_avail</span><span class="p">,</span> <span class="n">ram_usage</span> 

<span class="k">def</span> <span class="nf">getMacOSVersion</span><span class="p">():</span>
    <span class="n">OpSys</span><span class="o">=</span><span class="n">platform</span><span class="o">.</span><span class="n">system</span><span class="p">()</span>    
    <span class="k">if</span> <span class="n">OpSys</span><span class="o">==</span><span class="s1">&#39;Darwin&#39;</span><span class="p">:</span>
        <span class="n">versionList</span> <span class="o">=</span> <span class="n">platform</span><span class="o">.</span><span class="n">mac_ver</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
        <span class="n">macVersion</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">versionList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="n">versionList</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># not getting patch version so xx.xx only</span>
        <span class="k">if</span> <span class="n">macVersion</span> <span class="o">&gt;=</span> <span class="mf">10.15</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        
<span class="k">def</span> <span class="nf">systemCheck</span><span class="p">(</span><span class="n">dump</span><span class="o">=</span><span class="nb">print</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Performs a simple diagnostic of the system, no input commands needed. System</span>
<span class="sd">    info is printed to screen, number of CPUs, memory and OS. This check is </span>
<span class="sd">    useful for parallel processing. </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dump : function</span>
<span class="sd">        stdout pointer</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    system_info: dict</span>
<span class="sd">        Dictionary keys refer information about the system </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dump</span><span class="p">(</span><span class="s2">&quot;________________System-Check__________________&quot;</span><span class="p">)</span>
    <span class="c1">#check operating system </span>
    <span class="n">OpSys</span><span class="o">=</span><span class="n">platform</span><span class="o">.</span><span class="n">system</span><span class="p">()</span>    
    <span class="k">if</span> <span class="n">OpSys</span><span class="o">==</span><span class="s1">&#39;Darwin&#39;</span><span class="p">:</span>
        <span class="n">dump</span><span class="p">(</span><span class="s2">&quot;Kernel type: macOS&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dump</span><span class="p">(</span><span class="s2">&quot;Kernel type: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="n">OpSys</span><span class="p">)</span>
    
    <span class="n">totalMemory</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># incase system can&#39;t figure it out!</span>
    <span class="n">num_threads</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="c1">#display processor info</span>
    <span class="n">dump</span><span class="p">(</span><span class="s2">&quot;Processor info: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="n">platform</span><span class="o">.</span><span class="n">processor</span><span class="p">())</span>
    <span class="n">cpu_cores</span> <span class="o">=</span> <span class="n">psutil</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">(</span><span class="n">logical</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">physical_cores</span> <span class="o">=</span> <span class="n">psutil</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">(</span><span class="n">logical</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span> <span class="c1"># for Apple silicon</span>
        <span class="n">max_freq</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">psutil</span><span class="o">.</span><span class="n">cpu_freq</span><span class="p">())</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">max_freq</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">dump</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%i</span><span class="s2"> Threads at &lt;= </span><span class="si">%5.1f</span><span class="s2"> Mhz&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">cpu_cores</span><span class="p">,</span><span class="n">max_freq</span><span class="p">))</span>
    <span class="n">dump</span><span class="p">(</span><span class="s2">&quot;(</span><span class="si">%i</span><span class="s2">)&quot;</span><span class="o">%</span><span class="n">physical_cores</span><span class="p">)</span>
    
    <span class="c1">#check the amount of ram </span>
    <span class="n">ram</span> <span class="o">=</span> <span class="n">psutil</span><span class="o">.</span><span class="n">virtual_memory</span><span class="p">()</span>
    <span class="n">totalMemory</span> <span class="o">=</span> <span class="n">ram</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mf">9.31e-10</span>
    <span class="n">availMemory</span> <span class="o">=</span> <span class="n">ram</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mf">9.31e-10</span>
    <span class="n">usage</span> <span class="o">=</span> <span class="n">ram</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">dump</span><span class="p">(</span><span class="s1">&#39;Total memory = </span><span class="si">%3.1f</span><span class="s1"> Gb (usage = </span><span class="si">%3.1f</span><span class="s1">)&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">totalMemory</span><span class="p">,</span><span class="n">usage</span><span class="p">))</span>
    
    <span class="c1">#wine check - this message will display if wine is not installed / detected</span>
    <span class="n">helpful_msg</span> <span class="o">=</span><span class="s2">&quot;&quot;&quot;   </span>
<span class="s2">This version of ResIPy requires wine to run R2.exe, please consider installing</span>
<span class="s2">&#39;wine is not an emulator&#39; package @ https://www.winehq.org/. On linux wine can be found on</span>
<span class="s2">most reprositories (ubuntu/debian users can use &quot;sudo apt install wine-stable&quot;). Wine acts as</span>
<span class="s2">a compatiblity layer between unix like OS systems (ie macOS and linux) and windows programs. </span>
<span class="s2">    &quot;&quot;&quot;</span>
    <span class="n">wineCheck</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">msg_flag</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">OpSys</span><span class="o">==</span><span class="s2">&quot;Linux&quot;</span><span class="p">:</span>
        <span class="c1">#detect wine </span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">Popen</span><span class="p">(</span><span class="s2">&quot;wine --version&quot;</span><span class="p">,</span> <span class="n">stdout</span><span class="o">=</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">shell</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">is_wine</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">readline</span><span class="p">())</span><span class="c1">#[0].split()[0]</span>
        <span class="k">if</span> <span class="n">is_wine</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;wine&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Wine is not installed!&quot;</span><span class="p">,</span> <span class="ne">Warning</span><span class="p">)</span>
            <span class="n">msg_flag</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">wineCheck</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">wine_version</span> <span class="o">=</span> <span class="n">is_wine</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">dump</span><span class="p">(</span><span class="s2">&quot;Wine version = &quot;</span><span class="o">+</span><span class="n">wine_version</span><span class="p">)</span>
                          
    <span class="k">elif</span> <span class="n">OpSys</span><span class="o">==</span><span class="s2">&quot;Windows&quot;</span><span class="p">:</span>
        <span class="n">dump</span><span class="p">(</span><span class="s1">&#39;Wine Version = Native Windows (N/A)&#39;</span><span class="p">)</span>
                
    <span class="k">elif</span> <span class="n">OpSys</span><span class="o">==</span><span class="s1">&#39;Darwin&#39;</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span> 
            <span class="n">winetxt</span> <span class="o">=</span> <span class="s1">&#39;wine&#39;</span>
            <span class="k">if</span> <span class="n">getMacOSVersion</span><span class="p">():</span>
                <span class="n">winetxt</span> <span class="o">=</span> <span class="s1">&#39;wine64&#39;</span> 
            <span class="n">winePath</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">wine_path</span> <span class="o">=</span> <span class="n">Popen</span><span class="p">([</span><span class="s1">&#39;which&#39;</span><span class="p">,</span> <span class="n">winetxt</span><span class="p">],</span> <span class="n">stdout</span><span class="o">=</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">shell</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">universal_newlines</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="c1">#.communicate()[0]</span>
            <span class="k">for</span> <span class="n">stdout_line</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="n">wine_path</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">readline</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">):</span>
                <span class="n">winePath</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stdout_line</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">winePath</span> <span class="o">!=</span> <span class="p">[]:</span>
                <span class="n">is_wine</span> <span class="o">=</span> <span class="n">Popen</span><span class="p">([</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">winePath</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)),</span> <span class="s1">&#39;--version&#39;</span><span class="p">],</span> <span class="n">stdout</span><span class="o">=</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">shell</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">universal_newlines</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">global</span> <span class="n">wPath</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">is_wine</span> <span class="o">=</span> <span class="n">Popen</span><span class="p">([</span><span class="s1">&#39;/usr/local/bin/</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">winetxt</span><span class="p">,</span><span class="s1">&#39;--version&#39;</span><span class="p">],</span> <span class="n">stdout</span><span class="o">=</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">shell</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">universal_newlines</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">wPath</span> <span class="o">=</span> <span class="s1">&#39;/usr/local/bin/&#39;</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">is_wine</span> <span class="o">=</span> <span class="n">Popen</span><span class="p">([</span><span class="s1">&#39;/opt/homebrew/bin/</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">winetxt</span><span class="p">,</span><span class="s1">&#39;--version&#39;</span><span class="p">],</span> <span class="n">stdout</span><span class="o">=</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">shell</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">universal_newlines</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># quick fix for M1 Macs</span>
                    <span class="n">wPath</span> <span class="o">=</span> <span class="s1">&#39;/opt/homebrew/bin/&#39;</span>
            <span class="n">wineVersion</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">stdout_line</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="n">is_wine</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">readline</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">):</span>
                <span class="n">wineVersion</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stdout_line</span><span class="p">)</span>
            <span class="n">wine_version</span> <span class="o">=</span> <span class="n">stdout_line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">dump</span><span class="p">(</span><span class="s2">&quot;Wine version = &quot;</span><span class="o">+</span><span class="n">wine_version</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Wine is not installed!&quot;</span><span class="p">,</span> <span class="ne">Warning</span><span class="p">)</span>
            <span class="n">msg_flag</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">wineCheck</span> <span class="o">=</span> <span class="kc">False</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">OpSys</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s2">&quot;unrecognised/unsupported operating system&quot;</span><span class="p">)</span>
            
    <span class="k">if</span> <span class="n">msg_flag</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dump</span> <span class="o">!=</span> <span class="nb">print</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">helpful_msg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dump</span><span class="p">(</span><span class="n">helpful_msg</span><span class="p">)</span>
            
    <span class="c1">#check graphics unit </span>
    <span class="n">dump</span><span class="p">(</span><span class="s2">&quot;GPU info: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">gpuinfo</span><span class="p">))</span>
    
    <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;totalMemory&#39;</span><span class="p">:</span><span class="n">totalMemory</span><span class="p">,</span>
            <span class="s1">&#39;availMemory&#39;</span><span class="p">:</span><span class="n">availMemory</span><span class="p">,</span>
            <span class="s1">&#39;cpuCount&#39;</span><span class="p">:</span><span class="n">cpu_cores</span><span class="p">,</span>
            <span class="s1">&#39;physicalCpuCount&#39;</span><span class="p">:</span><span class="n">physical_cores</span><span class="p">,</span> 
            <span class="s1">&#39;maxFreq&#39;</span><span class="p">:</span><span class="n">max_freq</span><span class="p">,</span>
            <span class="s1">&#39;OS&#39;</span><span class="p">:</span><span class="n">OpSys</span><span class="p">,</span>
            <span class="s1">&#39;wineCheck&#39;</span><span class="p">:</span><span class="n">wineCheck</span><span class="p">,</span>
            <span class="s1">&#39;GPU&#39;</span><span class="p">:</span><span class="n">mt</span><span class="o">.</span><span class="n">gpuinfo</span><span class="p">}</span>

<span class="k">def</span> <span class="nf">pointer</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">pass</span>
<span class="n">sysinfo</span> <span class="o">=</span> <span class="n">systemCheck</span><span class="p">(</span><span class="n">dump</span><span class="o">=</span><span class="n">pointer</span><span class="p">)</span>

<span class="c1">#%% useful functions</span>
<span class="k">class</span> <span class="nc">cd</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Context manager for changing the current working directory&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newPath</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">newPath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="n">newPath</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">savedPath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
        <span class="n">os</span><span class="o">.</span><span class="n">chdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">newPath</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">etype</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">chdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">savedPath</span><span class="p">)</span>

<span class="c1"># distance matrix function for 2D (numpy based from https://stackoverflow.com/questions/22720864/efficiently-calculating-a-euclidean-distance-matrix-using-numpy)</span>
<span class="k">def</span> <span class="nf">cdist</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">complex</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">a</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">-</span><span class="n">z</span><span class="p">)</span>



<span class="c1">#%% main Project class (called &#39;R2&#39; in previous versions)</span>
<span class="k">class</span> <span class="nc">Project</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span> <span class="c1"># Project master class instanciated by the GUI</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Master class to handle all processing around the inversion codes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dirname : str, optional</span>
<span class="sd">        Path of the working directory. Can also be set using `R2.setwd()`.</span>
<span class="sd">    typ : str, optional</span>
<span class="sd">        Either `R2` or `R3t` for 3D. Complex equivalents are `cR2` and `cR3t`.</span>
<span class="sd">        Automatically infered when creating the survey.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dirname</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">typ</span><span class="o">=</span><span class="s1">&#39;R2&#39;</span><span class="p">):</span> <span class="c1"># initiate R2 class</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">apiPath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="vm">__file__</span><span class="p">))</span> <span class="c1"># directory of the code</span>
        <span class="k">if</span> <span class="n">dirname</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="n">dirname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">apiPath</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dirname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">dirname</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Working directory is:&#39;</span><span class="p">,</span> <span class="n">dirname</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setwd</span><span class="p">(</span><span class="n">dirname</span><span class="p">)</span> <span class="c1"># working directory (for the datas)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elec</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># will be assigned when creating a survey</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># list of survey object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surveysInfo</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># info about surveys (date)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># mesh object (one per Project instance)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meshParams</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># mesh parameters passed to mesh creation scheme </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">topo</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="s1">&#39;z&#39;</span><span class="p">])</span> <span class="c1"># store additional topo points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># dict configuration variables for inversion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">configFile</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invLog</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span> <span class="c1"># to save inversion output - all R2.out files</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fwdLog</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span> <span class="c1"># to save forward modeling R2_forward.out files</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">=</span> <span class="n">typ</span> <span class="c1"># or cR2 or R3t, cR3</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">err</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># if we want error in protocol.dat or not</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iBorehole</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># to tell the software to not plot pseudoSection</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iTimeLapse</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># to enable timelapse inversion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iBatch</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># to enable batch inversion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meshResults</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># contains vtk mesh object of inverted section</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">projs</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># contains Instances of Project for pseudo 3D inversion from 2D lines</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">projectPseudo3D</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># updates iteratively - for showing pseudo 3D inversion iterations, killing, etc.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pseudo3DBreakFlag</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># flag to cancel inversions in a chain (pseudo3D only)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pseudo3DSurvey</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># contains one survey instance with all 2D lines combined in a 3D grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pseudo3DMeshResult</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># contains pseudo 3D mesh result (for external use - e.g., ParaView)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pseudo3DMeshResultList</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># contains pseudo 3D meshes (individual 2D lines in 3D space - for external use - e.g., ParaView)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pseudo3Dfmd</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># pseudo3D project FMD (only used when user defines a FMD in createMultiMesh())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sequence</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># quadrupoles sequence if forward model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resist0</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># initial resistivity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iForward</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># if True, it will use the output of the forward</span>
        <span class="c1"># to run an inversion (and so need to reset the regions before this)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fmd</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># depth of investigation below the surface [in survey units]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proc</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># where the process to run R2/cR2 will be</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mproc</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># where the process for mesh building</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zlim</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># zlim to plot the mesh by default (from max(elec, topo) to min(doi, elec))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trapeziod</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># trapeziod vertices of cropped 2D mesh (triangles removed from bottom corners)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">geom_input</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># dictionnary used to create the mesh</span>
        <span class="c1"># attributes needed for independant error model for timelapse/batch inversion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">referenceMdl</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># is there a starting reference model already?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fwdErrModel</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># is there is a impoforward modelling error already (due to the mesh)?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">custSeq</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># flag - True if of 3D custom sequence imported</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errTyp</span> <span class="o">=</span> <span class="s1">&#39;global&#39;</span><span class="c1"># type of error model to be used in batch and timelapse surveys</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfaceIdx</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># used to show plan view iterations of 3D inversions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">darkMode</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># If true, electrodes wil be plotted in white, else black</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iadvanced</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># If true, use the advanced mesh format for 3D mesh</span>
        
        
            
    <span class="k">def</span> <span class="nf">setBorehole</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set all surveys in borehole type if `True` is passed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iBorehole</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">:</span>
            <span class="n">s</span><span class="o">.</span><span class="n">iBorehole</span> <span class="o">=</span> <span class="n">val</span>


    <span class="k">def</span> <span class="nf">_num2elec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elec</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a formated dataframe with &#39;x&#39;,&#39;y&#39;,&#39;z&#39;,&#39;label&#39;,&#39;remote&#39;,&#39;buried&#39;</span>
<span class="sd">        columns wether the input is a sparse matrix or dataframe.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">elec</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">elec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">elec</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">elec</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">elec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">elec</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">elec</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;z&#39;</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">elec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">elec</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">elec</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="s1">&#39;z&#39;</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">elec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">elec</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">elec</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="s1">&#39;z&#39;</span><span class="p">,</span><span class="s1">&#39;buried&#39;</span><span class="p">])</span>
                <span class="n">elec</span><span class="p">[</span><span class="s1">&#39;buried&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">elec</span><span class="p">[</span><span class="s1">&#39;buried&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;line&#39;</span> <span class="ow">in</span> <span class="n">elec</span><span class="o">.</span><span class="n">columns</span> <span class="ow">and</span> <span class="s1">&#39;number&#39;</span> <span class="ow">in</span> <span class="n">elec</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>                
            <span class="n">elecid</span>  <span class="o">=</span> <span class="n">elec</span><span class="o">.</span><span class="n">number</span><span class="o">.</span><span class="n">values</span> <span class="c1"># electrode number array </span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">elec</span><span class="o">.</span><span class="n">line</span><span class="o">.</span><span class="n">values</span> 
            <span class="n">label</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;1 1&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">elec</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">elec</span><span class="p">)):</span>
                <span class="n">label</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%i</span><span class="s1"> </span><span class="si">%i</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">elecid</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">elec</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="s1">&#39;label&#39;</span><span class="p">,</span><span class="n">label</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;y&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">elec</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">elec</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># all on same line by default</span>
        <span class="k">if</span> <span class="s1">&#39;z&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">elec</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">elec</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># all flat topo by default</span>
        <span class="k">if</span> <span class="s1">&#39;remote&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">elec</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">elec</span><span class="p">[</span><span class="s1">&#39;remote&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># all non remote by default</span>
        <span class="k">if</span> <span class="s1">&#39;buried&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">elec</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">elec</span><span class="p">[</span><span class="s1">&#39;buried&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># all surface elec by default</span>
        <span class="k">if</span> <span class="s1">&#39;label&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">elec</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">elec</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">elec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="c1"># all elec ordered and start at 1            </span>
        <span class="n">elec</span> <span class="o">=</span> <span class="n">elec</span><span class="o">.</span><span class="n">astype</span><span class="p">({</span><span class="s1">&#39;x&#39;</span><span class="p">:</span><span class="nb">float</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span><span class="nb">float</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span><span class="nb">float</span><span class="p">,</span> <span class="s1">&#39;buried&#39;</span><span class="p">:</span><span class="nb">bool</span><span class="p">,</span> <span class="s1">&#39;remote&#39;</span><span class="p">:</span><span class="nb">bool</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">:</span><span class="nb">str</span><span class="p">})</span>
        
        <span class="k">return</span> <span class="n">elec</span>
    
    
    
    <span class="k">def</span> <span class="nf">_findRemote</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elec</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Flag remote electrodes.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elec : dataframe</span>
<span class="sd">            contains the electrodes information</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        elec : dataframe</span>
<span class="sd">            remote flag added to electrodes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">remote_flags</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">9999999</span><span class="p">,</span> <span class="o">-</span><span class="mi">999999</span><span class="p">,</span> <span class="o">-</span><span class="mi">99999</span><span class="p">,</span><span class="o">-</span><span class="mi">9999</span><span class="p">,</span><span class="o">-</span><span class="mi">999</span><span class="p">,</span>
                    <span class="mi">9999999</span><span class="p">,</span> <span class="mi">999999</span><span class="p">,</span> <span class="mi">99999</span><span class="p">,</span> <span class="mi">9999</span><span class="p">,</span> <span class="mi">999</span><span class="p">]</span> <span class="c1"># values asssociated with remote electrodes</span>
        <span class="n">iremote</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">remote_flags</span><span class="p">)</span>
        <span class="n">iremote</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">elec</span><span class="p">[[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="s1">&#39;z&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">iremote</span>
        <span class="n">elec</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;remote&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">iremote</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">iremote</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Detected </span><span class="si">{:d}</span><span class="s1"> remote electrode.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">iremote</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">elec</span>


    
    <span class="k">def</span> <span class="nf">setElec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">elecList</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set electrodes. Automatically identified remote electrode.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elec : numpy array</span>
<span class="sd">            Array of NxM dimensions. N = number of electrodes, M = 2 for x,z or</span>
<span class="sd">            M = 3 if x,y,z coordinates are supplied.</span>
<span class="sd">        elecList : list, optional</span>
<span class="sd">            If not None then elec is ignored in favor of elecList. This option</span>
<span class="sd">            is to be used in the advanced use case where electrodes move which</span>
<span class="sd">            each survey. Each entry of the list is a numpy array the same format</span>
<span class="sd">            of &#39;elec&#39;, which is then assigned to each survey class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">elecList</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># same electrode set shared by all surveys (most common case)</span>
            <span class="n">ok</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">elec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num2elec</span><span class="p">(</span><span class="n">elec</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># electrode already inferred when parsing data</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iForward</span><span class="p">:</span> <span class="c1"># in case of forward modelling, changing the number of electrodes is allowed</span>
                    <span class="n">ok</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1"># check intersection of labels</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">s1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
                        <span class="n">s2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">df</span><span class="p">[[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;m&#39;</span><span class="p">,</span><span class="s1">&#39;n&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
                        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">s2</span><span class="p">):</span>
                            <span class="n">ok</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The following electrode labels are missing&#39;</span>
                                  <span class="s1">&#39; from the electrode declaration: &#39;</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">s2</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="n">x</span><span class="p">)]))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">elec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                            <span class="n">ok</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The number of electrodes read (</span><span class="si">{:d}</span><span class="s1">) is smaller&#39;</span>
                              <span class="s1">&#39; than the number of electrode from data file (</span><span class="si">{:d}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                  <span class="n">elec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>                
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ok</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># first assignement of electrodes</span>
            <span class="k">if</span> <span class="n">ok</span><span class="p">:</span>
                <span class="n">elec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_findRemote</span><span class="p">(</span><span class="n">elec</span><span class="p">)</span> <span class="c1"># identification of remote electrode</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">elec</span> <span class="o">=</span> <span class="n">elec</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">:</span>
                    <span class="n">s</span><span class="o">.</span><span class="n">elec</span> <span class="o">=</span> <span class="n">elec</span>
            
            <span class="c1"># check for shared electrodes (between lines) or duplicated</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_checkElecDuplicate</span><span class="p">()</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#some error checking</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">num_surveys</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">)</span> <span class="c1"># number of surveys</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">elecList</span><span class="p">)</span> <span class="o">!=</span> <span class="n">num_surveys</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The number of electrode matrices must match the number of surveys&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No Survey attribute assocaited with R2 class, make sure you create a survey first&quot;</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">initElec</span> <span class="o">=</span> <span class="n">elecList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">elec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num2elec</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">initElec</span><span class="p">),</span><span class="mi">3</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">survey</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">):</span>
                <span class="n">survey</span><span class="o">.</span><span class="n">elec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_findRemote</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_num2elec</span><span class="p">(</span><span class="n">elecList</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="c1"># plus identification of remote electrode</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">computeFineMeshDepth</span><span class="p">()</span>
            
    
    <span class="k">def</span> <span class="nf">mergeElec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dist</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Merge electrodes that have less than a certain distance to eache other</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dist : float, optional</span>
<span class="sd">            maximum distance of close electrodes in meters (electrodes that have a distance less than dist will be merged)</span>
<span class="sd">            -1 flag for auto calculation where dist = average(electrode spacing)/100</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            True: merge successful</span>
<span class="sd">            False: merge unsuccessful</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">distance</span>
        
        <span class="n">eleccoors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="s1">&#39;z&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="n">dist</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">distance</span><span class="o">.</span><span class="n">cdist</span><span class="p">(</span><span class="n">eleccoors</span><span class="p">,</span> <span class="n">eleccoors</span><span class="p">))</span><span class="o">/</span><span class="mi">100</span>
        
        <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">closepairsL</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># empty list to get len(closepairsL) == 0 in loop&#39;s first step (i=0)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">50</span><span class="p">):</span>
            <span class="n">elecdists</span> <span class="o">=</span> <span class="n">distance</span><span class="o">.</span><span class="n">cdist</span><span class="p">(</span><span class="n">eleccoors</span><span class="p">,</span> <span class="n">eleccoors</span><span class="p">)</span>
            <span class="n">elecdists</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">triu_indices</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">elecdists</span><span class="p">))]</span> <span class="o">=</span> <span class="n">dist</span>
            <span class="n">elecdists</span><span class="p">[</span><span class="n">elecdists</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span>
            
            <span class="c1"># indices of pairs with distance &lt; dist</span>
            <span class="n">closepairs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">elecdists</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">elecdists</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="p">)[</span><span class="mi">1</span><span class="p">]]</span>
            
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">closepairs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">closepairsL</span><span class="p">):</span> 
                <span class="n">c</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">c</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">:</span>
                <span class="k">break</span>
            
            <span class="n">poses</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">closepairs</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">poses</span><span class="p">)):</span>
                <span class="n">poses</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">closepairs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">closepairs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">closepairs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="k">else</span> <span class="n">closepairs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
            
            <span class="n">eleccoors</span><span class="p">[</span><span class="n">closepairs</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">eleccoors</span><span class="p">[</span><span class="n">poses</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">closepairsL</span> <span class="o">=</span> <span class="n">closepairs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">elecdf_temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># to make it compatible with the new self.setElec</span>
            <span class="n">elecdf_temp</span><span class="p">[[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="s1">&#39;z&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">eleccoors</span>
            
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">closepairs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Merging close electrodes successful!&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">setElec</span><span class="p">(</span><span class="n">elecdf_temp</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">True</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">closepairs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># solution did not converge</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Merging close electrodes unsuccessful - Choose a shorter merging distance (i.e., dist &lt; </span><span class="si">{:.2f}</span><span class="s1">m)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dist</span><span class="p">))</span>
            <span class="k">return</span> <span class="kc">False</span>
    
    
    <span class="k">def</span> <span class="nf">_checkElecDuplicate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check for duplicated electrodes positions and merge them</span>
<span class="sd">        to the same label in this case. Useful for 3D survey from 2D lines,</span>
<span class="sd">        if multiple lines shared have electrodes in common.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># from: https://stackoverflow.com/questions/46629518/find-indices-of-duplicate-rows-in-pandas-dataframe</span>
        <span class="n">elec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">elec</span><span class="p">[[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="s1">&#39;z&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">iunique</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">iunique</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Merging electrodes positionned at the same location.&#39;</span><span class="p">)</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">iunique</span><span class="p">]</span>
            <span class="n">dups</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">df</span><span class="p">))</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">index</span><span class="p">))</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            
            <span class="k">for</span> <span class="n">dup</span> <span class="ow">in</span> <span class="n">dups</span><span class="p">:</span>
                <span class="n">dico</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">label2keep</span> <span class="o">=</span> <span class="n">elec</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">dup</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;label&#39;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dup</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                    <span class="n">label</span> <span class="o">=</span> <span class="n">elec</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index</span><span class="p">,</span><span class="s1">&#39;label&#39;</span><span class="p">]</span> <span class="c1"># label of duplicated electrodes</span>
                    <span class="n">dico</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">label2keep</span>
                    <span class="c1"># check through elec for each survey                        </span>
                    <span class="k">for</span> <span class="n">survey</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">label2keep</span> <span class="ow">in</span> <span class="n">survey</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">:</span>
                            <span class="c1"># if the label2keep is present, just remove the duplicate</span>
                             <span class="n">i2keep</span> <span class="o">=</span> <span class="n">survey</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">label</span>
                             <span class="n">survey</span><span class="o">.</span><span class="n">elec</span> <span class="o">=</span> <span class="n">survey</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="n">i2keep</span><span class="p">]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span> <span class="c1"># if not just renamed its label</span>
                            <span class="n">survey</span><span class="o">.</span><span class="n">elec</span> <span class="o">=</span> <span class="n">survey</span><span class="o">.</span><span class="n">elec</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">to_replace</span><span class="o">=</span><span class="n">dico</span><span class="p">)</span>
                <span class="c1"># and we replace (not remove) the label by the label of the first </span>
                <span class="c1"># occurence of the duplicated electrode</span>
                <span class="k">for</span> <span class="n">survey</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">:</span>
                    <span class="n">survey</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">survey</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">to_replace</span><span class="o">=</span><span class="n">dico</span><span class="p">)</span>
                    
                <span class="c1"># finally we remove duplicates from the Project instance itself</span>
                <span class="k">if</span> <span class="n">label2keep</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">:</span>
                    <span class="c1"># if the label2keep is present, just remove the duplicate</span>
                     <span class="n">i2keep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">label</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">elec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="n">i2keep</span><span class="p">]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1"># if not just renamed its label</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">elec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">to_replace</span><span class="o">=</span><span class="n">dico</span><span class="p">)</span>
                
                
            
    <span class="k">def</span> <span class="nf">generateElec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nb</span><span class="o">=</span><span class="mi">24</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">dz</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">nline</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">lineSpacing</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate electrodes positions for 2D and 3D surveys.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nb : int, optional</span>
<span class="sd">            Number of electrodes per line. For 3D survey, if multiple lines,</span>
<span class="sd">            the total number of electrodes will be nb x nline.</span>
<span class="sd">        dx : float, optional</span>
<span class="sd">            Spacing in meters between electrodes in the X direction.</span>
<span class="sd">        dz : float, optional</span>
<span class="sd">            Increment in the Z direction (elevation) between consecutive electrodes.</span>
<span class="sd">        nline : int, optional</span>
<span class="sd">            Number of lines. 1 for 2D and multiple for 3D.</span>
<span class="sd">        lineSpacing : float, optional</span>
<span class="sd">            Spacing between lines (3D only).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check type</span>
        <span class="n">nb</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nb</span><span class="p">)</span>
        <span class="n">nline</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nline</span><span class="p">)</span>
        
        <span class="c1"># electrode positions for one line</span>
        <span class="n">elec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nb</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">elec</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">nb</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span><span class="p">,</span> <span class="n">nb</span><span class="p">)</span>
        <span class="n">elec</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">nb</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">dz</span><span class="p">,</span> <span class="n">nb</span><span class="p">)</span>
        
        <span class="c1"># specific 2D or 3D additions and building dfelec</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;R2&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;cR2&#39;</span><span class="p">):</span>
            <span class="n">dfelec</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">,</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="s1">&#39;z&#39;</span><span class="p">,</span><span class="s1">&#39;buried&#39;</span><span class="p">])</span>
            <span class="n">dfelec</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nb</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
            <span class="n">dfelec</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="s1">&#39;z&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">elec</span>
            <span class="n">dfelec</span><span class="p">[</span><span class="s1">&#39;buried&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">elec</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">nline</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nline</span><span class="p">):</span>
                <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="s1">&#39;</span><span class="si">{:d}</span><span class="s1"> </span><span class="si">{:d}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb</span><span class="p">)])</span> <span class="c1"># string + elec number</span>
                <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">nb</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">nb</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">lineSpacing</span> <span class="c1"># Y is line spacing</span>
            <span class="n">dfelec</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">,</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="s1">&#39;z&#39;</span><span class="p">,</span><span class="s1">&#39;buried&#39;</span><span class="p">])</span>
            <span class="n">dfelec</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
            <span class="n">dfelec</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">dfelec</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">dfelec</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">dfelec</span><span class="p">[</span><span class="s1">&#39;buried&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">setElec</span><span class="p">(</span><span class="n">dfelec</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">hasElecString</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Determine if a electrode strings are present in the electrode labels </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            True if strings present in electrode label</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span>
        <span class="k">if</span> <span class="s1">&#39;label&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">label</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">())</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>
        
        
    <span class="k">def</span> <span class="nf">detectStrings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">max_itr</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Automatically detect electrode strings </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tolerance : float, optional</span>
<span class="sd">            Maximum (+/-) bearing (ie directional angle) tolerance each subsiquent</span>
<span class="sd">            electrode may have. The default is 5.</span>
<span class="sd">        max_itr : int, optional</span>
<span class="sd">            Maximum number of searches that can be performed to find colinear</span>
<span class="sd">            nieghbouring electrodes. The default is None.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            if the change in x and y direction for 2 neighbouring electrodes is </span>
<span class="sd">            the same. ie no 2 electrodes can occupy the same x y position in </span>
<span class="sd">            this code. </span>
<span class="sd">        ValueError</span>
<span class="sd">            if the change maxium number of searches is exceeded. </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list (of list)</span>
<span class="sd">            Each entry in the list corresponds to an electrode string, and is</span>
<span class="sd">            a list of integers which are the indices of the respective electrodes</span>
<span class="sd">            in self.elec</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># compute bearing </span>
        <span class="k">def</span> <span class="nf">bearing</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span><span class="n">dy</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">dx</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">dy</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;both dx and dy equal 0 - check no 2 electrodes occupy same xy coordinates&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">dx</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">dy</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">dx</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">dy</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">180</span>
            <span class="k">elif</span> <span class="n">dx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">dy</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">90</span>
            <span class="k">elif</span> <span class="n">dx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">dy</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">270</span>
            <span class="k">elif</span> <span class="n">dx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">dy</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> 
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">dx</span><span class="o">/</span><span class="n">dy</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">dx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">dy</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> 
                <span class="k">return</span> <span class="mi">180</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">dx</span><span class="o">/</span><span class="n">dy</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">dx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">dy</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> 
                <span class="k">return</span> <span class="mi">180</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">dx</span><span class="o">/</span><span class="n">dy</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">dx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">dy</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> 
                <span class="k">return</span> <span class="mi">360</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">dx</span><span class="o">/</span><span class="n">dy</span><span class="p">))</span>

        <span class="n">iremote</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;remote&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="o">~</span><span class="n">iremote</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="o">~</span><span class="n">iremote</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">max_itr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">max_itr</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">+</span><span class="mi">10</span>
        <span class="c1"># init - nb couple of commented lines are in here for displaying the selected electrode strings </span>
        <span class="c1"># fig, ax = plt.subplots()</span>
        <span class="c1"># ax.scatter(x,y,c=&#39;k&#39;)</span>
        <span class="c1"># ax.set_aspect(&#39;equal&#39;)</span>
        
        <span class="c1"># mid point of survey </span>
        <span class="n">xm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">ym</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="c1"># ax.scatter(xm,ym,c=&#39;b&#39;,s=2)</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">xm</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">ym</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># distance to all other points in survey</span>
        
        <span class="c1"># find neighbours </span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">cKDTree</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="n">distm</span><span class="p">,</span> <span class="n">niegh</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">points</span><span class="p">,</span><span class="n">k</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
        
        <span class="c1">#start finding strings </span>
        <span class="n">string</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># caches for saving found electrodes</span>
        <span class="n">allocated</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span> 
        
        <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span> 
        <span class="k">while</span> <span class="nb">any</span><span class="p">(</span><span class="n">allocated</span><span class="o">==</span><span class="kc">False</span><span class="p">):</span>
            <span class="c1">#color = tuple(np.random.rand(3)) # color for line </span>
            <span class="c1">#find starting point</span>
            <span class="n">si</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="c1"># start point index</span>
            <span class="c1"># ax.scatter(x[si],y[si],c=&#39;r&#39;)</span>
            <span class="n">allocated</span><span class="p">[</span><span class="n">si</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">dist</span><span class="p">[</span><span class="n">si</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">this_string</span> <span class="o">=</span> <span class="p">[</span><span class="n">si</span><span class="p">]</span>
            <span class="c1">#get start point neighbours </span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">niegh</span><span class="p">[</span><span class="n">si</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
            <span class="n">dxdy</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">n</span><span class="p">,:]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="n">si</span><span class="p">,:]</span> <span class="c1">#deltas </span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">distm</span><span class="p">[</span><span class="n">si</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
            <span class="n">di</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="c1"># index of min distance</span>
            <span class="n">ni</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="n">di</span><span class="p">]</span> <span class="c1"># index of nearest neighbour</span>
            <span class="n">this_string</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ni</span><span class="p">)</span> <span class="c1"># save</span>
            <span class="n">allocated</span><span class="p">[</span><span class="n">ni</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">dist</span><span class="p">[</span><span class="n">ni</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="c1">#work out staring direction </span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">bearing</span><span class="p">(</span><span class="n">dxdy</span><span class="p">[</span><span class="n">di</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">dxdy</span><span class="p">[</span><span class="n">di</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
            <span class="c1"># ax.plot([x[si],x[ni]],[y[si],y[ni]],c=color)</span>
            <span class="n">canidate</span> <span class="o">=</span> <span class="kc">True</span>
            
            <span class="k">while</span> <span class="n">canidate</span><span class="p">:</span>
                <span class="n">pi</span> <span class="o">=</span> <span class="n">ni</span> <span class="c1"># prevoius neighbour </span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">niegh</span><span class="p">[</span><span class="n">ni</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
                <span class="n">dxdy</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">n</span><span class="p">,:]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="n">ni</span><span class="p">,:]</span> 
                <span class="n">d</span> <span class="o">=</span> <span class="n">distm</span><span class="p">[</span><span class="n">ni</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
                <span class="n">itr</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                <span class="n">thetav</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">itr</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)):</span>
                    <span class="n">thetav</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bearing</span><span class="p">(</span><span class="n">dxdy</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">dxdy</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">thtest</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">thetav</span> <span class="o">-</span> <span class="n">theta</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tolerance</span> <span class="c1"># test if another point on desired bearing</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">thtest</span><span class="o">==</span><span class="kc">False</span><span class="p">):</span>
                    <span class="n">canidate</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># no more canidates </span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">di</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">thtest</span><span class="p">])</span> <span class="c1"># index of min distance</span>
                    <span class="n">ni</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="n">thtest</span><span class="p">][</span><span class="n">di</span><span class="p">]</span> <span class="c1"># index of next nearest neighbour</span>
                    <span class="n">theta</span> <span class="o">=</span> <span class="n">bearing</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">ni</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="n">pi</span><span class="p">],</span><span class="n">y</span><span class="p">[</span><span class="n">ni</span><span class="p">]</span><span class="o">-</span><span class="n">y</span><span class="p">[</span><span class="n">pi</span><span class="p">])</span>
                    <span class="c1"># ax.plot([x[pi],x[ni]],[y[pi],y[ni]],c=color)</span>
                    <span class="n">allocated</span><span class="p">[</span><span class="n">ni</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">this_string</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ni</span><span class="p">)</span>
                    <span class="n">dist</span><span class="p">[</span><span class="n">ni</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="c1">#overwrite electrode string in data frame? #TODO</span>
                    <span class="c1"># label = self.elec.loc[ni,&#39;label&#39;].split() </span>
                <span class="n">c</span><span class="o">+=</span><span class="mi">1</span>
                <span class="k">if</span> <span class="n">c</span><span class="o">&gt;</span><span class="n">max_itr</span><span class="p">:</span>
                    <span class="n">canidate</span><span class="o">=</span><span class="kc">False</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">&gt;</span><span class="n">max_itr</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;max number of iterations exceeded&#39;</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="n">string</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this_string</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="n">string</span>
    
    <span class="k">def</span> <span class="nf">elec2horidist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert 2D xz data into a true horizontal distance. Assumes that survey </span>
<span class="sd">        was done with a tape measure and the X distances are not true horizontal</span>
<span class="sd">        distance but distances measured along the ground. </span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">:</span>
            <span class="n">s</span><span class="o">.</span><span class="n">elec2horidist</span><span class="p">()</span> 
            
        <span class="c1"># reset first survey electrodes to project electrodes </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setElec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">elec</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">setwd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dirname</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the working directory.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dirname : str</span>
<span class="sd">            Path of the working directory.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">wd</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirname</span><span class="p">,</span> <span class="s1">&#39;invdir&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">dirname</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">dirname</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">wd</span><span class="p">):</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">wd</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;clearing dirname&#39;</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">wd</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dirname</span> <span class="o">=</span> <span class="n">wd</span>


    <span class="k">def</span> <span class="nf">setTitle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linetitle</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the title of the survey name when inverting data. Input is a string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">linetitle</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;lineTitle&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">linetitle</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cannot set Survey title as input is not a string&quot;</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">saveProject</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Save the current project will all dataset in custom </span>
<span class="sd">        ResIPy format (.resipy) for future importation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">zipfile</span> <span class="kn">import</span> <span class="n">ZipFile</span><span class="p">,</span> <span class="n">ZipInfo</span>
        <span class="kn">import</span> <span class="nn">json</span>
        
        <span class="k">if</span> <span class="n">fname</span><span class="p">[</span><span class="o">-</span><span class="mi">7</span><span class="p">:]</span> <span class="o">!=</span> <span class="s1">&#39;.resipy&#39;</span><span class="p">:</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="n">fname</span> <span class="o">+</span> <span class="s1">&#39;.resipy&#39;</span>
        
        <span class="c1"># create save directory</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="n">savedir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">savedir</span><span class="p">):</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">savedir</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">savedir</span><span class="p">)</span>
        
        <span class="c1"># add files to it</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudo3DSurvey</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vtk</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">savedir</span><span class="p">,</span> <span class="s1">&#39;mesh.vtk&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">savedir</span><span class="p">,</span> <span class="s1">&#39;elec.csv&#39;</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">line_terminator</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iForward</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">dfseq</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sequence</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;m&#39;</span><span class="p">,</span><span class="s1">&#39;n&#39;</span><span class="p">])</span>
            <span class="n">dfseq</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">savedir</span><span class="p">,</span> <span class="s1">&#39;dfseq.csv&#39;</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">line_terminator</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">survey</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">):</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">savedir</span><span class="p">,</span> <span class="n">survey</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">survey</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">f</span> <span class="o">+</span> <span class="s1">&#39;-df.csv&#39;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">line_terminator</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">survey</span><span class="o">.</span><span class="n">elec</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">f</span> <span class="o">+</span> <span class="s1">&#39;-elec.csv&#39;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">line_terminator</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">+</span><span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meshResults</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">meshResults</span><span class="p">[</span><span class="n">c</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">vtk</span><span class="p">(</span><span class="n">f</span> <span class="o">+</span> <span class="s1">&#39;.vtk&#39;</span><span class="p">)</span>
        
        <span class="c1"># batch/time-lapse</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iBatch</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">iTimeLapse</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">savedir</span><span class="p">,</span> <span class="s1">&#39;bigSurvey&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bigSurvey</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">f</span> <span class="o">+</span> <span class="s1">&#39;-bigdf.csv&#39;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">line_terminator</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            
        <span class="c1"># pseudo 3D</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudo3DSurvey</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">savedir</span><span class="p">,</span> <span class="s1">&#39;pseudo3DSurvey&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pseudo3DSurvey</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">f</span> <span class="o">+</span> <span class="s1">&#39;-pseudo3Ddf.csv&#39;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">line_terminator</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pseudo3DSurvey</span><span class="o">.</span><span class="n">elec</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">f</span> <span class="o">+</span> <span class="s1">&#39;-pseudo3Delec.csv&#39;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">line_terminator</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">proj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">projs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">proj</span><span class="o">.</span><span class="n">mesh</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="n">proj</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span>
                    <span class="n">proj</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vtk</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">savedir</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">-ps3d.vtk&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">)))</span>
        
        <span class="n">settings</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;surveysInfo&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveysInfo</span><span class="p">,</span>
                    <span class="s1">&#39;topo&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">topo</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(),</span>
                    <span class="s1">&#39;typ&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">,</span>
                    <span class="s1">&#39;err&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">err</span><span class="p">,</span>
                    <span class="s1">&#39;iBorehole&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">iBorehole</span><span class="p">,</span>
                    <span class="s1">&#39;iTimeLapse&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">iTimeLapse</span><span class="p">,</span>
                    <span class="s1">&#39;iBatch&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">iBatch</span><span class="p">,</span>
                    <span class="s1">&#39;sequence&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="s1">&#39;resist0&#39;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resist0</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">resist0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="s1">&#39;iForward&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">iForward</span><span class="p">,</span>
                    <span class="s1">&#39;fmd&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">fmd</span><span class="p">,</span>
                    <span class="s1">&#39;zlim&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">zlim</span><span class="p">,</span>
                    <span class="s1">&#39;geom_input&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom_input</span><span class="p">,</span> <span class="c1"># need to make list of array?</span>
                    <span class="s1">&#39;referenceMdl&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">referenceMdl</span><span class="p">,</span>
                    <span class="s1">&#39;fwdErrModel&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">fwdErrModel</span><span class="p">,</span>
                    <span class="s1">&#39;custSeq&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">custSeq</span><span class="p">,</span>
                    <span class="s1">&#39;errTyp&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">errTyp</span><span class="p">,</span>
                    <span class="s1">&#39;surfaceIdx&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">surfaceIdx</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">surfaceIdx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
                   <span class="p">}</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">savedir</span><span class="p">,</span> <span class="s1">&#39;settings.json&#39;</span><span class="p">),</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">settings</span><span class="p">))</span>
        
        <span class="c1"># param as numpy array</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;num_regions&#39;</span><span class="p">,</span> <span class="s1">&#39;res0File&#39;</span><span class="p">,</span> <span class="s1">&#39;num_xz_poly&#39;</span><span class="p">,</span> <span class="s1">&#39;a_wgt&#39;</span><span class="p">,</span> <span class="s1">&#39;b_wgt&#39;</span><span class="p">,</span>
              <span class="s1">&#39;lineTitle&#39;</span><span class="p">,</span> <span class="s1">&#39;job_type&#39;</span><span class="p">,</span> <span class="s1">&#39;flux_type&#39;</span><span class="p">,</span> <span class="s1">&#39;singular_type&#39;</span><span class="p">,</span>
              <span class="s1">&#39;res_matrix&#39;</span><span class="p">,</span> <span class="s1">&#39;scale&#39;</span><span class="p">,</span> <span class="s1">&#39;regions&#39;</span><span class="p">,</span> <span class="s1">&#39;patch_x&#39;</span><span class="p">,</span> <span class="s1">&#39;patch_z&#39;</span><span class="p">,</span>
              <span class="s1">&#39;inverse_type&#39;</span><span class="p">,</span> <span class="s1">&#39;target_decrease&#39;</span><span class="p">,</span> <span class="s1">&#39;qual_ratio&#39;</span><span class="p">,</span> <span class="s1">&#39;data_type&#39;</span><span class="p">,</span>
              <span class="s1">&#39;reg_mode&#39;</span><span class="p">,</span> <span class="s1">&#39;tolerance&#39;</span><span class="p">,</span> <span class="s1">&#39;max_iter&#39;</span><span class="p">,</span> <span class="s1">&#39;error_mod&#39;</span><span class="p">,</span> <span class="s1">&#39;alpha_aniso&#39;</span><span class="p">,</span>
              <span class="s1">&#39;alpha_s&#39;</span><span class="p">,</span> <span class="s1">&#39;min_error&#39;</span><span class="p">,</span> <span class="s1">&#39;rho_min&#39;</span><span class="p">,</span> <span class="s1">&#39;rho_max&#39;</span><span class="p">,</span> <span class="s1">&#39;mesh_type&#39;</span><span class="p">]</span>
        <span class="n">sparams</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">sparams</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">if</span> <span class="s1">&#39;node_elec&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">:</span>
            <span class="n">sparams</span><span class="p">[</span><span class="s1">&#39;node_elec&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;node_elec&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]),</span>
                                    <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;node_elec&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]]]</span>
            <span class="c1"># int64 not JSON serializable so we convert it to int (int32)</span>
        <span class="k">if</span> <span class="s1">&#39;xz_poly_table&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">:</span>
            <span class="n">sparams</span><span class="p">[</span><span class="s1">&#39;xz_poly_table&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;xz_poly_table&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">if</span> <span class="s1">&#39;xy_poly_table&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">:</span>
            <span class="n">sparams</span><span class="p">[</span><span class="s1">&#39;xy_poly_table&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;xy_poly_table&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">savedir</span><span class="p">,</span> <span class="s1">&#39;params.json&#39;</span><span class="p">),</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">sparams</span><span class="p">))</span>
        
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">savedir</span><span class="p">,</span> <span class="s1">&#39;invLog.log&#39;</span><span class="p">),</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">invLog</span><span class="p">)</span>
        
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">savedir</span><span class="p">,</span> <span class="s1">&#39;fwdLog.log&#39;</span><span class="p">),</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fwdLog</span><span class="p">)</span>
        
        <span class="c1"># zip the directory, move it and clean</span>
        <span class="k">with</span> <span class="n">ZipFile</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fz</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">savedir</span><span class="p">):</span>
                <span class="n">fz</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">savedir</span><span class="p">,</span> <span class="n">file</span><span class="p">),</span> <span class="n">file</span><span class="p">)</span>
        <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">savedir</span><span class="p">)</span>
        
        <span class="c1"># TODO maybe add a self.uiParams = {} for UI specific parameters?</span>
     
        
    <span class="k">def</span> <span class="nf">loadProject</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load data from project file.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fname : str</span>
<span class="sd">            Path where the file will be saved.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">zipfile</span> <span class="kn">import</span> <span class="n">ZipFile</span><span class="p">,</span> <span class="n">ZipInfo</span>
        <span class="kn">import</span> <span class="nn">json</span>
        
        <span class="c1"># create save directory</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.resipy&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="n">savedir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">savedir</span><span class="p">):</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">savedir</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">savedir</span><span class="p">)</span>
        
        <span class="c1"># read in zip and extract in working directory</span>
        <span class="k">with</span> <span class="n">ZipFile</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fz</span><span class="p">:</span>
            <span class="n">fz</span><span class="o">.</span><span class="n">extractall</span><span class="p">(</span><span class="n">savedir</span><span class="p">)</span>
            
        <span class="c1"># read files an reconstruct Survey objects</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meshResults</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">dfnames</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">savedir</span><span class="p">,</span><span class="s1">&#39;*-df.csv&#39;</span><span class="p">))</span>
        <span class="n">elecnames</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">savedir</span><span class="p">,</span><span class="s1">&#39;*-elec.csv&#39;</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">dfname</span><span class="p">,</span> <span class="n">elecname</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dfnames</span><span class="p">,</span> <span class="n">elecnames</span><span class="p">):</span> <span class="c1"># better than 100000 loops!</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">dfname</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;m&#39;</span><span class="p">,</span><span class="s1">&#39;n&#39;</span><span class="p">]:</span>
                <span class="n">df</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
            <span class="n">dfelec</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">elecname</span><span class="p">)</span>
            <span class="n">dfelec</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfelec</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
            <span class="n">surveyName</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">dfname</span><span class="p">[:</span><span class="o">-</span><span class="mi">7</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Survey</span><span class="p">(</span><span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="p">,</span> <span class="n">elec</span><span class="o">=</span><span class="n">dfelec</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">surveyName</span><span class="p">))</span>
            <span class="n">elec</span> <span class="o">=</span> <span class="n">dfelec</span><span class="p">[</span><span class="o">~</span><span class="n">dfelec</span><span class="p">[</span><span class="s1">&#39;remote&#39;</span><span class="p">]][[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="s1">&#39;z&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">savedir</span><span class="p">,</span> <span class="n">surveyName</span> <span class="o">+</span> <span class="s1">&#39;.vtk&#39;</span><span class="p">)):</span>
                <span class="n">mesh</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">vtk_import</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">savedir</span><span class="p">,</span> <span class="n">surveyName</span> <span class="o">+</span> <span class="s1">&#39;.vtk&#39;</span><span class="p">))</span>
                <span class="n">mesh</span><span class="o">.</span><span class="n">setElec</span><span class="p">(</span><span class="n">elec</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">elec</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">elec</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">meshResults</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>

        <span class="c1"># for i in range(100000): # don&#39;t think that someone will store so many</span>
        <span class="c1">#     f = os.path.join(savedir, &#39;survey{:d}&#39;.format(i))</span>
        <span class="c1">#     if os.path.exists(f + &#39;-df.csv&#39;):</span>
        <span class="c1">#         df = pd.read_csv(f + &#39;-df.csv&#39;)</span>
        <span class="c1">#         for c in [&#39;a&#39;,&#39;b&#39;,&#39;m&#39;,&#39;n&#39;]:</span>
        <span class="c1">#             df[c] = df[c].astype(str)</span>
        <span class="c1">#         dfelec = pd.read_csv(f + &#39;-elec.csv&#39;)</span>
        <span class="c1">#         dfelec[&#39;label&#39;] = dfelec[&#39;label&#39;].astype(str)</span>
        <span class="c1">#         self.surveys.append(Survey(df=df, elec=dfelec)) </span>
        <span class="c1">#         elec = dfelec[~dfelec[&#39;remote&#39;]][[&#39;x&#39;,&#39;y&#39;,&#39;z&#39;]].values</span>
        <span class="c1">#         if os.path.exists(f + &#39;.vtk&#39;):</span>
        <span class="c1">#             mesh = mt.vtk_import(f + &#39;.vtk&#39;)</span>
        <span class="c1">#             mesh.setElec(elec[:,0], elec[:,1], elec[:,2])</span>
        <span class="c1">#             self.meshResults.append(mesh)</span>
        
        <span class="c1"># batch/time-lapse</span>
        <span class="n">fbig</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">savedir</span><span class="p">,</span> <span class="s1">&#39;bigSurvey&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">fbig</span> <span class="o">+</span> <span class="s1">&#39;-bigdf.csv&#39;</span><span class="p">):</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">fbig</span> <span class="o">+</span> <span class="s1">&#39;-bigdf.csv&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;m&#39;</span><span class="p">,</span><span class="s1">&#39;n&#39;</span><span class="p">]:</span>
                <span class="n">df</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bigSurvey</span> <span class="o">=</span> <span class="n">Survey</span><span class="p">(</span><span class="n">df</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">elec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">elec</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bigSurvey</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">bigSurvey</span><span class="o">.</span><span class="n">dfOrigin</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bigSurvey</span><span class="o">.</span><span class="n">ndata</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">elec</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">savedir</span><span class="p">,</span> <span class="s1">&#39;elec.csv&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">savedir</span><span class="p">,</span> <span class="s1">&#39;mesh.vtk&#39;</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">importMesh</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">savedir</span><span class="p">,</span> <span class="s1">&#39;mesh.vtk&#39;</span><span class="p">))</span> <span class="c1"># better</span>
<span class="c1">#         self.mesh = mt.vtk_import(os.path.join(savedir, &#39;mesh.vtk&#39;))</span>
        
        <span class="c1"># read flags and settings</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">savedir</span><span class="p">,</span> <span class="s1">&#39;settings.json&#39;</span><span class="p">),</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">settings</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surveysInfo</span> <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;surveysInfo&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">topo</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;topo&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;typ&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">err</span> <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;err&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iBorehole</span> <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;iBorehole&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iTimeLapse</span> <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;iTimeLapse&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iBatch</span> <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;iBatch&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;sequence&#39;</span><span class="p">])</span> <span class="k">if</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;sequence&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resist0</span> <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resist0&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iForward</span> <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;iForward&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iForward</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">savedir</span><span class="p">,</span> <span class="s1">&#39;dfseq.csv&#39;</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">importSequence</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">savedir</span><span class="p">,</span> <span class="s1">&#39;dfseq.csv&#39;</span><span class="p">))</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">copytree</span><span class="p">(</span><span class="n">savedir</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="s1">&#39;fwd&#39;</span><span class="p">))</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="s1">&#39;fwd&#39;</span><span class="p">,</span> <span class="s1">&#39;mesh.vtk&#39;</span><span class="p">),</span><span class="c1"># needed for inverting a fwd_only project after loading</span>
                        <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="s1">&#39;fwd&#39;</span><span class="p">,</span> <span class="s1">&#39;forward_model.vtk&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fmd</span> <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;fmd&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zlim</span> <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;zlim&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iForward</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meshResults</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshResults</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">geom_input</span> <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;geom_input&#39;</span><span class="p">]</span> <span class="c1"># might failed if numpy array inside</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;could not import geom_input&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">referenceMdl</span> <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;referenceMdl&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fwdErrModel</span> <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;fwdErrModel&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">custSeq</span> <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;custSeq&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errTyp</span> <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;errTyp&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfaceIdx</span> <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;surfaceIdx&#39;</span><span class="p">]</span>
            
        <span class="c1"># read parameters</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">savedir</span><span class="p">,</span> <span class="s1">&#39;params.json&#39;</span><span class="p">),</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">sparams</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;xz_poly_table&#39;</span> <span class="ow">in</span> <span class="n">sparams</span><span class="p">:</span>
            <span class="n">sparams</span><span class="p">[</span><span class="s1">&#39;xz_poly_table&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sparams</span><span class="p">[</span><span class="s1">&#39;xz_poly_table&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="s1">&#39;xy_poly_table&#39;</span> <span class="ow">in</span> <span class="n">sparams</span><span class="p">:</span>
            <span class="n">sparams</span><span class="p">[</span><span class="s1">&#39;xy_poly_table&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sparams</span><span class="p">[</span><span class="s1">&#39;xy_poly_table&#39;</span><span class="p">])</span>
        <span class="n">sparams</span><span class="p">[</span><span class="s1">&#39;mesh&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span>
        <span class="k">if</span> <span class="s1">&#39;node_elec&#39;</span> <span class="ow">in</span> <span class="n">sparams</span><span class="p">:</span>
            <span class="n">sparams</span><span class="p">[</span><span class="s1">&#39;node_elec&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sparams</span><span class="p">[</span><span class="s1">&#39;node_elec&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">sparams</span><span class="p">[</span><span class="s1">&#39;node_elec&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sparams</span><span class="p">[</span><span class="s1">&#39;node_elec&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param</span> <span class="o">=</span> <span class="n">sparams</span>
        
        <span class="c1"># pseudo 3D - must be here to take params from self</span>
        <span class="n">fpseudo3D</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">savedir</span><span class="p">,</span> <span class="s1">&#39;pseudo3DSurvey&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">fpseudo3D</span> <span class="o">+</span> <span class="s1">&#39;-pseudo3Ddf.csv&#39;</span><span class="p">):</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">fpseudo3D</span> <span class="o">+</span> <span class="s1">&#39;-pseudo3Ddf.csv&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;m&#39;</span><span class="p">,</span><span class="s1">&#39;n&#39;</span><span class="p">]:</span>
                <span class="n">df</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
            <span class="n">dfelec</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">fpseudo3D</span> <span class="o">+</span> <span class="s1">&#39;-pseudo3Delec.csv&#39;</span><span class="p">)</span>
            <span class="n">dfelec</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfelec</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pseudo3DSurvey</span> <span class="o">=</span> <span class="n">Survey</span><span class="p">(</span><span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="p">,</span> <span class="n">elec</span><span class="o">=</span><span class="n">dfelec</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">:</span>
                <span class="n">directory</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">directory</span><span class="p">)</span> <span class="c1"># making separate inversion diectories</span>
                <span class="n">proj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_createProjects4Pseudo3D</span><span class="p">(</span><span class="n">dirname</span><span class="o">=</span><span class="n">directory</span><span class="p">,</span> <span class="n">invtyp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">)</span> <span class="c1"># non-parallel meshing</span>
                <span class="n">proj</span><span class="o">.</span><span class="n">createSurvey</span><span class="p">(</span><span class="n">fname</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">elec</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">elec</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">projs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">proj</span><span class="p">)</span> <span class="c1"># appending projects list for later use of meshing and inversion</span>
                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">savedir</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">-ps3d.vtk&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">name</span><span class="p">))):</span>
                    <span class="n">proj</span><span class="o">.</span><span class="n">importMesh</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">savedir</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">-ps3d.vtk&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">name</span><span class="p">)))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshResults</span> <span class="o">!=</span> <span class="p">[]:</span>
                <span class="k">for</span> <span class="n">proj</span><span class="p">,</span> <span class="n">mresult</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">projs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshResults</span><span class="p">):</span>
                    <span class="n">proj</span><span class="o">.</span><span class="n">meshResults</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mresult</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_updatePseudo3DSurvey</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">projs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span> <span class="c1"># we don&#39;t want an empty self.mesh if there are meshes in self.projs</span>
        
        <span class="c1"># populating inversion/forward modeling logs </span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">savedir</span><span class="p">,</span> <span class="s1">&#39;invLog.log&#39;</span><span class="p">)):</span> <span class="c1"># compatibility with old saves</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">savedir</span><span class="p">,</span> <span class="s1">&#39;invLog.log&#39;</span><span class="p">),</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">invLog</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">savedir</span><span class="p">,</span> <span class="s1">&#39;fwdLog.log&#39;</span><span class="p">),</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fwdLog</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">createSurvey</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">ftype</span><span class="o">=</span><span class="s1">&#39;Syscal&#39;</span><span class="p">,</span> <span class="n">info</span><span class="o">=</span><span class="p">{},</span> <span class="n">spacing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                     <span class="n">parser</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read electrodes and quadrupoles data and return </span>
<span class="sd">        a survey object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fname : str</span>
<span class="sd">            Filename to be parsed.</span>
<span class="sd">        ftype : str, optional</span>
<span class="sd">            Type of file to be parsed. Either &#39;Syscal&#39;,&#39;ProtocolDC&#39;,&#39;ResInv&#39;,</span>
<span class="sd">            &#39;BGS Prime&#39;, &#39;ProtocolIP&#39;, &#39;Sting&#39;, &#39;ABEM-Lund&#39;, &#39;Lippmann&#39; or &#39;ARES&#39;.</span>
<span class="sd">        info : dict, optional</span>
<span class="sd">            Dictionnary of info about the survey.</span>
<span class="sd">        spacing : float, optional</span>
<span class="sd">            Electrode spacing to be passed to the parser function.</span>
<span class="sd">        parser : function, optional</span>
<span class="sd">            A parser function to be passed to `Survey` constructor.</span>
<span class="sd">        debug : bool, optional</span>
<span class="sd">            If True, information about the reciprocal measurements, default </span>
<span class="sd">            filtering, etc. will be displayed.</span>
<span class="sd">        **kwargs: Keyword arguments to be passed to Survey()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Survey</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">ftype</span><span class="p">,</span> <span class="n">spacing</span><span class="o">=</span><span class="n">spacing</span><span class="p">,</span> <span class="n">parser</span><span class="o">=</span><span class="n">parser</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surveysInfo</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setBorehole</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iBorehole</span><span class="p">)</span>

        <span class="c1"># if all survey have magErr and phiErr then put self.err = True</span>
        <span class="n">ok</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;magErr&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">ok</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">ok</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;magErr/phiErr columns detected, will be used in protocol.dat&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">err</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># define electrode position according to first survey</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">elec</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setElec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">elec</span><span class="p">)</span>
        
        <span class="c1">#do a check for reading in 3D protocol files for 2D projects </span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;2&#39;</span> <span class="ow">and</span> <span class="s1">&#39;Protocol&#39;</span> <span class="ow">in</span> <span class="n">ftype</span><span class="p">:</span> 
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">())</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> 
                    <span class="n">s</span><span class="o">.</span><span class="n">_rmLineNum</span><span class="p">()</span> 
        
            
    <span class="k">def</span> <span class="nf">addData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adds data to the survey - used usually to add reciprocal datasets</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **kwargs: Keyword arguments to be passed to Survey.addData()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">addData</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">createBatchSurvey</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dirname</span><span class="p">,</span> <span class="n">ftype</span><span class="o">=</span><span class="s1">&#39;Syscal&#39;</span><span class="p">,</span> <span class="n">info</span><span class="o">=</span><span class="p">{},</span> <span class="n">spacing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">parser</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">isurveys</span><span class="o">=</span><span class="p">[],</span> <span class="n">dump</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read multiples files from a folders (sorted by alphabetical order).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dirname : str</span>
<span class="sd">            Directory with files to be parsed.</span>
<span class="sd">        ftype : str, optional</span>
<span class="sd">            Type of file to be parsed. Either &#39;Syscal&#39; or &#39;Protocol&#39;.</span>
<span class="sd">        info : dict, optional</span>
<span class="sd">            Dictionnary of info about the survey.</span>
<span class="sd">        spacing : float, optional</span>
<span class="sd">            Electrode spacing to be passed to the parser function.</span>
<span class="sd">        parser : function, optional</span>
<span class="sd">            A parser function to be passed to `Survey` constructor.</span>
<span class="sd">        isurveys : list, optional</span>
<span class="sd">            List of surveys index that will be used for error modelling and so</span>
<span class="sd">            reciprocal measurements. By default all surveys are used.</span>
<span class="sd">        dump : function, optional</span>
<span class="sd">            Function to dump the information message when importing the files.</span>
<span class="sd">        debug : bool, optional</span>
<span class="sd">            If True informations about reciprocal computation, default filtering</span>
<span class="sd">            and so on will be displayed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">createTimeLapseSurvey</span><span class="p">(</span><span class="n">dirname</span><span class="o">=</span><span class="n">dirname</span><span class="p">,</span> <span class="n">ftype</span><span class="o">=</span><span class="n">ftype</span><span class="p">,</span> <span class="n">info</span><span class="o">=</span><span class="n">info</span><span class="p">,</span>
                                   <span class="n">spacing</span><span class="o">=</span><span class="n">spacing</span><span class="p">,</span> <span class="n">isurveys</span><span class="o">=</span><span class="n">isurveys</span><span class="p">,</span>
                                   <span class="n">parser</span><span class="o">=</span><span class="n">parser</span><span class="p">,</span> <span class="n">dump</span><span class="o">=</span><span class="n">dump</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iTimeLapse</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iBatch</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setBorehole</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iBorehole</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">createTimeLapseSurvey</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dirname</span><span class="p">,</span> <span class="n">ftype</span><span class="o">=</span><span class="s1">&#39;Syscal&#39;</span><span class="p">,</span> <span class="n">info</span><span class="o">=</span><span class="p">{},</span>
                              <span class="n">spacing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parser</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">isurveys</span><span class="o">=</span><span class="p">[],</span>
                              <span class="n">dump</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read electrodes and quadrupoles data and return</span>
<span class="sd">        a survey object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dirname : str or list of str</span>
<span class="sd">            Directory with files to be parsed or list of file to be parsed.</span>
<span class="sd">        ftype : str, optional</span>
<span class="sd">            Type of file to be parsed. Either &#39;Syscal&#39; or &#39;Protocol&#39;.</span>
<span class="sd">        info : dict, optional</span>
<span class="sd">            Dictionnary of info about the survey. Put inverse_type = 1 to allow</span>
<span class="sd">            for a changing number of measurements between surveys.</span>
<span class="sd">        spacing : float, optional</span>
<span class="sd">            Electrode spacing to be passed to the parser function.</span>
<span class="sd">        parser : function, optional</span>
<span class="sd">            A parser function to be passed to `Survey` constructor.</span>
<span class="sd">        isurveys : list, optional</span>
<span class="sd">            List of surveys index that will be used for error modelling and so</span>
<span class="sd">            reciprocal measurements. By default all surveys are used.</span>
<span class="sd">        dump : function, optional</span>
<span class="sd">            Function to dump information message when importing the files.</span>
<span class="sd">        debug : bool, optional</span>
<span class="sd">            If True informations about reciprocal computation, default filtering</span>
<span class="sd">            and so on will be displayed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dump</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iTimeLapse</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iTimeLapseReciprocal</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># true if survey has reciprocal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># flush other survey</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dirname</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span> <span class="c1"># it&#39;s a list of filename</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dirname</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;at least two files needed for timelapse inversion&#39;</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="n">files</span> <span class="o">=</span> <span class="n">dirname</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># it&#39;s a directory and we import all the files inside</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">dirname</span><span class="p">):</span>
                <span class="n">files</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirname</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">dirname</span><span class="p">))</span> <span class="k">if</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;.&#39;</span><span class="p">]</span>
                <span class="c1"># this filter out hidden file as well</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;dirname should be a directory path or a list of filenames&#39;</span><span class="p">)</span>


        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">files</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">createSurvey</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">ftype</span><span class="o">=</span><span class="n">ftype</span><span class="p">,</span> <span class="n">parser</span><span class="o">=</span><span class="n">parser</span><span class="p">,</span> <span class="n">spacing</span><span class="o">=</span><span class="n">spacing</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">)</span>
            <span class="n">haveReciprocal</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;irecip&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">iTimeLapseReciprocal</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">haveReciprocal</span><span class="p">)</span>
            <span class="n">dump</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\r</span><span class="si">{:d}</span><span class="s1">/</span><span class="si">{:d}</span><span class="s1"> imported&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">files</span><span class="p">)))</span>
            <span class="c1"># all surveys are imported whatever their length, they will be matched</span>
            <span class="c1"># later if reg_mode == 2 (difference inversion)</span>
        <span class="n">dump</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iTimeLapseReciprocal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iTimeLapseReciprocal</span><span class="p">)</span>
        <span class="c1"># elec and borehole flags assign when first call to R2.createSurvey()</span>
        
        <span class="c1"># create bigSurvey (useful if we want to fit a single error model</span>
        <span class="c1"># based on the combined data of all the surveys)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bigSurvey</span> <span class="o">=</span> <span class="n">Survey</span><span class="p">(</span><span class="n">files</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ftype</span><span class="o">=</span><span class="n">ftype</span><span class="p">,</span> <span class="n">spacing</span><span class="o">=</span><span class="n">spacing</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">parser</span><span class="o">=</span><span class="n">parser</span><span class="p">)</span>
        <span class="c1"># then override the df</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">isurveys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># assume all surveys would be use for error modelling</span>
            <span class="n">isurveys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">isurveys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">isurveys</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># convert to indices</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bigSurvey</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">isurveys</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">df2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">df</span>
            <span class="n">ipos</span> <span class="o">=</span> <span class="n">df2</span><span class="p">[</span><span class="s1">&#39;irecip&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="n">ineg</span> <span class="o">=</span> <span class="n">df2</span><span class="p">[</span><span class="s1">&#39;irecip&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">&lt;</span> <span class="mi">0</span>
            <span class="n">df2</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ipos</span><span class="p">,</span> <span class="s1">&#39;irecip&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df2</span><span class="p">[</span><span class="n">ipos</span><span class="p">][</span><span class="s1">&#39;irecip&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span>
            <span class="n">df2</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ineg</span><span class="p">,</span> <span class="s1">&#39;irecip&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df2</span><span class="p">[</span><span class="n">ineg</span><span class="p">][</span><span class="s1">&#39;irecip&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">c</span>
            <span class="c1">#df = df.append(df2, sort=True) # sort to silence the future warning if concatenation axis is not aligned</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">df</span><span class="p">,</span> <span class="n">df2</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">df2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bigSurvey</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># override it</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bigSurvey</span><span class="o">.</span><span class="n">dfOrigin</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bigSurvey</span><span class="o">.</span><span class="n">ndata</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


    <span class="k">def</span> <span class="nf">create3DSurvey</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">lineSpacing</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">zigzag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ftype</span><span class="o">=</span><span class="s1">&#39;Syscal&#39;</span><span class="p">,</span>
                       <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parser</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a 3D survey based on 2D regularly spaced surveys.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fname : list of str</span>
<span class="sd">            List of 2D filenames in the right order for the grid or directory</span>
<span class="sd">            name (the files will be sorted alphabetically in this last case).</span>
<span class="sd">        lineSpacing : float, optional</span>
<span class="sd">            Spacing in meter between each line.</span>
<span class="sd">        zigzag : bool, optional</span>
<span class="sd">            If `True` then one survey out of two will be flipped.</span>
<span class="sd">            #TODO not implemented yet</span>
<span class="sd">        ftype : str, optional</span>
<span class="sd">            Type of the survey to choose which parser to use.</span>
<span class="sd">        name : str, optional</span>
<span class="sd">            Name of the merged 3D survey.</span>
<span class="sd">            </span>
<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        If one electrode has similar position between multiple lines (shared</span>
<span class="sd">        electrode), ResIPy will keep online one position of the electrode</span>
<span class="sd">        and share its label accross the lines.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span> <span class="c1"># it&#39;s a list of filename</span>
            <span class="n">fnames</span> <span class="o">=</span> <span class="n">fname</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># it&#39;s a directory and we import all the files inside</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
                <span class="n">fnames</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">fname</span><span class="p">))</span> <span class="k">if</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;.&#39;</span><span class="p">]</span>
                <span class="c1"># this filter out hidden file as well</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;fname should be a directory path or a list of filenames&#39;</span><span class="p">)</span>

        <span class="n">surveys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">fnames</span><span class="p">:</span>
            <span class="n">surveys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Survey</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">ftype</span><span class="o">=</span><span class="n">ftype</span><span class="p">,</span> <span class="n">parser</span><span class="o">=</span><span class="n">parser</span><span class="p">))</span>
        <span class="n">survey0</span> <span class="o">=</span> <span class="n">surveys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="c1"># check this is a regular grid (actually unregular grid works too</span>
        <span class="c1"># as we create one mesh for all)</span>
        <span class="c1"># nelec = survey0.elec.shape[0]</span>
        <span class="c1"># for s in surveys:</span>
        <span class="c1">#     if s.elec.shape[0] != nelec:</span>
        <span class="c1">#         raise ValueError(&#39;Survey {:s} has {:d} electrodes while the first survey has {:d}.&#39;</span>
        <span class="c1">#                          &#39;All surveys should have the same number of electrodes.&#39;.format(s.name, s.elec.shape[0], nelec))</span>
        
        <span class="c1"># build global electrodes and merged dataframe</span>
        <span class="n">elec</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">dfs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">surveys</span><span class="p">):</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">elec</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">e</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="n">lineSpacing</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{:d}</span><span class="s1"> &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">e</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">+</span> <span class="n">e</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span>
            <span class="n">elec</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;m&#39;</span><span class="p">,</span><span class="s1">&#39;n&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">+</span> <span class="n">df</span><span class="p">[[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;m&#39;</span><span class="p">,</span><span class="s1">&#39;n&#39;</span><span class="p">]]</span>
            <span class="n">dfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
        <span class="n">elec</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">elec</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">dfm</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">dfs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="n">survey0</span><span class="o">.</span><span class="n">elec</span> <span class="o">=</span> <span class="n">elec</span>
        <span class="n">survey0</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">dfm</span>
        <span class="n">survey0</span><span class="o">.</span><span class="n">dfOrigin</span> <span class="o">=</span> <span class="n">dfm</span> <span class="c1"># for raw phase plot</span>
        <span class="n">survey0</span><span class="o">.</span><span class="n">dfReset</span> <span class="o">=</span> <span class="n">dfm</span> <span class="c1"># for reseting filters on res</span>
        <span class="n">survey0</span><span class="o">.</span><span class="n">dfPhaseReset</span> <span class="o">=</span> <span class="n">dfm</span> <span class="c1"># for reseting filters on IP</span>
        <span class="n">survey0</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;3Dfrom2Dlines&#39;</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span> <span class="o">=</span> <span class="p">[</span><span class="n">survey0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elec</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setElec</span><span class="p">(</span><span class="n">elec</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setBorehole</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iBorehole</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">createPseudo3DSurvey</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dirname</span><span class="p">,</span> <span class="n">lineSpacing</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ftype</span><span class="o">=</span><span class="s1">&#39;Syscal&#39;</span><span class="p">,</span> <span class="n">parser</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a pseudo 3D survey based on 2D surveys. Multiple 2D Projects to be turned into a single pseudo 3D survey.</span>
<span class="sd">            THIS WILL NEED CORRECT ELECTRODE LAYOUT - DONE IN self._updatePseudo3DSurvey()</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dirname : list of str</span>
<span class="sd">            List of 2D filenames in the right order for the grid or directory</span>
<span class="sd">            name (the files will be sorted alphabetically in this last case).</span>
<span class="sd">        lineSpacing : float, optional</span>
<span class="sd">            Spacing in meter between each line.</span>
<span class="sd">        ftype : str, optional</span>
<span class="sd">            Type of the survey to choose which parser to use.</span>
<span class="sd">        kwargs : -</span>
<span class="sd">            Keyword arguments to be passed to Project.createBatchSurvey()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">createBatchSurvey</span><span class="p">(</span><span class="n">dirname</span><span class="o">=</span><span class="n">dirname</span><span class="p">,</span> <span class="n">ftype</span><span class="o">=</span><span class="n">ftype</span><span class="p">,</span> <span class="n">parser</span><span class="o">=</span><span class="n">parser</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="c1"># We need surveys in the master Project for data procesing (error modeling, etc.)</span>
    
        <span class="n">elecList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">dfList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">):</span>
            <span class="n">directory</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">directory</span><span class="p">)</span> <span class="c1"># making separate inversion diectories</span>
            <span class="n">proj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_createProjects4Pseudo3D</span><span class="p">(</span><span class="n">dirname</span><span class="o">=</span><span class="n">directory</span><span class="p">,</span> <span class="n">invtyp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">)</span> <span class="c1"># non-parallel meshing</span>
            <span class="c1"># proj.createSurvey(fname=None, name=s.name, df=s.df, elec=s.elec, **kwargs)</span>
            <span class="n">proj</span><span class="o">.</span><span class="n">surveys</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="c1"># might be faster than importing survey again</span>
            <span class="c1"># this actually stores a reference to the same survey object, so it&#39;s all good</span>
            <span class="c1"># as filtering operation done in batch surveys will be directly done on the surveys of </span>
            <span class="c1"># each project as it&#39;s the same Survey object (with two references)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">projs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">proj</span><span class="p">)</span> <span class="c1"># appending projects list for later use of meshing and inversion</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">elec</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">e</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="n">lineSpacing</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{:d}</span><span class="s1"> &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">e</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">+</span> <span class="n">e</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span>
            <span class="n">elecList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;m&#39;</span><span class="p">,</span><span class="s1">&#39;n&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">+</span> <span class="n">df</span><span class="p">[[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;m&#39;</span><span class="p">,</span><span class="s1">&#39;n&#39;</span><span class="p">]]</span>
            <span class="n">dfList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
            
        <span class="n">elec</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">elecList</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">dfm</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">dfList</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">pseudo3DSurvey</span> <span class="o">=</span> <span class="n">Survey</span><span class="p">(</span><span class="n">fname</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">dfm</span><span class="p">,</span> <span class="n">elec</span><span class="o">=</span><span class="n">elec</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elec</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setElec</span><span class="p">(</span><span class="n">elec</span><span class="p">)</span> <span class="c1"># create initial electrodes df - to be populated later</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setBorehole</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iBorehole</span><span class="p">)</span>
        
    
    
    <span class="k">def</span> <span class="nf">importPseudo3DElec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Import electrodes positions. The label columns should include line</span>
<span class="sd">        number separated by space (like in 3D):</span>
<span class="sd">            label,x,y,z</span>
<span class="sd">            1 3,0,0,0</span>
<span class="sd">            1 4,1,1,0</span>
<span class="sd">            1 5,1,2,1</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fname : str</span>
<span class="sd">            Path of the CSV file containing the electrodes positions. It should contains 3 columns maximum with the X, Y, Z positions of the electrodes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="nb">float</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">header</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="n">header</span> <span class="o">=</span> <span class="s1">&#39;infer&#39;</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">header</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">elec</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">values</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">elec</span> <span class="o">=</span> <span class="n">df</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setPseudo3DElec</span><span class="p">(</span><span class="n">elec</span><span class="p">)</span>
    
    
    
    <span class="k">def</span> <span class="nf">setPseudo3DElec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elec</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set pseudo 3D electrodes (with an electrode label as:</span>
<span class="sd">            &lt;line number&gt; &lt;electrode number&gt;).</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elecList : list of dataframes, optional</span>
<span class="sd">            List of electrodes dataframes - each df must have 2D like XYZ (rotated to have y=0).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pseudo3DSurvey</span><span class="o">.</span><span class="n">elec</span> <span class="o">=</span> <span class="n">elec</span>
        
        <span class="c1"># take self.surveys information to inform all projects in self.projs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_updatePseudo3DSurvey</span><span class="p">()</span>
        
        
        
    <span class="k">def</span> <span class="nf">_updatePseudo3DSurvey</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elecList</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update a pseudo 3D survey based on 2D surveys. </span>
<span class="sd">            Cleaned data, updated electrodes will be inserted in each survey.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elecList : list of dataframes, optional</span>
<span class="sd">            List of electrodes dataframes - each df must have 2D like XYZ (rotated to have y=0).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">projs</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Survey needs to be created first! use Project.createPseudo3DSurvey()&#39;</span><span class="p">)</span>
            
        <span class="n">elecList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create2DLines</span><span class="p">(</span><span class="n">elecList</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">elecdf</span><span class="p">,</span> <span class="n">proj</span><span class="p">,</span> <span class="n">survey</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">elecList</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">projs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">):</span>
            <span class="n">survey</span><span class="o">.</span><span class="n">elec</span> <span class="o">=</span> <span class="n">elecdf</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">proj</span><span class="o">.</span><span class="n">setElec</span><span class="p">(</span><span class="n">elecdf</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
            <span class="n">proj</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">survey</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">proj</span><span class="o">.</span><span class="n">typ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span>    
            <span class="n">proj</span><span class="o">.</span><span class="n">err</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">err</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudo3Dfmd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># pseudo3D fmd has been forced elsewhere so needs to be added here</span>
                <span class="n">proj</span><span class="o">.</span><span class="n">fmd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudo3Dfmd</span>


    <span class="k">def</span> <span class="nf">split3DGrid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">changeLabel</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Split self.elec to available lines based on &#39;label&#39; </span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elec : dataframe, optional</span>
<span class="sd">            Contains the electrodes information. &quot;label&quot; column must be provided and</span>
<span class="sd">            have &quot;&lt;line number&gt; &lt;electrode number&gt;&quot; format.</span>
<span class="sd">        changeLable : bool, optional</span>
<span class="sd">            If True, the line number will be dropped from labels - Flase for GUI related surveys.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        elecList : list of dataframes</span>
<span class="sd">            List of electrodes dataframes - each df can have a 3D like XYZ.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">elec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudo3DSurvey</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
               <span class="n">elec</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">pseudo3DSurvey</span><span class="o">.</span><span class="n">elec</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
               <span class="n">elec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">elec</span><span class="p">[[</span><span class="s1">&#39;lineNum&#39;</span><span class="p">,</span> <span class="s1">&#39;elecNum&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">elec</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">expand</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">elecGroups</span> <span class="o">=</span> <span class="n">elec</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;lineNum&#39;</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="c1">#, as_index=False)</span>
        <span class="n">elecdfs</span> <span class="o">=</span> <span class="p">[</span><span class="n">elecGroups</span><span class="o">.</span><span class="n">get_group</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">elecGroups</span><span class="o">.</span><span class="n">groups</span><span class="p">]</span>
        <span class="n">elecList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">elecdfRaw</span> <span class="ow">in</span> <span class="n">elecdfs</span><span class="p">:</span>
            <span class="n">elecdf</span> <span class="o">=</span> <span class="n">elecdfRaw</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># void pandas setting with copy warning annoying error</span>
            <span class="k">if</span> <span class="n">changeLabel</span><span class="p">:</span>
                <span class="n">elecdf</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">elecdf</span><span class="p">[</span><span class="s1">&#39;elecNum&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="c1"># it&#39;s 2D so let&#39;s get rid of line numbers in labels</span>
            <span class="n">elecdf</span> <span class="o">=</span> <span class="n">elecdf</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="s1">&#39;lineNum&#39;</span><span class="p">,</span> <span class="s1">&#39;elecNum&#39;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">elecdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_findRemote</span><span class="p">(</span><span class="n">elecdf</span><span class="p">)</span>
            <span class="n">elecList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elecdf</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">elecList</span>
    
    
    <span class="k">def</span> <span class="nf">_create2DLines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elecList</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a list of 2D electrode XYZ/topo where only x &amp; z are variable and y=0.</span>
<span class="sd">            Simply, rotating an array of XY locations on x, y = 0 pivot to have all y values equal to zero</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elecList : list of dataframes, optional</span>
<span class="sd">            List of electrodes dataframes - each df can have a 3D like XYZ.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        elecList : list of dataframes</span>
<span class="sd">            List of electrodes dataframes - each df will have 2D like XYZ (rotated to have y=0).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="n">elecList</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">elecList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">split3DGrid</span><span class="p">()</span>
            
        <span class="k">for</span> <span class="n">elecdf</span> <span class="ow">in</span> <span class="n">elecList</span><span class="p">:</span>
            <span class="c1"># transforming line to start from x, y = 0</span>
            <span class="n">ie</span> <span class="o">=</span> <span class="n">elecdf</span><span class="p">[</span><span class="o">~</span><span class="n">elecdf</span><span class="p">[</span><span class="s1">&#39;remote&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span>
            <span class="n">elecdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ie</span><span class="p">,</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">elecdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ie</span><span class="p">,</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">-</span> <span class="n">elecdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">elecdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ie</span><span class="p">,</span><span class="s1">&#39;x&#39;</span><span class="p">]),</span><span class="s1">&#39;x&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">elecdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ie</span><span class="p">,</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">elecdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="s1">&#39;x&#39;</span><span class="p">]):</span> <span class="c1"># line is vertical</span>
                <span class="n">elecdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ie</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">elecdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ie</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">-</span> <span class="n">elecdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">elecdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ie</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">]),</span><span class="s1">&#39;y&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">elecdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ie</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">elecdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ie</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">-</span> <span class="n">elecdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">elecdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ie</span><span class="p">,</span><span class="s1">&#39;x&#39;</span><span class="p">]),</span><span class="s1">&#39;y&#39;</span><span class="p">]</span>
            <span class="n">delx</span> <span class="o">=</span> <span class="n">elecdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ie</span><span class="p">,</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">elecdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ie</span><span class="p">,</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="n">dely</span> <span class="o">=</span> <span class="n">elecdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ie</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">elecdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ie</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="k">if</span> <span class="n">delx</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="n">dely</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">delx</span><span class="p">))</span>
            <span class="n">rotangle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">elecdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">elecdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ie</span><span class="p">,</span><span class="s1">&#39;x&#39;</span><span class="p">]),</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">elecdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">elecdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ie</span><span class="p">,</span><span class="s1">&#39;x&#39;</span><span class="p">]),</span><span class="s1">&#39;y&#39;</span><span class="p">]:</span> <span class="c1"># CCW rotation needed</span>
                <span class="n">rotangle</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="c1"># rotation     </span>
            <span class="n">rotmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">rotangle</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">rotangle</span><span class="p">)],</span> 
                                <span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">rotangle</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">rotangle</span><span class="p">)]])</span>
            <span class="n">xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">elecdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ie</span><span class="p">,</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">elecdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ie</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">])</span>
            <span class="n">newmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rotmat</span><span class="p">,</span> <span class="n">xy</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="n">elecdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ie</span><span class="p">,</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">newmat</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">elecdf</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># to make sure we don&#39;t end up with super small values</span>
                        
        <span class="k">return</span> <span class="n">elecList</span>
    
    
    <span class="k">def</span> <span class="nf">createMultiMesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">runParallel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create multiple meshes from avalable Projects in self.projs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        runParallel : bool, optional</span>
<span class="sd">            if True, mesh generation will run in multiple threads.</span>
<span class="sd">        kwargs : -</span>
<span class="sd">            Keyword arguments to be passed to mesh generation schemes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO the below doesn&#39;t work well, we need to use</span>
        <span class="c1"># 1) tempfile for creating temporary directory and then the </span>
        <span class="c1"># write all files to those and then use a similar approach to </span>
        <span class="c1"># Project.runParallel() with a while loop and limiting given ncores</span>
        <span class="c1"># however, it&#39;s fast enough like this as it&#39;s a sequence of 2D meshes</span>
        <span class="k">for</span> <span class="n">proj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">projs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">runParallel</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">proj</span><span class="o">.</span><span class="n">createMesh</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
                <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">proj</span><span class="o">.</span><span class="n">createMesh</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">projs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span> <span class="c1"># just to have a populated mesh in master Project!</span>
        <span class="k">if</span> <span class="s1">&#39;fmd&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pseudo3Dfmd</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;fmd&#39;</span><span class="p">]</span>
   
    
    
    <span class="k">def</span> <span class="nf">showPseudo3DMesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">color_map</span><span class="o">=</span><span class="s1">&#39;Greys&#39;</span><span class="p">,</span> <span class="n">meshList</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">cropMesh</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">color_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">returnMesh</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                         <span class="n">cropMaxDepth</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">clipCorners</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">pvshow</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Show 2D meshes in 3D view</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ax : matplotlib axis, optional</span>
<span class="sd">            If specified, graph will be plotted on the given axis.</span>
<span class="sd">        color_map : str, optional</span>
<span class="sd">            Name of the colormap to be used.</span>
<span class="sd">        meshList : list of Mesh classes</span>
<span class="sd">            If not None, pseudo 3D meshes will be plotted by default.</span>
<span class="sd">        cropMesh : bool, optional</span>
<span class="sd">            If True, 2D mesh will be bound to electrodes and zlim.</span>
<span class="sd">        color_bar : Boolean, optional </span>
<span class="sd">            `True` to plot colorbar.</span>
<span class="sd">        returnMesh: bool, optional</span>
<span class="sd">            if True method returns a merged mesh. </span>
<span class="sd">        cropMaxDepth : bool, optional</span>
<span class="sd">            If True, region below fine mesh depth (fmd) will be cropped.</span>
<span class="sd">        clipCorners : bool, optional</span>
<span class="sd">            If &#39;True&#39;, triangles from bottom corners will be cropped (only if the whole mesh is not shown).</span>
<span class="sd">        pvshow : bool, optional</span>
<span class="sd">            Set to False to not call `Plotter.show()` (useful for subplots).</span>
<span class="sd">        kwargs : -</span>
<span class="sd">            Keyword arguments to be passed to Mesh.show() class.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">findminmax</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">mina</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">maxa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">+</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">mina</span> <span class="o">==</span> <span class="n">maxa</span><span class="p">:</span>
                <span class="n">mina</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="n">maxa</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">mina</span><span class="p">,</span> <span class="n">maxa</span><span class="p">]</span>
        
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">pyvista</span> <span class="k">as</span> <span class="nn">pv</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ERROR: pyvista is needed to show pseudo 3D meshes. Use pip install pyvista&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        
        <span class="k">if</span> <span class="n">meshList</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">meshList</span> <span class="o">=</span> <span class="p">[</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">projs</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">Plotter</span><span class="p">()</span>
            
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;pvshow&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># don&#39;t invoke show after each mesh added</span>
        
        <span class="n">elecList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">split3DGrid</span><span class="p">()</span>  <span class="c1"># split the electrodes to lines in 3D space   </span>
                
        <span class="k">if</span> <span class="n">returnMesh</span><span class="p">:</span>
            <span class="n">meshOutList</span> <span class="o">=</span> <span class="p">[]</span>
            
        <span class="k">for</span> <span class="n">proj</span><span class="p">,</span> <span class="n">elecdf</span><span class="p">,</span> <span class="n">mesh</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">projs</span><span class="p">,</span> <span class="n">elecList</span><span class="p">,</span> <span class="n">meshList</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Mesh undefined for this project!&#39;</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">cropMesh</span><span class="p">:</span>
                <span class="n">node_x</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">node</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">node_z</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">node</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">xmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">node_x</span><span class="p">)</span>
                <span class="n">xmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">node_x</span><span class="p">)</span>
                <span class="n">zmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">node_z</span><span class="p">)</span>
                <span class="n">zmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">node_z</span><span class="p">)</span>
                <span class="p">(</span><span class="n">xsurf</span><span class="p">,</span> <span class="n">zsurf</span><span class="p">)</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">extractSurface</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">cropMaxDepth</span> <span class="ow">and</span> <span class="n">proj</span><span class="o">.</span><span class="n">fmd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">xfmd</span><span class="p">,</span> <span class="n">zfmd</span> <span class="o">=</span> <span class="n">xsurf</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">zsurf</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">proj</span><span class="o">.</span><span class="n">fmd</span>
                    <span class="n">verts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xsurf</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">xfmd</span><span class="p">,</span> <span class="n">xmin</span><span class="p">],</span>
                                  <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">zmin</span><span class="p">,</span> <span class="n">zmax</span><span class="p">,</span> <span class="n">zsurf</span><span class="p">,</span> <span class="n">zmax</span><span class="p">,</span> <span class="n">zmin</span><span class="p">,</span> <span class="n">zfmd</span><span class="p">,</span> <span class="n">zmin</span><span class="p">]]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">verts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xsurf</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">xmin</span><span class="p">],</span>
                                  <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">zmin</span><span class="p">,</span> <span class="n">zmax</span><span class="p">,</span> <span class="n">zsurf</span><span class="p">,</span> <span class="n">zmax</span><span class="p">,</span> <span class="n">zmin</span><span class="p">,</span> <span class="n">zmin</span><span class="p">]]</span>
                <span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="n">verts</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">clipCorners</span> <span class="ow">and</span> <span class="n">proj</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;num_xz_poly&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># not clipping the corners of a mesh outside of the survey area!</span>
                <span class="n">elec_x</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">elec</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">elec_z</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">elec</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">elec_xmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">elec_x</span><span class="p">)</span>
                <span class="n">elec_xmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">elec_x</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">cropMaxDepth</span> <span class="ow">and</span> <span class="n">proj</span><span class="o">.</span><span class="n">fmd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">zminl</span> <span class="o">=</span> <span class="n">elec_z</span><span class="p">[</span><span class="n">elec_x</span><span class="o">.</span><span class="n">argmin</span><span class="p">()]</span> <span class="o">-</span> <span class="n">proj</span><span class="o">.</span><span class="n">fmd</span>
                    <span class="n">zminr</span> <span class="o">=</span> <span class="n">elec_z</span><span class="p">[</span><span class="n">elec_x</span><span class="o">.</span><span class="n">argmax</span><span class="p">()]</span> <span class="o">-</span> <span class="n">proj</span><span class="o">.</span><span class="n">fmd</span>
                <span class="k">elif</span> <span class="n">cropMaxDepth</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">proj</span><span class="o">.</span><span class="n">fmd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">zminl</span> <span class="o">=</span> <span class="n">zminr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">elec_z</span><span class="p">)</span> <span class="o">-</span> <span class="n">proj</span><span class="o">.</span><span class="n">fmd</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">zminl</span> <span class="o">=</span> <span class="n">zminr</span> <span class="o">=</span> <span class="n">zmin</span>
                <span class="n">zmaxl</span> <span class="o">=</span> <span class="n">elec_z</span><span class="p">[</span><span class="n">elec_x</span><span class="o">.</span><span class="n">argmin</span><span class="p">()]</span>
                <span class="n">zmaxr</span> <span class="o">=</span> <span class="n">elec_z</span><span class="p">[</span><span class="n">elec_x</span><span class="o">.</span><span class="n">argmax</span><span class="p">()]</span>
                <span class="n">ll</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">zmaxl</span> <span class="o">-</span> <span class="n">zminl</span><span class="p">)</span>
                <span class="n">lr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">zmaxr</span> <span class="o">-</span> <span class="n">zminr</span><span class="p">)</span>
                <span class="n">lx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">elec_xmin</span> <span class="o">-</span> <span class="n">elec_xmax</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ll</span> <span class="o">&gt;=</span> <span class="n">lx</span><span class="o">/</span><span class="mi">4</span><span class="p">:</span>
                    <span class="n">ll</span> <span class="o">=</span> <span class="n">lx</span><span class="o">/</span><span class="mi">4</span>
                <span class="k">if</span> <span class="n">lr</span> <span class="o">&gt;=</span> <span class="n">lx</span><span class="o">/</span><span class="mi">4</span><span class="p">:</span>
                    <span class="n">lr</span> <span class="o">=</span> <span class="n">lx</span><span class="o">/</span><span class="mi">4</span>
    
                <span class="c1"># surf bound to elecs</span>
                <span class="n">elec_surf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">xsurf</span><span class="p">,</span> <span class="n">zsurf</span><span class="p">][(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">xsurf</span> <span class="o">-</span> <span class="n">elec_xmin</span><span class="p">))</span><span class="o">.</span><span class="n">argmin</span><span class="p">():</span>
                                                <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">xsurf</span> <span class="o">-</span> <span class="n">elec_xmax</span><span class="p">))</span><span class="o">.</span><span class="n">argmin</span><span class="p">(),:]</span>
                <span class="n">idxl</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">elec_surf</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">ll</span><span class="p">))</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
                <span class="n">idxr</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">elec_surf</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">elec_xmax</span> <span class="o">-</span> <span class="n">lr</span><span class="p">)))</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>       
                <span class="n">xtrapbot</span> <span class="o">=</span> <span class="n">elec_surf</span><span class="p">[</span><span class="n">idxl</span><span class="p">:</span><span class="n">idxr</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">cropMaxDepth</span> <span class="ow">and</span> <span class="n">proj</span><span class="o">.</span><span class="n">fmd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">ztrapbot</span> <span class="o">=</span> <span class="n">elec_surf</span><span class="p">[</span><span class="n">idxl</span><span class="p">:</span><span class="n">idxr</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">proj</span><span class="o">.</span><span class="n">fmd</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ztrapbot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">xtrapbot</span><span class="p">)</span> <span class="o">*</span> <span class="n">zminl</span>
                    
                <span class="n">proj</span><span class="o">.</span><span class="n">trapeziod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">elec_xmin</span><span class="p">,</span> <span class="n">xsurf</span><span class="p">,</span> <span class="n">elec_xmax</span><span class="p">,</span> <span class="n">xtrapbot</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">elec_xmin</span><span class="p">],</span>
                                  <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">zmaxl</span><span class="p">,</span> <span class="n">zsurf</span><span class="p">,</span> <span class="n">zmaxr</span><span class="p">,</span> <span class="n">ztrapbot</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">zmaxl</span><span class="p">]]</span>
                <span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="n">proj</span><span class="o">.</span><span class="n">trapeziod</span><span class="p">)</span>
            
            <span class="k">else</span><span class="p">:</span>
                <span class="n">proj</span><span class="o">.</span><span class="n">trapeziod</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># make sure trapeziod mask is clear</span>

            <span class="n">meshMoved</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">moveMesh2D</span><span class="p">(</span><span class="n">meshObject</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">elecLocal</span><span class="o">=</span><span class="n">proj</span><span class="o">.</span><span class="n">elec</span><span class="p">,</span> <span class="n">elecGrid</span><span class="o">=</span><span class="n">elecdf</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">cropMesh</span><span class="p">:</span>
                <span class="n">limits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">meshMoved</span><span class="o">.</span><span class="n">elec</span><span class="p">[:,</span><span class="mi">0</span><span class="p">][</span><span class="o">~</span><span class="n">meshMoved</span><span class="o">.</span><span class="n">iremote</span><span class="p">],</span> <span class="n">meshMoved</span><span class="o">.</span><span class="n">elec</span><span class="p">[:,</span><span class="mi">1</span><span class="p">][</span><span class="o">~</span><span class="n">meshMoved</span><span class="o">.</span><span class="n">iremote</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">limits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">meshMoved</span><span class="o">.</span><span class="n">node</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">meshMoved</span><span class="o">.</span><span class="n">node</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]]</span>

            <span class="n">xlim</span> <span class="o">=</span> <span class="n">findminmax</span><span class="p">(</span><span class="n">limits</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">ylim</span> <span class="o">=</span> <span class="n">findminmax</span><span class="p">(</span><span class="n">limits</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">zlim</span> <span class="o">=</span> <span class="n">proj</span><span class="o">.</span><span class="n">zlim</span>
            <span class="n">meshMoved</span><span class="o">.</span><span class="n">ndims</span> <span class="o">=</span> <span class="mi">3</span> <span class="c1"># overwrite dimension to use show3D() method</span>

            <span class="n">meshMoved</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">color_map</span><span class="o">=</span><span class="n">color_map</span><span class="p">,</span> <span class="n">color_bar</span><span class="o">=</span><span class="n">color_bar</span><span class="p">,</span> <span class="n">xlim</span><span class="o">=</span><span class="n">xlim</span><span class="p">,</span>
                      <span class="n">ylim</span><span class="o">=</span><span class="n">ylim</span><span class="p">,</span> <span class="n">zlim</span><span class="o">=</span><span class="n">zlim</span><span class="p">,</span> <span class="n">darkMode</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">darkMode</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">returnMesh</span><span class="p">:</span>
                <span class="n">meshOutList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">meshMoved</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">pvshow</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">show</span><span class="p">()</span> <span class="c1"># call plotter.show()</span>
        
        <span class="k">if</span> <span class="n">returnMesh</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pseudo3DMeshResultList</span> <span class="o">=</span> <span class="n">meshOutList</span>
            <span class="n">meshMerged</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">mergeMeshes</span><span class="p">(</span><span class="n">meshOutList</span><span class="p">)</span>
            <span class="n">meshMerged</span><span class="o">.</span><span class="n">ndims</span> <span class="o">=</span> <span class="mi">3</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pseudo3DMeshResult</span> <span class="o">=</span> <span class="n">meshMerged</span>
    
    
    <span class="k">def</span> <span class="nf">_setPseudo3DParam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">targetProjParams</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set params from master Project to a target Project.</span>
<span class="sd">            IMPORTANT: some params (e.g., mesh, reg0, etc.) are excluded</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        targetProjParams : dict</span>
<span class="sd">            Target Project instance params</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        targetProjParams : dict</span>
<span class="sd">            Target Project instance params are set from self (master Project)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;num_xz_poly&#39;</span><span class="p">,</span> <span class="s1">&#39;num_xy_poly&#39;</span><span class="p">,</span><span class="s1">&#39;a_wgt&#39;</span><span class="p">,</span> <span class="s1">&#39;b_wgt&#39;</span><span class="p">,</span> <span class="s1">&#39;lineTitle&#39;</span><span class="p">,</span> <span class="s1">&#39;job_type&#39;</span><span class="p">,</span>  
                <span class="s1">&#39;flux_type&#39;</span><span class="p">,</span> <span class="s1">&#39;singular_type&#39;</span><span class="p">,</span> <span class="s1">&#39;res_matrix&#39;</span><span class="p">,</span> <span class="s1">&#39;scale&#39;</span><span class="p">,</span> <span class="s1">&#39;patch_x&#39;</span><span class="p">,</span> <span class="s1">&#39;patch_z&#39;</span><span class="p">,</span>
                <span class="s1">&#39;inverse_type&#39;</span><span class="p">,</span> <span class="s1">&#39;target_decrease&#39;</span><span class="p">,</span> <span class="s1">&#39;qual_ratio&#39;</span><span class="p">,</span> <span class="s1">&#39;data_type&#39;</span><span class="p">,</span> <span class="s1">&#39;zmin&#39;</span><span class="p">,</span> <span class="s1">&#39;zmax&#39;</span><span class="p">,</span>
                <span class="s1">&#39;reg_mode&#39;</span><span class="p">,</span> <span class="s1">&#39;tolerance&#39;</span><span class="p">,</span> <span class="s1">&#39;max_iter&#39;</span><span class="p">,</span> <span class="s1">&#39;error_mod&#39;</span><span class="p">,</span> <span class="s1">&#39;alpha_aniso&#39;</span><span class="p">,</span>
                <span class="s1">&#39;alpha_s&#39;</span><span class="p">,</span> <span class="s1">&#39;min_error&#39;</span><span class="p">,</span> <span class="s1">&#39;rho_min&#39;</span><span class="p">,</span> <span class="s1">&#39;rho_max&#39;</span><span class="p">,</span> <span class="s1">&#39;mesh_type&#39;</span><span class="p">]</span>
        
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">targetProjParams</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">if</span> <span class="s1">&#39;node_elec&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">:</span>
            <span class="n">targetProjParams</span><span class="p">[</span><span class="s1">&#39;node_elec&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;node_elec&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;node_elec&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()]</span>
        <span class="k">if</span> <span class="s1">&#39;xz_poly_table&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">:</span>
            <span class="n">targetProjParams</span><span class="p">[</span><span class="s1">&#39;xz_poly_table&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;xz_poly_table&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">if</span> <span class="s1">&#39;xy_poly_table&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">:</span>
            <span class="n">targetProjParams</span><span class="p">[</span><span class="s1">&#39;xy_poly_table&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;xy_poly_table&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        
        <span class="k">return</span> <span class="n">targetProjParams</span>
    
    
    <span class="k">def</span> <span class="nf">invertPseudo3D</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">invLog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">runParallel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Run pseudo3D inversions.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        invLog : function, optional</span>
<span class="sd">            Passes project inversion outputs.</span>
<span class="sd">        runParallel : bool</span>
<span class="sd">            if True, inversions will run in parallel based on number of CPU cores.</span>
<span class="sd">        kwargs : -</span>
<span class="sd">            Keyword arguments to be passed to invert().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># kill management</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">procs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proc</span> <span class="o">=</span> <span class="n">ProcsManagement</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_updatePseudo3DSurvey</span><span class="p">()</span> <span class="c1"># make sure we have set all attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meshResults</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># clean meshResults list</span>
        <span class="k">for</span> <span class="n">proj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">projs</span><span class="p">:</span> <span class="c1"># preparing inversion params</span>
            <span class="n">proj</span><span class="o">.</span><span class="n">param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_setPseudo3DParam</span><span class="p">(</span><span class="n">proj</span><span class="o">.</span><span class="n">param</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">runParallel</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span> <span class="c1"># non-parallel inversion</span>
            <span class="k">for</span> <span class="n">proj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">projs</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">projectPseudo3D</span> <span class="o">=</span> <span class="n">proj</span> <span class="c1"># get functions for UI</span>
                <span class="n">proj</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">procs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">proj</span><span class="o">.</span><span class="n">proc</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">proc</span><span class="o">.</span><span class="n">killFlag</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="k">if</span> <span class="n">invLog</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">invLog</span><span class="p">(</span><span class="n">proj</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="n">proj</span><span class="o">.</span><span class="n">typ</span><span class="p">)</span>
            
        <span class="k">else</span><span class="p">:</span> <span class="c1"># parallel inversion</span>
            <span class="k">if</span> <span class="n">invLog</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">def</span> <span class="nf">invLog</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            
            <span class="c1"># create R2.exe path</span>
            <span class="n">exeName</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">+</span> <span class="s1">&#39;.exe&#39;</span>
            <span class="n">exePath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">apiPath</span><span class="p">,</span> <span class="s1">&#39;exe&#39;</span><span class="p">,</span> <span class="n">exeName</span><span class="p">)</span>
    
            <span class="c1"># create .in and protocol.dat files</span>
            <span class="n">wds</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">proj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">projs</span><span class="p">:</span>
                <span class="n">wds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">proj</span><span class="o">.</span><span class="n">dirname</span><span class="p">)</span>
                <span class="n">invLog</span><span class="p">(</span><span class="s1">&#39;Writing .in file and protocol.dat for </span><span class="si">{}</span><span class="s1"> survey... &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">proj</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
                <span class="n">proj</span><span class="o">.</span><span class="n">write2in</span><span class="p">()</span> <span class="c1"># R2.in</span>
                <span class="n">proj</span><span class="o">.</span><span class="n">write2protocol</span><span class="p">()</span> <span class="c1"># protocol.dat</span>
                <span class="n">invLog</span><span class="p">(</span><span class="s1">&#39;done</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">wds2</span> <span class="o">=</span> <span class="n">wds</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
            <span class="c1"># create workers directory</span>
            <span class="n">ncoresAvailable</span> <span class="o">=</span> <span class="n">ncores</span> <span class="o">=</span> <span class="n">sysinfo</span><span class="p">[</span><span class="s1">&#39;cpuCount&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ncores</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ncores</span> <span class="o">=</span> <span class="n">sysinfo</span><span class="p">[</span><span class="s1">&#39;physicalCpuCount&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ncores</span> <span class="o">&gt;</span> <span class="n">ncoresAvailable</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Number of cores larger than available&#39;</span><span class="p">)</span>
    
            <span class="k">if</span> <span class="n">OS</span> <span class="o">==</span> <span class="s1">&#39;Windows&#39;</span><span class="p">:</span>
                <span class="n">cmd</span> <span class="o">=</span> <span class="p">[</span><span class="n">exePath</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">OS</span> <span class="o">==</span> <span class="s1">&#39;Darwin&#39;</span><span class="p">:</span>
                <span class="n">winetxt</span> <span class="o">=</span> <span class="s1">&#39;wine&#39;</span>
                <span class="k">if</span> <span class="n">getMacOSVersion</span><span class="p">():</span>
                    <span class="n">winetxt</span> <span class="o">=</span> <span class="s1">&#39;wine64&#39;</span>
                <span class="n">winePath</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">wine_path</span> <span class="o">=</span> <span class="n">Popen</span><span class="p">([</span><span class="s1">&#39;which&#39;</span><span class="p">,</span> <span class="n">winetxt</span><span class="p">],</span> <span class="n">stdout</span><span class="o">=</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">shell</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">universal_newlines</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">stdout_line</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="n">wine_path</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">readline</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">):</span>
                    <span class="n">winePath</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stdout_line</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">winePath</span> <span class="o">!=</span> <span class="p">[]:</span>
                    <span class="n">cmd</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">winePath</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)),</span> <span class="n">exePath</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cmd</span> <span class="o">=</span> <span class="p">[</span><span class="n">wPath</span> <span class="o">+</span> <span class="n">winetxt</span><span class="p">,</span> <span class="n">exePath</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cmd</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;wine&#39;</span><span class="p">,</span><span class="n">exePath</span><span class="p">]</span>
    
            <span class="k">if</span> <span class="n">OS</span> <span class="o">==</span> <span class="s1">&#39;Windows&#39;</span><span class="p">:</span>
                <span class="n">startupinfo</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">STARTUPINFO</span><span class="p">()</span>
                <span class="n">startupinfo</span><span class="o">.</span><span class="n">dwFlags</span> <span class="o">|=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">STARTF_USESHOWWINDOW</span>
    
            <span class="c1"># run them all in parallel as child processes</span>
            <span class="n">invLog</span><span class="p">(</span><span class="s1">&#39;----------- PARALLEL INVERSION BEGINS ----------</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">def</span> <span class="nf">dumpOutput</span><span class="p">(</span><span class="n">out</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">readline</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">):</span>
                    <span class="n">invLog</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">out</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    
            <span class="c1"># create essential attribute</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">irunParallel2</span> <span class="o">=</span> <span class="kc">True</span>
    
            <span class="c1"># run in // (http://code.activestate.com/recipes/577376-simple-way-to-execute-multiple-process-in-parallel/)</span>
            <span class="c1"># In an infinite loop, will run an number of process (according to the number of cores)</span>
            <span class="c1"># the loop will check when they finish and start new ones.</span>
            <span class="k">def</span> <span class="nf">done</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="n">poll</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

            <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">invLog</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\r</span><span class="si">{:.0f}</span><span class="s1">/</span><span class="si">{:.0f}</span><span class="s1"> inversions completed&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">wds2</span><span class="p">)))</span>
            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">irunParallel2</span><span class="p">:</span>
                <span class="k">while</span> <span class="n">wds</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">procs</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">ncores</span><span class="p">:</span>
                    <span class="n">wd</span> <span class="o">=</span> <span class="n">wds</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">OS</span> <span class="o">==</span> <span class="s1">&#39;Windows&#39;</span><span class="p">:</span>
                        <span class="n">p</span> <span class="o">=</span> <span class="n">Popen</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">cwd</span><span class="o">=</span><span class="n">wd</span><span class="p">,</span> <span class="n">stdout</span><span class="o">=</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">shell</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">universal_newlines</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">startupinfo</span><span class="o">=</span><span class="n">startupinfo</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">p</span> <span class="o">=</span> <span class="n">Popen</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">cwd</span><span class="o">=</span><span class="n">wd</span><span class="p">,</span> <span class="n">stdout</span><span class="o">=</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">shell</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">universal_newlines</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">procs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">procs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">done</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">procs</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                        <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">+</span><span class="mi">1</span>
                        <span class="c1"># TODO get RMS and iteration number here ?</span>
                        <span class="n">invLog</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\r</span><span class="si">{:.0f}</span><span class="s1">/</span><span class="si">{:.0f}</span><span class="s1"> inversions completed&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">wds2</span><span class="p">)))</span>
    
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">procs</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">wds</span><span class="p">:</span>
                    <span class="n">invLog</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.05</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">invLog</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span> <span class="c1"># clearing the inversion log for saving</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">proc</span><span class="o">.</span><span class="n">killFlag</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span> <span class="c1"># make sure we haven&#39;t killed the processes</span>
            <span class="k">for</span> <span class="n">proj</span><span class="p">,</span> <span class="n">survey</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">projs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">runParallel</span><span class="p">:</span>
                    <span class="n">proj</span><span class="o">.</span><span class="n">getInvError</span><span class="p">()</span>
                    <span class="n">proj</span><span class="o">.</span><span class="n">getResults</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">meshResults</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">proj</span><span class="o">.</span><span class="n">meshResults</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="n">survey</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">proj</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># to populate inversion error outputs</span>
                <span class="n">survey</span><span class="o">.</span><span class="n">dfInvErrOutputOrigin</span> <span class="o">=</span> <span class="n">survey</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">proj</span><span class="o">.</span><span class="n">invLog</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span> <span class="c1"># in case of parallel inversion</span>
                    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">proj</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="n">proj</span><span class="o">.</span><span class="n">typ</span> <span class="o">+</span> <span class="s1">&#39;.out&#39;</span><span class="p">),</span><span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                        <span class="n">proj</span><span class="o">.</span><span class="n">invLog</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">invLog</span> <span class="o">+=</span> <span class="s1">&#39;###&gt;&gt;&gt; Dataset: &#39;</span> <span class="o">+</span> <span class="n">survey</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="n">proj</span><span class="o">.</span><span class="n">invLog</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;----------- END OF INVERSION IN // ----------&#39;</span><span class="p">)</span>

    
    <span class="k">def</span> <span class="nf">showPseudo3DResults</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cropMesh</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Show 2D Inversions in 3D view</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cropMesh : bool, optional</span>
<span class="sd">            If True, 2D mesh will be bound to electrodes and zlim.</span>
<span class="sd">        kwargs : -</span>
<span class="sd">            Keyword arguments to be passed to showPseudo3DMesh().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">meshResults</span> <span class="o">=</span> <span class="p">[</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">meshResults</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">projs</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">showPseudo3DMesh</span><span class="p">(</span><span class="n">color_bar</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cropMesh</span><span class="o">=</span><span class="n">cropMesh</span><span class="p">,</span> <span class="n">meshList</span><span class="o">=</span><span class="n">meshResults</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
    
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_createProjects4Pseudo3D</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">dirname</span><span class="p">,</span> <span class="n">invtyp</span><span class="o">=</span><span class="s1">&#39;R2&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a Project instance for future use of meshing and inversion.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dirname : str</span>
<span class="sd">            directory where 2D line will be dealt with (meshing, inversion, etc.)</span>
<span class="sd">        invtyp : str</span>
<span class="sd">            &#39;R2&#39; - inverting 2D resistivity</span>
<span class="sd">            &#39;cR2&#39; - inverting 2D induced polarization</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ProjInstance : Instance of Project class</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ProjInstance</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">dirname</span><span class="o">=</span><span class="n">dirname</span><span class="p">,</span> <span class="n">typ</span><span class="o">=</span><span class="n">invtyp</span><span class="p">)</span>
        <span class="n">ProjInstance</span><span class="o">.</span><span class="n">dirname</span> <span class="o">=</span> <span class="n">dirname</span>
        <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirname</span><span class="p">,</span> <span class="s1">&#39;invdir&#39;</span><span class="p">))</span> <span class="c1"># we don&#39;t want this invdir anymore</span>
        <span class="k">return</span> <span class="n">ProjInstance</span>


    <span class="k">def</span> <span class="nf">showPseudo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot pseudo-section with dots.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int, optional</span>
<span class="sd">            Index of the survey to be used for the pseudo-section (in case of</span>
<span class="sd">            timelapse or batch).</span>
<span class="sd">        vmin : float, optional</span>
<span class="sd">            Minimum value for colorscale.</span>
<span class="sd">        vmax : float, optional</span>
<span class="sd">            Maximum value for colorscale.</span>
<span class="sd">        ax : matplotlib.Axes, optional</span>
<span class="sd">            If specified, axis along which to plot the graph.</span>
<span class="sd">        **kwargs : optional</span>
<span class="sd">            Passed to `Survey.showPseudo()`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">showPseudo</span><span class="p">(</span><span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">showPseudoIP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot pseudo-section with dots for IP data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int, optional</span>
<span class="sd">            Index of the survey to be used for the pseudo-section (in case of</span>
<span class="sd">            timelapse or batch).</span>
<span class="sd">        vmin : float, optional</span>
<span class="sd">            Minimum value for colorscale.</span>
<span class="sd">        vmax : float, optional</span>
<span class="sd">            Maximum value for colorscale.</span>
<span class="sd">        ax : matplotlib.Axes, optional</span>
<span class="sd">            If specified, axis along which to plot the graph.</span>
<span class="sd">        **kwargs : optional</span>
<span class="sd">            Passed to `Survey.showPseudoIP()`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">showPseudoIP</span><span class="p">(</span><span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">matchSurveys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Will trim all surveys to get them ready for difference inversion</span>
<span class="sd">        where all datasets must have the same number of quadrupoles.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Matching quadrupoles between surveys for difference inversion...&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">dfs</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">df</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">]</span>

        <span class="c1"># sort all dataframe (should already be the case)</span>
        <span class="n">dfs2</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">df</span> <span class="ow">in</span> <span class="n">dfs</span><span class="p">:</span>
            <span class="n">dfs2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="p">)</span><span class="c1">#.sort_values(by=[&#39;a&#39;,&#39;b&#39;,&#39;m&#39;,&#39;n&#39;]).reset_index(drop=True))</span>

        <span class="c1"># concatenate columns of string</span>
        <span class="k">def</span> <span class="nf">cols2str</span><span class="p">(</span><span class="n">cols</span><span class="p">):</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="n">cols</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">cols</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">cols</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">defchararray</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">cols</span><span class="p">[:,</span><span class="n">i</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">x</span>

        <span class="c1"># get measurements common to all surveys</span>
        <span class="n">df0</span> <span class="o">=</span> <span class="n">dfs2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">cols2str</span><span class="p">(</span><span class="n">df0</span><span class="p">[[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;m&#39;</span><span class="p">,</span><span class="s1">&#39;n&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="n">icommon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">df</span> <span class="ow">in</span> <span class="n">dfs2</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">cols2str</span><span class="p">(</span><span class="n">df</span><span class="p">[[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;m&#39;</span><span class="p">,</span><span class="s1">&#39;n&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            <span class="n">ie</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
            <span class="n">icommon</span> <span class="o">=</span> <span class="n">icommon</span> <span class="o">&amp;</span> <span class="n">ie</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">icommon</span><span class="p">),</span> <span class="s1">&#39;in common...&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

        <span class="c1"># create boolean index to match those measurements</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">xcommon</span> <span class="o">=</span> <span class="n">x0</span><span class="p">[</span><span class="n">icommon</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">df</span> <span class="ow">in</span> <span class="n">dfs2</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">cols2str</span><span class="p">(</span><span class="n">df</span><span class="p">[[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;m&#39;</span><span class="p">,</span><span class="s1">&#39;n&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            <span class="n">iedups</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">duplicated</span><span class="p">())</span> <span class="c1"># cols2str() can cause duplicates and messup np.in1d()</span>
            <span class="n">common</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xcommon</span><span class="p">)</span>
            <span class="n">common</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">iedups</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">indexes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">common</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;done in </span><span class="si">{:.3}</span><span class="s1">s&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">t0</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">indexes</span>


    <span class="k">def</span> <span class="nf">showError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot the reciprocal errors.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int, optional</span>
<span class="sd">            Index of the survey to plot. If `index == -1` then all combined</span>
<span class="sd">            data of all survey will be plotted together. Default is to plot</span>
<span class="sd">            the first survey (`index==0`).</span>
<span class="sd">        ax : matplotlib axis, optional</span>
<span class="sd">            If specified, graph will be plotted on the given axis.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fig : matplotlib figure, optional</span>
<span class="sd">            If ax is not specified, the function will return a figure object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span> <span class="c1"># show them all from bigSurvey</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bigSurvey</span><span class="o">.</span><span class="n">showError</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">showError</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">showErrorDist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate and plots reciprocal error probablity histogram.</span>
<span class="sd">        Good data will have a bell shape (normal) distribution where most datapoints have near</span>
<span class="sd">        zero reciprocal error.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int, optional</span>
<span class="sd">            Index of the survey to plot. Default is first survey `index == 0`.</span>
<span class="sd">            If `index == -2` then the error distribution of the combined data</span>
<span class="sd">            will be plotted.</span>
<span class="sd">        ax : Matplotlib.Axes</span>
<span class="sd">            If specified, the graph will be plotted against it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span> <span class="c1"># show them all from bigSurvey</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bigSurvey</span><span class="o">.</span><span class="n">showErrorDist</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">showErrorDist</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">filterManual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Interactive manually filters the data visually. The manually selected</span>
<span class="sd">        points index are stored in `Survey.iselect` or `Survey.eselect``if it is</span>
<span class="sd">        an electrodes. Use `Survey.filterData()` to filter them out for a single</span>
<span class="sd">        survey. Or `R2._filterSimilarQuads()` to filter quadrupoles amongs all</span>
<span class="sd">        `R2.surveys`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">:</span>
                <span class="n">s</span><span class="o">.</span><span class="n">iselect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
                <span class="n">s</span><span class="o">.</span><span class="n">eselect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">elec</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">filterManual</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">darkMode</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">darkMode</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">filterManual</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">darkMode</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">darkMode</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">filterDummy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove measurements where abs(a-b) != abs(m-n) (likely to be dummy</span>
<span class="sd">        measurements added for speed).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int, optional</span>
<span class="sd">            Index of the survey to process. If `index == -1` (default) then the</span>
<span class="sd">            processing is applied on all survey independantly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">:</span>
                <span class="n">s</span><span class="o">.</span><span class="n">filterDummy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">filterDummy</span><span class="p">()</span>
            
    <span class="k">def</span> <span class="nf">fixLegendItems</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ax</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Display legend items with survey names in the case of fitting </span>
<span class="sd">        individual error models to multiple data sets. </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ax : matplotlib axes </span>
<span class="sd">            Axes handle with reciprocal error plots in it. </span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">newlegend</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># list to store new legend entries </span>
        <span class="n">legends</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_legend</span><span class="p">()</span><span class="o">.</span><span class="n">get_texts</span><span class="p">()</span> <span class="c1"># return text objects of the legend entries </span>
        <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># legend count number </span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># survey iteration number </span>
        <span class="n">maxleg</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span> <span class="c1"># maximum number of legends that should be possible </span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">legends</span><span class="p">:</span> 
            <span class="k">if</span> <span class="n">c</span><span class="o">%</span><span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">c</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">i</span><span class="o">+=</span><span class="mi">1</span> 
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> 
            <span class="n">newlegend</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:s}</span><span class="s1"> </span><span class="si">{:s}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">get_text</span><span class="p">()))</span>
            <span class="n">c</span><span class="o">+=</span><span class="mi">1</span> <span class="c1"># add one every time loop is run </span>
            <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="n">maxleg</span><span class="p">:</span>
                <span class="k">break</span> <span class="c1"># TODO: maybe delete surplus legend items in future? </span>
            
        <span class="n">ax</span><span class="o">.</span><span class="n">get_legend</span><span class="p">()</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">newlegend</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span> <span class="c1"># replace legend entries with survey names appended </span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">get_title</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>


    <span class="k">def</span> <span class="nf">fitErrorLin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fit a linear relationship to the resistivity data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int, optional</span>
<span class="sd">            Index of the survey to fit. If `index == -1` (default) then the fit</span>
<span class="sd">            is done on all surveys independantly.</span>
<span class="sd">            If `ndex == -2` then the fit is done on the combined surveys.</span>
<span class="sd">        ax : matplotlib axis, optional</span>
<span class="sd">            If specified, graph will be plotted on the given axis.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fig : matplotlib figure, optional</span>
<span class="sd">            If ax is not specified, the function will return a figure object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span> <span class="c1"># apply to combined survey</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bigSurvey</span><span class="o">.</span><span class="n">fitErrorLin</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">:</span>
                <span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;resError&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bigSurvey</span><span class="o">.</span><span class="n">errorModel</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="c1"># apply to each</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">:</span>
                <span class="n">s</span><span class="o">.</span><span class="n">fitErrorLin</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
            <span class="c1"># redo the legend</span>
            <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fixLegendItems</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">fitErrorLin</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">fitErrorPwl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fit an power law to the resistivity data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int, optional</span>
<span class="sd">            Index of the survey to fit. If `index == -1` (default) then the fit</span>
<span class="sd">            is done on all surveys independantly.</span>
<span class="sd">            If `ndex == -2` then the fit is done on the combined surveys.</span>
<span class="sd">        ax : matplotlib axis, optional</span>
<span class="sd">            If specified, graph will be plotted on the given axis.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fig : matplotlib figure, optional</span>
<span class="sd">            If ax is not specified, the function will return a figure object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span> <span class="c1"># apply to combined data of bigSurvey</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bigSurvey</span><span class="o">.</span><span class="n">fitErrorPwl</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">:</span>
                <span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;resError&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bigSurvey</span><span class="o">.</span><span class="n">errorModel</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="c1"># apply to each</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">:</span>
                <span class="n">s</span><span class="o">.</span><span class="n">fitErrorPwl</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
            <span class="c1"># redo the legend</span>
            <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fixLegendItems</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">fitErrorPwl</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">fitErrorLME</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rpath</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">iplot</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fit a linear mixed effect (LME) model by having the electrodes as</span>
<span class="sd">        as grouping variables.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Index of the survey to fit. If `index == -1` (default) then the fit</span>
<span class="sd">            is done on all surveys independantly.</span>
<span class="sd">            If `ndex == -2` then the fit is done on the combined surveys.</span>
<span class="sd">        ax : matplotlib.Axes, optional</span>
<span class="sd">            If specified, the graph will be plotted against this axis,</span>
<span class="sd">            otherwise a new figure will be created.</span>
<span class="sd">        rpath : str, optional</span>
<span class="sd">            Path of the directory with R (for Windows only).</span>
<span class="sd">        iplot : bool, optional</span>
<span class="sd">            If `True` plot it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span> <span class="c1"># apply to combined data of bigSurvey</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ERROR : LME survey can not be fitted on combined data.&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="c1"># apply to each</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">:</span>
                <span class="n">s</span><span class="o">.</span><span class="n">fitErrorLME</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">rpath</span><span class="o">=</span><span class="n">rpath</span><span class="p">,</span> <span class="n">iplot</span><span class="o">=</span><span class="n">iplot</span><span class="p">)</span>
            <span class="c1"># redo the legend</span>
            <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fixLegendItems</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">fitErrorLME</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">rpath</span><span class="o">=</span><span class="n">rpath</span><span class="p">,</span> <span class="n">iplot</span><span class="o">=</span><span class="n">iplot</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">showErrorIP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot the reciprocal phase discrepancies against the reciprocal mean</span>
<span class="sd">        transfer resistance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int, optional</span>
<span class="sd">            Index of the survey to show. Default is the first survey</span>
<span class="sd">            `index == 0`. If `ndex == -2` then the combined data from all</span>
<span class="sd">            surveys are shown.</span>
<span class="sd">        ax : matplotlib axis, optional</span>
<span class="sd">            If specified, graph will be plotted on the given axis.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fig : matplotlib.Figure, optional</span>
<span class="sd">            If ax is not specified, the function will return a figure object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span> <span class="c1"># show with combined data of bigSurvey</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bigSurvey</span><span class="o">.</span><span class="n">showErrorIP</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">showErrorIP</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">fitErrorPwlIP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot the reciprocal phase errors with a power-law fit.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int, optional</span>
<span class="sd">            Index of the survey to fit. If `index == -1` (default) then the fit</span>
<span class="sd">            is done on all surveys independantly.</span>
<span class="sd">            If `ndex == -2` then the fit is done on the combined surveys.</span>
<span class="sd">        ax : matplotlib axis, optional</span>
<span class="sd">            If specified, graph will be plotted on the given axis.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fig : matplotlib figure, optional</span>
<span class="sd">            If ax is not specified, the function will return a figure object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span> <span class="c1"># apply to combined data of bigSurvey</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bigSurvey</span><span class="o">.</span><span class="n">fitErrorPwlIP</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">:</span>
                <span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;phaseError&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bigSurvey</span><span class="o">.</span><span class="n">phaseErrorModel</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="c1"># apply to each</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">:</span>
                <span class="n">s</span><span class="o">.</span><span class="n">fitErrorPwlIP</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
            <span class="c1"># redo the legend</span>
            <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fixLegendItems</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">fitErrorPwlIP</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">fitErrorParabolaIP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot the reciprocal phase errors with a parabola fit.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int, optional</span>
<span class="sd">            Index of the survey to fit. If `index == -1` (default) then the fit</span>
<span class="sd">            is done on all surveys independantly.</span>
<span class="sd">            If `ndex == -2` then the fit is done on the combined surveys.</span>
<span class="sd">        ax : matplotlib axis, optional</span>
<span class="sd">            If specified, graph will be plotted on the given axis.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fig : matplotlib figure, optional</span>
<span class="sd">            If ax is not specified, the function will return a figure object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span> <span class="c1"># apply to combined data of bigSurvey</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bigSurvey</span><span class="o">.</span><span class="n">fitErrorParabolaIP</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">:</span>
                <span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;phaseError&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bigSurvey</span><span class="o">.</span><span class="n">phaseErrorModel</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="c1"># apply to each</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">:</span>
                <span class="n">s</span><span class="o">.</span><span class="n">fitErrorParabolaIP</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
            <span class="c1"># redo the legend</span>
            <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fixLegendItems</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">fitErrorParabolaIP</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>



    <span class="k">def</span> <span class="nf">showHeatmap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot a phase heatmap (x = M, y = A and value = -phi) based on:</span>
<span class="sd">        Orozco, A. F., K. H. Williams, and A. Kemna (2013),</span>
<span class="sd">        Time-lapse spectral induced polarization imaging of stimulated uranium bioremediation,</span>
<span class="sd">        Near Surf. Geophys., 11(5), 531544, doi:10.3997/1873-0604.2013020)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int, optional</span>
<span class="sd">            Index of the survey to fit. Default is the first survey</span>
<span class="sd">            `index == 0`.</span>
<span class="sd">        ax : matplotlib axis, optional</span>
<span class="sd">            If specified, graph will be plotted on the given axis.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fig : matplotlib figure, optional</span>
<span class="sd">            If ax is not specified, the function will return a figure object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">showHeatmap</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>

    
    <span class="k">def</span> <span class="nf">checkTxSign</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Checking and correcting the polarity of the transfer resistances (flat 2D surveys only !).&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">:</span>
            <span class="c1"># if np.all(s.df[&#39;resist&#39;].values &gt; 0): # TODO why?! </span>
            <span class="n">s</span><span class="o">.</span><span class="n">checkTxSign</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">_filterSimilarQuad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quads</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Filter out similar quadrupole based on iselect (Survey.filterManual)</span>
<span class="sd">        from the specified survey.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        quads : array</span>
<span class="sd">            2D array with an ABMN quadrupole per row.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">totalRemoved</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">:</span>
            <span class="n">i2keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">quad</span> <span class="ow">in</span> <span class="n">quads</span><span class="p">:</span>
                <span class="n">ie</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="p">[[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;m&#39;</span><span class="p">,</span><span class="s1">&#39;n&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span> <span class="o">==</span> <span class="n">quad</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">i2keep</span> <span class="o">=</span> <span class="n">i2keep</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">ie</span>
            <span class="n">s</span><span class="o">.</span><span class="n">filterData</span><span class="p">(</span><span class="n">i2keep</span><span class="p">)</span>
            <span class="n">totalRemoved</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">~</span><span class="n">i2keep</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">totalRemoved</span>


    <span class="k">def</span> <span class="nf">filterRangeIP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">phimin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">phimax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Filter IP data according to a specified range.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int, optional</span>
<span class="sd">            Index of the survey to fit. If `index == -1` (default)</span>
<span class="sd">            then the fit is done on all surveys independantly.</span>
<span class="sd">        phimin : float, optional</span>
<span class="sd">            Minimium phase angle [mrad].</span>
<span class="sd">        phimax : float, optional</span>
<span class="sd">            Maximum phase angle [mrad].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="c1"># apply to each</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">:</span>
                <span class="n">s</span><span class="o">.</span><span class="n">filterRangeIP</span><span class="p">(</span><span class="n">phimin</span><span class="p">,</span> <span class="n">phimax</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">filterRangeIP</span><span class="p">(</span><span class="n">phimin</span><span class="p">,</span> <span class="n">phimax</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">filterRecipIP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove reciprocal for IP data ONLY. Additional arguments to be</span>
<span class="sd">        passed to :func: `~resipy.Survey.filterRecipIP`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span> <span class="c1"># apply to combined data of bigSurvey</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bigSurvey</span><span class="o">.</span><span class="n">filterRecipIP</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">:</span>
                <span class="n">s</span><span class="o">.</span><span class="n">filterRecipIP</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="c1"># apply to each</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">:</span>
                <span class="n">s</span><span class="o">.</span><span class="n">filterRecipIP</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">filterRecipIP</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">filterNested</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Removes nested measurements:</span>
<span class="sd">        Where M or N are in between A and B.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int, optional</span>
<span class="sd">            Index of the survey to fit. If `index == -1` (default) then the fit</span>
<span class="sd">            is done on all surveys independantly.</span>
<span class="sd">            If `ndex == -2` then the fit is done on the combined surveys.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="c1"># apply to each</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">:</span>
                <span class="n">s</span><span class="o">.</span><span class="n">filterNested</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">filterNested</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">addFilteredIP</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add filtered IP to the dataframes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">:</span>
            <span class="n">s</span><span class="o">.</span><span class="n">addFilteredIP</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">filterDCA</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dump</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Execute DCA filtering. Decay Curve Analysis (DCA) based on.</span>
<span class="sd">        Flores Orozco, A., Gallistl, J., Bcker, M., &amp; Williams, K. H. (2017).,</span>
<span class="sd">        Decay curve analysis for data error quantification in time-domain induced polarization imaging.,</span>
<span class="sd">        Geophysics, 83(2), 148. https://doi.org/10.1190/geo2016-0714.1</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int, optional</span>
<span class="sd">            Index of the survey to use for processing. Default `index == -1`</span>
<span class="sd">            will apply the processing to all surveys.</span>
<span class="sd">        dump : function, optional</span>
<span class="sd">            Function onto pass the progress.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">:</span>
                <span class="n">s</span><span class="o">.</span><span class="n">filterDCA</span><span class="p">(</span><span class="n">dump</span><span class="o">=</span><span class="n">dump</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">filterDCA</span><span class="p">(</span><span class="n">dump</span><span class="o">=</span><span class="n">dump</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">filterElec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elec</span><span class="o">=</span><span class="p">[],</span> <span class="n">index</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Filter out measurements associated with specific electrodes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elec : list</span>
<span class="sd">            List of electrode number to be removed.</span>
<span class="sd">        index : int, optional</span>
<span class="sd">            Index of the survey on which to apply the processing. If the</span>
<span class="sd">            processing is to be applied to all surveys then specifiy</span>
<span class="sd">            `index=-1` (default).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">numRemoved</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="c1"># apply to all surveys</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">:</span>
                <span class="n">numRemoved</span> <span class="o">+=</span> <span class="n">s</span><span class="o">.</span><span class="n">filterElec</span><span class="p">(</span><span class="n">elec</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">numRemoved</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">filterElec</span><span class="p">(</span><span class="n">elec</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">numRemoved</span>
                

    <span class="k">def</span> <span class="nf">filterRecip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">percent</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">index</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Filter on reciprocal errors.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int, optional</span>
<span class="sd">            Index of the survey on which to apply the processing. If the</span>
<span class="sd">            processing is to be applied to all surveys then specifiy</span>
<span class="sd">            `index=-1` (default).</span>
<span class="sd">        percent : float, optional</span>
<span class="sd">            Percentage of reciprocal error above witch a measurement will be</span>
<span class="sd">            discarded. 20% by default.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">numRemoved</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="c1"># apply to all surveys</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">:</span>
                <span class="n">numRemoved</span> <span class="o">+=</span> <span class="n">s</span><span class="o">.</span><span class="n">filterRecip</span><span class="p">(</span><span class="n">percent</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">numRemoved</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">filterRecip</span><span class="p">(</span><span class="n">percent</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">numRemoved</span>
    
    
    <span class="k">def</span> <span class="nf">filterStack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">percent</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">index</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Filter on stacking (dev) errors.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int, optional</span>
<span class="sd">            Index of the survey on which to apply the processing. If the</span>
<span class="sd">            processing is to be applied to all surveys then specifiy</span>
<span class="sd">            `index=-1` (default).</span>
<span class="sd">        percent : float, optional</span>
<span class="sd">            Percentage of stacking error above witch a measurement will be</span>
<span class="sd">            discarded. 2% by default.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">numRemoved</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="c1"># apply to all surveys</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">:</span>
                <span class="n">numRemoved</span> <span class="o">+=</span> <span class="n">s</span><span class="o">.</span><span class="n">filterStack</span><span class="p">(</span><span class="n">percent</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">numRemoved</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">filterStack</span><span class="p">(</span><span class="n">percent</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">numRemoved</span>


    <span class="k">def</span> <span class="nf">filterUnpaired</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove quadrupoles that don&#39;t have reciprocals. This might</span>
<span class="sd">        remove dummy measurements added for sequence optimization.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int, optional</span>
<span class="sd">            Index of the survey on which to apply the processing. If the</span>
<span class="sd">            processing is to be applied to all surveys then specifiy</span>
<span class="sd">            `index=-1` (default).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">numRemoved</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="c1"># apply to all surveys</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">:</span>
                <span class="n">numRemoved</span> <span class="o">+=</span> <span class="n">s</span><span class="o">.</span><span class="n">filterUnpaired</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">numRemoved</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">filterUnpaired</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">numRemoved</span>



    <span class="k">def</span> <span class="nf">filterNegative</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove negative apparent resistivty values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">:</span>
            <span class="n">s</span><span class="o">.</span><span class="n">filterNegative</span><span class="p">()</span>
            
    
    <span class="k">def</span> <span class="nf">filterAppResist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Filter measurements by apparent resistivity for surface surveys </span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        vmin : float, optional</span>
<span class="sd">            Minimum value.</span>
<span class="sd">        vmax : float, optional</span>
<span class="sd">            Maximum value.</span>
<span class="sd">        index : int, optional</span>
<span class="sd">            Index of the survey on which to apply the processing. If the</span>
<span class="sd">            processing is to be applied to all surveys then specifiy</span>
<span class="sd">            `index=-1` (default).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">numRemoved</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="c1"># apply to all surveys</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">:</span>
                <span class="n">numRemoved</span> <span class="o">+=</span> <span class="n">s</span><span class="o">.</span><span class="n">filterAppResist</span><span class="p">(</span><span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">numRemoved</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">filterAppResist</span><span class="p">(</span><span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">numRemoved</span>


    <span class="k">def</span> <span class="nf">filterTransferRes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Filter measurements by transfer resistance. </span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        vmin : float, optional</span>
<span class="sd">            Minimum value.</span>
<span class="sd">        vmax : float, optional</span>
<span class="sd">            Maximum value.</span>
<span class="sd">        index : int, optional</span>
<span class="sd">            Index of the survey on which to apply the processing. If the</span>
<span class="sd">            processing is to be applied to all surveys then specifiy</span>
<span class="sd">            `index=-1` (default).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">numRemoved</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="c1"># apply to all surveys</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">:</span>
                <span class="n">numRemoved</span> <span class="o">+=</span> <span class="n">s</span><span class="o">.</span><span class="n">filterTransferRes</span><span class="p">(</span><span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">numRemoved</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">filterTransferRes</span><span class="p">(</span><span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">numRemoved</span>
    
    <span class="k">def</span> <span class="nf">filterContRes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Filter measurements by contact resistance if avialable. </span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        vmin : float, optional</span>
<span class="sd">            Minimum value.</span>
<span class="sd">        vmax : float, optional</span>
<span class="sd">            Maximum value.</span>
<span class="sd">        index : int, optional</span>
<span class="sd">            Index of the survey on which to apply the processing. If the</span>
<span class="sd">            processing is to be applied to all surveys then specifiy</span>
<span class="sd">            `index=-1` (default).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">numRemoved</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="c1"># apply to all surveys</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">:</span>
                <span class="n">numRemoved</span> <span class="o">+=</span> <span class="n">s</span><span class="o">.</span><span class="n">filterContRes</span><span class="p">(</span><span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">numRemoved</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">filterContRes</span><span class="p">(</span><span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">numRemoved</span>

    <span class="k">def</span> <span class="nf">computeFineMeshDepth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the Fine Mesh Depth (FMD) based on electrode</span>
<span class="sd">        positions and the larger dipole spacing. Express as a positive number,</span>
<span class="sd">        it represents the relative vertical distance to extend the fine mesh</span>
<span class="sd">        region below the surface.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dfelec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">dfelec</span> <span class="o">=</span> <span class="n">dfelec</span><span class="p">[</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;remote&#39;</span><span class="p">]]</span> <span class="c1"># discard remote electrode for this</span>
        <span class="n">elec</span> <span class="o">=</span> <span class="n">dfelec</span><span class="p">[[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="s1">&#39;z&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;R2&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;cR2&#39;</span><span class="p">):</span> <span class="c1"># 2D survey:</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iForward</span> <span class="o">==</span> <span class="kc">False</span><span class="p">):</span>
                <span class="n">lookupDict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">dfelec</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dfelec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
                <span class="n">array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">df</span><span class="p">[[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;m&#39;</span><span class="p">,</span><span class="s1">&#39;n&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">lookupDict</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="c1"># strings don&#39;t have max/min</span>
                <span class="n">maxDist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">elec</span><span class="p">[</span><span class="n">array</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">array</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]),</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">elec</span><span class="p">[</span><span class="n">array</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">array</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]),</span><span class="mi">0</span><span class="p">]))</span> <span class="c1"># max dipole separation</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fmd</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="n">maxDist</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># if it&#39;s a forward model for instance</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fmd</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">elec</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">elec</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]))</span>

        <span class="k">else</span><span class="p">:</span> <span class="c1"># for 3D survey</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">elec</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">elec</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">el1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">elec</span><span class="p">):</span>
                <span class="n">dist</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">el1</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]</span> <span class="o">-</span> <span class="n">elec</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fmd</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;buried&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># catch where buried electrodes are present as the fmd needs adjusting in this case </span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;buried&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="c1"># if all buried, we assume surface at 0 m</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fmd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="mi">0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">elec</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]))</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># surface given by max z elec</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fmd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">elec</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>  <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">elec</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]))</span> <span class="o">+</span> <span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">fmd</span><span class="p">)</span>
        <span class="c1"># print(&#39;Fine Mesh Depth (relative to the surface): {:.2f} m&#39;.format(self.fmd))</span>


    <span class="k">def</span> <span class="nf">createMesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typ</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="n">buried</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">surface</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cl_factor</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                   <span class="n">cl</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dump</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">res0</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">show_output</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fmd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">remote</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">refine</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a mesh.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        typ : str, optional</span>
<span class="sd">            Type of mesh.</span>
<span class="sd">            For 2D:</span>
<span class="sd">                - &#39;quad&#39;: quadrilateral (fast to build)</span>
<span class="sd">                - &#39;trian&#39;: triangular (fast to run) - default</span>
<span class="sd">                - &#39;circle&#39;: close circular mesh</span>
<span class="sd">            For 3D: </span>
<span class="sd">                - &#39;tetra&#39;: tetrahedral mesh for half-space - default</span>
<span class="sd">                - &#39;cylinder&#39;: column build with tetrahedral</span>
<span class="sd">                - &#39;prism&#39;: column build with prism</span>
<span class="sd">                - &#39;tank&#39;: closed geometry with tetrahedra</span>
<span class="sd">        buried : numpy.array, optional</span>
<span class="sd">            Boolean array of electrodes that are buried. Should be the same</span>
<span class="sd">            length as `R2.elec`</span>
<span class="sd">        surface : numpy.array, optional</span>
<span class="sd">            Array with two or three columns x, y (optional) and elevation for</span>
<span class="sd">            additional surface points.</span>
<span class="sd">        cl_factor : float, optional</span>
<span class="sd">            Characteristic length factor. Only used for triangular mesh to allow</span>
<span class="sd">            mesh to be refined close the electrodes and then expand.</span>
<span class="sd">        cl : float, optional</span>
<span class="sd">            Characteristic length that define the mesh size around the</span>
<span class="sd">            electrodes.</span>
<span class="sd">        dump : function, optional</span>
<span class="sd">            Function to which pass the output during mesh generation. `print()`</span>
<span class="sd">             is the default.</span>
<span class="sd">        res0 : float, optional</span>
<span class="sd">            Starting resistivity for mesh elements.</span>
<span class="sd">        show_output : bool, optional</span>
<span class="sd">            If `True`, the output of gmsh will be shown on screen.</span>
<span class="sd">        fmd : float, optional</span>
<span class="sd">            Depth of fine region specifies as a positive number relative to the mesh surface.</span>
<span class="sd">        remote : bool, optional</span>
<span class="sd">            Boolean array of electrodes that are remote (ie not real). Should be the same</span>
<span class="sd">            length as `Project.elec`.</span>
<span class="sd">        refine : int, optional</span>
<span class="sd">            Number times the mesh will be refined. Refinement split the triangles</span>
<span class="sd">            or the tetrahedra but keep the same number of parameter for the inversion.</span>
<span class="sd">            This helps having a more accurate forward response and a faster inversion</span>
<span class="sd">            (as the number of elements does not increase). Only available for</span>
<span class="sd">            triangles or tetrahedral mesh.</span>
<span class="sd">        kwargs : -</span>
<span class="sd">            Keyword arguments to be passed to mesh generation schemes</span>
<span class="sd">            Specific for &#39;tank mesh&#39;:</span>
<span class="sd">                - origin : list of 3 floats</span>
<span class="sd">                    Origin in X,Y,Z of one of the tank corner.</span>
<span class="sd">                - dimension : list of 3 floats</span>
<span class="sd">                    Dimension from the corner on how to extend the tank.</span>
<span class="sd">            Specific for &#39;cylinder mesh&#39;:</span>
<span class="sd">                - zlim : list of 2 int</span>
<span class="sd">                For the bottom and top of the column along the Z axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>     
        <span class="k">if</span> <span class="n">dump</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">show_output</span><span class="p">:</span>
                <span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                    <span class="k">pass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meshParams</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;typ&#39;</span><span class="p">:</span><span class="n">typ</span><span class="p">,</span> <span class="s1">&#39;buried&#39;</span><span class="p">:</span><span class="n">buried</span><span class="p">,</span> <span class="s1">&#39;surface&#39;</span><span class="p">:</span><span class="n">surface</span><span class="p">,</span>
                           <span class="s1">&#39;cl_factor&#39;</span><span class="p">:</span><span class="n">cl_factor</span><span class="p">,</span> <span class="s1">&#39;cl&#39;</span><span class="p">:</span><span class="n">cl</span><span class="p">,</span> <span class="s1">&#39;dump&#39;</span><span class="p">:</span><span class="n">dump</span><span class="p">,</span>
                           <span class="s1">&#39;res0&#39;</span><span class="p">:</span> <span class="n">res0</span><span class="p">,</span> <span class="s1">&#39;show_output&#39;</span><span class="p">:</span><span class="n">show_output</span><span class="p">,</span>
                           <span class="s1">&#39;refine&#39;</span><span class="p">:</span><span class="n">refine</span><span class="p">,</span><span class="s1">&#39;fmd&#39;</span><span class="p">:</span><span class="n">fmd</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">kwargs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meshParams</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;R2&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;cR2&#39;</span><span class="p">:</span> <span class="c1"># it&#39;s a 2D mesh</span>
                <span class="n">typ</span> <span class="o">=</span> <span class="s1">&#39;trian&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">typ</span> <span class="o">=</span> <span class="s1">&#39;tetra&#39;</span>
        
        <span class="c1"># flag for if mesh gets refined during mesh creation </span>
        <span class="n">refined</span> <span class="o">=</span> <span class="kc">False</span> 
    
        <span class="c1"># check if remote electrodes present</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;remote&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;quad&#39;</span><span class="p">):</span>
            <span class="n">dump</span><span class="p">(</span><span class="s1">&#39;remote electrode is not supported in quadrilateral mesh for now, please use triangular mesh instead.&#39;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># define electrode types</span>
        <span class="k">if</span> <span class="n">buried</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">buried</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;buried&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">buried</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;length of argument &quot;buried&quot; (</span><span class="si">{:s}</span><span class="s1">) does not match length&#39;</span>
                      <span class="s1">&#39; of self.elec (</span><span class="si">{:d}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">buried</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">elec_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">elec_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">elec_z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">elec_type</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="s1">&#39;electrode&#39;</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">elec_x</span><span class="p">))</span>
        <span class="n">elec_type</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;buried&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;buried&#39;</span>
        <span class="n">elec_type</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;remote&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;remote&#39;</span>
        <span class="n">elecLabels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
        
        <span class="c1"># assign possible topography (surface)</span>
        <span class="k">if</span> <span class="n">surface</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">surface</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">topo</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;z&#39;</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">topo</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="s1">&#39;z&#39;</span><span class="p">])</span>
        
        <span class="c1"># estimate depth of fine mesh</span>
        <span class="k">if</span> <span class="n">fmd</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">computeFineMeshDepth</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fmd</span> <span class="o">=</span> <span class="n">fmd</span>

        <span class="k">if</span> <span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;quad&#39;</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Creating quadrilateral mesh...&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="n">surface_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">topo</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="k">if</span> <span class="n">surface</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">surface_z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">topo</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="k">if</span> <span class="n">surface</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">mesh</span><span class="p">,</span><span class="n">meshx</span><span class="p">,</span><span class="n">meshy</span><span class="p">,</span><span class="n">topo</span><span class="p">,</span><span class="n">e_nodes</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">quadMesh</span><span class="p">(</span><span class="n">elec_x</span><span class="p">,</span><span class="n">elec_z</span><span class="p">,</span><span class="nb">list</span><span class="p">(</span><span class="n">elec_type</span><span class="p">),</span>
                                                         <span class="n">surface_x</span><span class="o">=</span><span class="n">surface_x</span><span class="p">,</span> <span class="n">surface_z</span><span class="o">=</span><span class="n">surface_z</span><span class="p">,</span>
                                                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>   <span class="c1">#generate quad mesh</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;mesh_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">6</span>
            <span class="n">e_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">eNodes</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1"># +1 because of indexing staring at 0 in python</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;node_elec&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">elecLabels</span><span class="p">,</span> <span class="n">e_nodes</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)]</span>

            <span class="k">if</span> <span class="s1">&#39;regions&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">:</span> <span class="c1"># allow to create a new mesh then rerun inversion</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;regions&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="s1">&#39;num_regions&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;num_regions&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">geom_input</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">if</span> <span class="n">surface</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">geom_input</span><span class="p">[</span><span class="s1">&#39;surface&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">topo</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">topo</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">]</span>
                
            <span class="k">if</span> <span class="s1">&#39;geom_input&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">geom_input</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;geom_input&#39;</span><span class="p">])</span>
                <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;geom_input&#39;</span><span class="p">)</span>

            <span class="n">whole_space</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;buried&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="ow">and</span> <span class="n">surface</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># all electrodes buried and no surface given</span>
                <span class="n">whole_space</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="n">elec_type</span> <span class="o">=</span> <span class="n">elec_type</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

            <span class="k">def</span> <span class="nf">setMeshProc</span><span class="p">(</span><span class="n">a</span><span class="p">):</span> <span class="c1"># little function to be passed to meshTools fct</span>
            <span class="c1"># to get the variable outputed by Popen (allow mesh killing in UI)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mproc</span> <span class="o">=</span> <span class="n">a</span>
                
            <span class="k">with</span> <span class="n">cd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">):</span><span class="c1">#change to working directory so that mesh files written in working directory</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mproc</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;trian&#39;</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Creating triangular mesh...&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                    <span class="n">mesh</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">triMesh</span><span class="p">(</span><span class="n">elec_x</span><span class="p">,</span><span class="n">elec_z</span><span class="p">,</span><span class="n">elec_type</span><span class="p">,</span><span class="n">geom_input</span><span class="p">,</span>
                                 <span class="n">path</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">apiPath</span><span class="p">,</span> <span class="s1">&#39;exe&#39;</span><span class="p">),</span>
                                 <span class="n">cl_factor</span><span class="o">=</span><span class="n">cl_factor</span><span class="p">,</span>
                                 <span class="n">cl</span><span class="o">=</span><span class="n">cl</span><span class="p">,</span> <span class="n">dump</span><span class="o">=</span><span class="n">dump</span><span class="p">,</span> <span class="n">show_output</span><span class="o">=</span><span class="n">show_output</span><span class="p">,</span>
                                 <span class="n">fmd</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fmd</span><span class="p">,</span> <span class="n">whole_space</span><span class="o">=</span><span class="n">whole_space</span><span class="p">,</span>
                                 <span class="n">handle</span><span class="o">=</span><span class="n">setMeshProc</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;circle&#39;</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Creating circular mesh...NOT IMPLEMENTED YET&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                    <span class="n">mesh</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">circularMesh</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">elec_x</span><span class="p">,</span> <span class="n">elec_y</span><span class="p">,</span> <span class="n">elec_z</span><span class="p">],</span>
                                             <span class="n">path</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">apiPath</span><span class="p">,</span> <span class="s1">&#39;exe&#39;</span><span class="p">),</span>
                                             <span class="n">cl</span><span class="o">=</span><span class="n">cl</span><span class="p">,</span> <span class="n">dump</span><span class="o">=</span><span class="n">dump</span><span class="p">,</span> <span class="n">show_output</span><span class="o">=</span><span class="n">show_output</span><span class="p">,</span>
                                             <span class="n">handle</span><span class="o">=</span><span class="n">setMeshProc</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;num_xy_poly&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    
                <span class="k">elif</span> <span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;tetra&#39;</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Creating tetrahedral mesh...&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>    
                    <span class="k">if</span> <span class="n">cl</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">dist</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;remote&#39;</span><span class="p">]][[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="c1"># half the minimal electrode distance</span>
                        <span class="n">cl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">dist</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">])</span>
                    <span class="n">mesh</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">tetraMesh</span><span class="p">(</span><span class="n">elec_x</span><span class="p">,</span> <span class="n">elec_y</span><span class="p">,</span> <span class="n">elec_z</span><span class="p">,</span><span class="n">elec_type</span><span class="p">,</span>
                                 <span class="n">path</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">apiPath</span><span class="p">,</span> <span class="s1">&#39;exe&#39;</span><span class="p">),</span>
                                 <span class="n">surface_refinement</span><span class="o">=</span><span class="n">surface</span><span class="p">,</span>
                                 <span class="n">cl_factor</span><span class="o">=</span><span class="n">cl_factor</span><span class="p">,</span>
                                 <span class="n">cl</span><span class="o">=</span><span class="n">cl</span><span class="p">,</span> <span class="n">dump</span><span class="o">=</span><span class="n">dump</span><span class="p">,</span> <span class="n">show_output</span><span class="o">=</span><span class="n">show_output</span><span class="p">,</span>
                                 <span class="n">fmd</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fmd</span><span class="p">,</span> <span class="n">whole_space</span><span class="o">=</span><span class="n">whole_space</span><span class="p">,</span>
                                 <span class="n">handle</span><span class="o">=</span><span class="n">setMeshProc</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;prism&#39;</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Creating prism mesh...&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                    <span class="n">mesh</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">prismMesh</span><span class="p">(</span><span class="n">elec_x</span><span class="p">,</span> <span class="n">elec_y</span><span class="p">,</span> <span class="n">elec_z</span><span class="p">,</span>
                                         <span class="n">path</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">apiPath</span><span class="p">,</span> <span class="s1">&#39;exe&#39;</span><span class="p">),</span>
                                         <span class="n">cl</span><span class="o">=</span><span class="n">cl</span><span class="p">,</span> <span class="n">dump</span><span class="o">=</span><span class="n">dump</span><span class="p">,</span> <span class="n">show_output</span><span class="o">=</span><span class="n">show_output</span><span class="p">,</span>
                                         <span class="n">handle</span><span class="o">=</span><span class="n">setMeshProc</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;num_xz_poly&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="c1"># self.iadvanced = False # as current implimentation of advanced mesh doesnt work with prisms </span>
                <span class="k">elif</span> <span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;cylinder&#39;</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Creating cylinder mesh...&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                    <span class="n">mesh</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">cylinderMesh</span><span class="p">(</span><span class="n">elec_x</span><span class="p">,</span> <span class="n">elec_y</span><span class="p">,</span> <span class="n">elec_z</span><span class="p">,</span>
                                             <span class="n">path</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">apiPath</span><span class="p">,</span> <span class="s1">&#39;exe&#39;</span><span class="p">),</span>
                                             <span class="n">cl</span><span class="o">=</span><span class="n">cl</span><span class="p">,</span> <span class="n">cl_factor</span><span class="o">=</span><span class="n">cl_factor</span><span class="p">,</span> <span class="n">dump</span><span class="o">=</span><span class="n">dump</span><span class="p">,</span> 
                                             <span class="n">show_output</span><span class="o">=</span><span class="n">show_output</span><span class="p">,</span>
                                             <span class="n">handle</span><span class="o">=</span><span class="n">setMeshProc</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;num_xz_poly&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="c1"># self.iadvanced = False # ditto </span>
                <span class="k">elif</span> <span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;tank&#39;</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Creating tank mesh...&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                    <span class="n">mesh</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">tankMesh</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">elec_x</span><span class="p">,</span> <span class="n">elec_y</span><span class="p">,</span> <span class="n">elec_z</span><span class="p">],</span>
                                             <span class="n">path</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">apiPath</span><span class="p">,</span> <span class="s1">&#39;exe&#39;</span><span class="p">),</span>
                                             <span class="n">cl</span><span class="o">=</span><span class="n">cl</span><span class="p">,</span> <span class="n">dump</span><span class="o">=</span><span class="n">dump</span><span class="p">,</span> <span class="n">show_output</span><span class="o">=</span><span class="n">show_output</span><span class="p">,</span>
                                             <span class="n">handle</span><span class="o">=</span><span class="n">setMeshProc</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;num_xz_poly&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mproc</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># mesh successfully done so let&#39;s put this back to None in case it isn&#39;t already</span>

            <span class="c1"># mesh refinement</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">typ</span> <span class="o">!=</span> <span class="s1">&#39;prism&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">typ</span> <span class="o">!=</span> <span class="s1">&#39;quad&#39;</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">refine</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;refining...&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                    <span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">refine</span><span class="p">()</span>
                <span class="n">refined</span> <span class="o">=</span> <span class="kc">True</span> 
                
            <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;mesh_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span>
            <span class="n">e_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">eNodes</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1"># +1 because of indexing staring at 0 in python</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;node_elec&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">elecLabels</span><span class="p">,</span> <span class="n">e_nodes</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;mesh&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mesh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;num_regions&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;res0File&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;res0.dat&#39;</span>
        <span class="n">numel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">numel</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">addAttribute</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">numel</span><span class="p">)</span><span class="o">*</span><span class="n">res0</span><span class="p">,</span> <span class="s1">&#39;res0&#39;</span><span class="p">)</span> <span class="c1"># default starting resisivity [Ohm.m]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">addAttribute</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">numel</span><span class="p">)</span><span class="o">*</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;phase0&#39;</span><span class="p">)</span> <span class="c1"># default starting phase [mrad]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">addAttribute</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">numel</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="s1">&#39;zones&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">addAttribute</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">numel</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span> <span class="s1">&#39;iter&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">refined</span><span class="p">:</span> <span class="c1"># dont want to re-allocate parameter number it has already been assigned  </span>
            <span class="c1">## is bugged in 2D, needs fixing! ## </span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">addAttribute</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">numel</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;param&#39;</span><span class="p">)</span> <span class="c1"># param = 0 if fixed</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="o">==</span><span class="s1">&#39;R2&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">addAttribute</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">numel</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;param&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;reqMemory&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">getSysStat</span><span class="p">()[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_estimateMemory</span><span class="p">(</span><span class="n">dump</span><span class="o">=</span><span class="n">dump</span><span class="p">)</span> <span class="c1"># if negative then we need more RAM</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">iremote</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;remote&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        
        <span class="c1"># define zlim</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;tank&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;cylinder&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;prism&#39;</span><span class="p">):</span>
            <span class="n">zmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">node</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">zmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">node</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">extent</span> <span class="o">=</span> <span class="n">zmax</span> <span class="o">-</span> <span class="n">zmin</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zlim</span> <span class="o">=</span> <span class="p">[</span><span class="n">zmin</span> <span class="o">-</span> <span class="mf">0.1</span><span class="o">*</span><span class="n">extent</span><span class="p">,</span> <span class="n">zmax</span> <span class="o">+</span> <span class="mf">0.1</span><span class="o">*</span><span class="n">extent</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">surface</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">zlimTop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">elec_z</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">surface</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">])])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">zlimTop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">elec_z</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;buried&#39;</span><span class="p">])</span> <span class="ow">and</span> <span class="n">surface</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># whole mesh</span>
                <span class="n">zlimBot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">elec_z</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;buried&#39;</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">surface</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">zlimBot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">elec_z</span><span class="p">[</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;buried&#39;</span><span class="p">]])</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">fmd</span> 
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">zlimBot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">topo</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">fmd</span> 
            <span class="k">else</span><span class="p">:</span>
                <span class="n">zlimBot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">elec_z</span><span class="p">[</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;remote&#39;</span><span class="p">]])</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">fmd</span> 
                
            <span class="bp">self</span><span class="o">.</span><span class="n">zlim</span> <span class="o">=</span> <span class="p">[</span><span class="n">zlimBot</span><span class="p">,</span> <span class="n">zlimTop</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_computePolyTable</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;done (</span><span class="si">{:d}</span><span class="s1"> elements)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        
        
    <span class="k">def</span> <span class="nf">_computePolyTable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># define num_xz_poly or num_xy_poly</span>
        <span class="n">elec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;remote&#39;</span><span class="p">]][[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="s1">&#39;z&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">elec_x</span><span class="p">,</span> <span class="n">elec_y</span><span class="p">,</span> <span class="n">elec_z</span> <span class="o">=</span> <span class="n">elec</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">elec</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">elec</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;R2&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;cR2&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;num_xz_poly&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;buried&#39;</span><span class="p">]):</span> <span class="c1"># we don&#39;t know if there is a surface</span>
            <span class="c1"># or not so we trust the zlim computation done in createMesh()</span>
                <span class="n">zmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zlim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">zmin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zlim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">zmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">elec_z</span><span class="p">)</span>
                <span class="n">zmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">elec_z</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">fmd</span> 
            <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">elec_x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">elec_x</span><span class="p">)</span>
            <span class="n">xz_poly_table</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="p">[</span><span class="n">xmin</span><span class="p">,</span> <span class="n">zmax</span><span class="p">],</span>
            <span class="p">[</span><span class="n">xmax</span><span class="p">,</span> <span class="n">zmax</span><span class="p">],</span>
            <span class="p">[</span><span class="n">xmax</span><span class="p">,</span> <span class="n">zmin</span><span class="p">],</span>
            <span class="p">[</span><span class="n">xmin</span><span class="p">,</span> <span class="n">zmin</span><span class="p">],</span>
            <span class="p">[</span><span class="n">xmin</span><span class="p">,</span> <span class="n">zmax</span><span class="p">]])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;xz_poly_table&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xz_poly_table</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;num_xy_poly&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
            <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">elec_x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">elec_x</span><span class="p">)</span>
            <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">elec_y</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">elec_y</span><span class="p">)</span>
            <span class="n">zmin</span><span class="p">,</span> <span class="n">zmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">elec_z</span><span class="p">)</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">fmd</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">elec_z</span><span class="p">)</span>
            <span class="n">xz_poly_table</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="p">[</span><span class="n">xmin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">],</span>
            <span class="p">[</span><span class="n">xmax</span><span class="p">,</span> <span class="n">ymax</span><span class="p">],</span>
            <span class="p">[</span><span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">],</span>
            <span class="p">[</span><span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span><span class="p">],</span>
            <span class="p">[</span><span class="n">xmin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">]])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;zmin&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">zmin</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;zmax&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">zmax</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;xy_poly_table&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xz_poly_table</span>

    
    <span class="k">def</span> <span class="nf">_defineZlim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes zlim&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fmd</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">computeFineMeshDepth</span><span class="p">()</span>
        <span class="n">zlimMax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">zlimMin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">fmd</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zlim</span> <span class="o">=</span> <span class="p">[</span><span class="n">zlimMin</span><span class="p">,</span> <span class="n">zlimMax</span><span class="p">]</span>
        

    <span class="k">def</span> <span class="nf">importMesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_path</span><span class="p">,</span> <span class="n">mesh_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">node_pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">elec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">order_nodes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">res0</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Import mesh from .vtk / .msh / .dat, rather than having ResIPy</span>
<span class="sd">        create one for you.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        file_path : str</span>
<span class="sd">            File path mapping to the mesh file</span>
<span class="sd">        mesh_type : str</span>
<span class="sd">            Not used anymore. </span>
<span class="sd">        node_pos : array like, optional</span>
<span class="sd">            Array of ints referencing the electrode nodes. If left as none no electrodes</span>
<span class="sd">            will be added to the mesh class. Consider using mesh.moveElecNodes()</span>
<span class="sd">            to add nodes to mesh using their xyz coordinates.</span>
<span class="sd">        elec : array, optional</span>
<span class="sd">            N*3 numpy array of electrode x,y,z coordinates. Electrode node positions</span>
<span class="sd">            will be computed by finding the nearest nodes to the relevant coordinates.</span>
<span class="sd">        res0 : float, optional</span>
<span class="sd">            Starting resistivity for mesh elements.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;R3t&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;cR3t&#39;</span><span class="p">):</span>
            <span class="n">flag_3D</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">flag_3D</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">readMesh</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">node_pos</span><span class="o">=</span><span class="n">node_pos</span><span class="p">,</span> 
                                          <span class="n">order_nodes</span><span class="o">=</span><span class="n">order_nodes</span><span class="p">)</span>

        <span class="c1"># recover region based on resistivity</span>
        <span class="k">if</span> <span class="n">file_path</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span> <span class="o">==</span> <span class="s1">&#39;.vtk&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;Resistivity(ohm.m)&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;Resistivity(ohm.m)&#39;</span><span class="p">]</span>
                <span class="n">ures</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">reg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ures</span><span class="p">):</span>
                    <span class="n">ie</span> <span class="o">=</span> <span class="n">res</span> <span class="o">==</span> <span class="n">reg</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ie</span><span class="p">,</span> <span class="s1">&#39;region&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
            
        <span class="k">if</span> <span class="n">elec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">moveElecNodes</span><span class="p">(</span><span class="n">elec</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">elec</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">elec</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>

        <span class="c1">#add the electrodes to the R2 class</span>
        <span class="k">if</span> <span class="n">elec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">node_pos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># then electrode positions should be known</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setElec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">elec</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">elec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="s1">&#39;z&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">moveElecNodes</span><span class="p">(</span><span class="n">elec</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">elec</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">elec</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;No electrode nodes associated with mesh! Electrode positions are unknown!&quot;</span><span class="p">)</span>

        <span class="c1">#R2 class mesh handling</span>
        <span class="n">e_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">eNodes</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1"># +1 because of indexing staring at 0 in python</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;mesh&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span>
        <span class="c1"># if mesh_type == &#39;quad&#39;:</span>
        <span class="c1">#     self.param[&#39;mesh_type&#39;] = 6</span>
        <span class="c1">#     colx = self.mesh.quadMeshNp() # convert nodes into column indexes</span>
        <span class="c1">#     self.param[&#39;node_elec&#39;] = np.c_[1+np.arange(len(e_nodes)), np.array(colx), np.ones((len(e_nodes,1)))].astype(int)</span>
            <span class="c1">#will only work for assuming electrodes are a surface array</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">type2VertsNo</span><span class="p">()</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">flag_3D</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;mesh_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span> <span class="c1"># tetra mesh</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;mesh_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">6</span> <span class="c1"># general quad mesh</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">flag_3D</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;mesh_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">6</span> <span class="c1"># prism mesh </span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;mesh_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span> <span class="c1"># triangular mesh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;node_elec&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">e_nodes</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)]</span>

        <span class="c1"># checking</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">e_nodes</span><span class="p">))</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">e_nodes</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Some electrodes are positionned on the same nodes : e_nodes=&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">e_nodes</span><span class="p">))</span>
        
        <span class="c1"># make regions continuous</span>
        <span class="n">regions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;region&#39;</span><span class="p">]</span>
        <span class="n">uregions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">regions</span><span class="p">)</span>
        <span class="n">iregions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">uregions</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">dico</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">uregions</span><span class="p">,</span> <span class="n">iregions</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;region&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">dico</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">regions</span><span class="p">]</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;num_regions&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;res0File&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;res0.dat&#39;</span>
        <span class="n">numel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">numel</span>
        <span class="k">if</span> <span class="s1">&#39;res0&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;res0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">numel</span><span class="p">)</span><span class="o">*</span><span class="n">res0</span> <span class="c1"># default starting resisivity [Ohm.m]</span>
        <span class="k">if</span> <span class="s1">&#39;phase0&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;phase0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">numel</span><span class="p">)</span><span class="o">*</span><span class="mi">0</span> <span class="c1"># default starting phase [mrad]</span>
        <span class="k">if</span> <span class="s1">&#39;zones&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;zones&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">numel</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;zones&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;zones&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="c1"># for some reason read as float</span>
        <span class="k">if</span> <span class="s1">&#39;iter&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;iter&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">numel</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">iremote</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;remote&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;R3t&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;cR3t&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">datAdv</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="s1">&#39;mesh3d.dat&#39;</span><span class="p">),</span> <span class="n">iadvanced</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">iadvanced</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">dat</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="s1">&#39;mesh.dat&#39;</span><span class="p">))</span>

        <span class="c1"># define zlim</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">zlim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_defineZlim</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_computePolyTable</span><span class="p">()</span>
        

    <span class="k">def</span> <span class="nf">showMesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Display the mesh and handles best default values. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">findminmax</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">a</span><span class="p">),</span><span class="nb">max</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Mesh undefined&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">elec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
            <span class="n">elec</span> <span class="o">=</span> <span class="n">elec</span><span class="p">[</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;remote&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,:]</span>
            <span class="k">if</span> <span class="s1">&#39;zlim&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;zlim&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zlim</span>
                
            <span class="k">if</span> <span class="s1">&#39;xlim&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span> <span class="c1"># best to use limits provided by R2 becuase it knows if electrodes are remote </span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;xlim&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">findminmax</span><span class="p">(</span><span class="n">elec</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="s1">&#39;ylim&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;t&#39;</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ylim&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">findminmax</span><span class="p">(</span><span class="n">elec</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
                
            <span class="k">if</span> <span class="s1">&#39;color_map&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span> <span class="c1"># pick a color map based on display type</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;t&#39;</span><span class="p">:</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;color_map&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Greys&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;color_map&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;gray&#39;</span>
                    
            <span class="k">if</span> <span class="s1">&#39;attr&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;attr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;region&#39;</span> <span class="c1"># this will show regions by default</span>
                
            <span class="k">if</span> <span class="s1">&#39;color_bar&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;region&#39;</span><span class="p">]))</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;color_bar&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># show colorbar for multiple regions</span>
                    <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;attr&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;region&#39;</span> <span class="ow">and</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;color_map&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Greys&#39;</span><span class="p">:</span>
                        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;color_map&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Spectral&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;color_bar&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            
            <span class="k">if</span> <span class="s1">&#39;typ&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshParams</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;tank&#39;</span><span class="p">,</span> <span class="s1">&#39;cylinder&#39;</span><span class="p">,</span> <span class="s1">&#39;prism&#39;</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshParams</span><span class="p">[</span><span class="s1">&#39;typ&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">a</span><span class="p">:</span>
                        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;clipping&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span> 
        
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">darkMode</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">darkMode</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            
    <span class="k">def</span> <span class="nf">refineMesh</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">refine</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">write2in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="o">=</span><span class="p">{}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create configuration file for inversion. Write mesh.dat and res0.dat.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        param : dict</span>
<span class="sd">            Dictionnary of parameters and values for the inversion settings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">err</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="s1">&#39;a_wgt&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;a_wgt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;b_wgt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;R2&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;R3t&#39;</span><span class="p">):</span> <span class="c1"># DC case</span>
            <span class="k">if</span> <span class="s1">&#39;a_wgt&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;a_wgt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.01</span>
            <span class="k">if</span> <span class="s1">&#39;b_wgt&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;b_wgt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.02</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;cR2&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;cR3t&#39;</span><span class="p">):</span> <span class="c1"># IP case</span>
            <span class="k">if</span> <span class="s1">&#39;a_wgt&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;a_wgt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.02</span> <span class="c1"># variance for magnitude (no more offset)</span>
            <span class="k">if</span> <span class="s1">&#39;b_wgt&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;b_wgt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="c1"># mrad</span>
        
        <span class="c1">#catch infinite z limits </span>
        <span class="k">if</span> <span class="s1">&#39;zmin&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;zmin&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;zmin&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">node</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span> <span class="o">-</span> <span class="mi">10</span> 
        <span class="k">if</span> <span class="s1">&#39;zmax&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;zmax&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;zmax&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">node</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="mi">10</span> 

        <span class="c1"># all those parameters are default but the user can change them and call</span>
        <span class="c1"># write2in again</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">param</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">param</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iTimeLapse</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># set background survey parameters first</span>
            <span class="n">refdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="s1">&#39;ref&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">refdir</span><span class="p">)</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">refdir</span><span class="p">)</span>
            <span class="n">param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">err</span><span class="p">:</span>
                <span class="n">param</span><span class="p">[</span><span class="s1">&#39;a_wgt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">param</span><span class="p">[</span><span class="s1">&#39;b_wgt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># default DC case as timelapse not supported for IP yet</span>
                <span class="k">if</span> <span class="s1">&#39;a_wgt&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">param</span><span class="p">:</span><span class="c1">#this allows previously assigned values to be</span>
                    <span class="n">param</span><span class="p">[</span><span class="s1">&#39;a_wgt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.01</span> <span class="c1"># written to the reference.in config file</span>
                <span class="k">if</span> <span class="s1">&#39;b_wgt&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">param</span><span class="p">:</span>
                    <span class="n">param</span><span class="p">[</span><span class="s1">&#39;b_wgt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.02</span>
            <span class="n">param</span><span class="p">[</span><span class="s1">&#39;reg_mode&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># set by default in ui.py too</span>
            <span class="n">param</span><span class="p">[</span><span class="s1">&#39;res0File&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;res0.dat&#39;</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;R2&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;cR2&#39;</span><span class="p">):</span>
                <span class="n">param</span><span class="p">[</span><span class="s1">&#39;num_xz_poly&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">param</span><span class="p">[</span><span class="s1">&#39;num_xy_poly&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">param</span><span class="p">[</span><span class="s1">&#39;inverse_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># normal regularisation</span>
                <span class="n">param</span><span class="p">[</span><span class="s1">&#39;zmin&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">node</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span> <span class="o">-</span> <span class="mi">10</span> <span class="c1"># we want to keep the whole mesh for background regularisation</span>
                <span class="n">param</span><span class="p">[</span><span class="s1">&#39;zmax&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">node</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="mi">10</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">configFile</span> <span class="o">=</span> <span class="n">write2in</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">refdir</span><span class="p">,</span> <span class="n">typ</span><span class="o">=</span><span class="n">typ</span><span class="p">)</span> <span class="c1"># background survey</span>
            
            <span class="c1"># now prepare the actual timelapse settings</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;num_regions&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="s1">&#39;reg_mode&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;reg_mode&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;res0File&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Start_res.dat&#39;</span>
            <span class="n">write2in</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="n">typ</span><span class="o">=</span><span class="n">typ</span><span class="p">)</span> <span class="c1"># actual time-lapse</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">configFile</span> <span class="o">=</span> <span class="n">write2in</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="n">typ</span><span class="o">=</span><span class="n">typ</span><span class="p">)</span>

        <span class="c1"># writing mesh.dat</span>
        <span class="n">ifixed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;param&#39;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ifixed</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># fixed element need to be at the end</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">orderElem</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">writeAttr</span><span class="p">(</span><span class="s1">&#39;res0&#39;</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="s1">&#39;Start_res.dat&#39;</span><span class="p">))</span> <span class="c1"># needs rewriting if the elements are reordered. </span>
            
        <span class="k">if</span> <span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;R3t&#39;</span> <span class="ow">or</span> <span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;cR3t&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">datAdv</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="s1">&#39;mesh3d.dat&#39;</span><span class="p">),</span> <span class="n">iadvanced</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">iadvanced</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">dat</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="s1">&#39;mesh.dat&#39;</span><span class="p">))</span>
        
        <span class="c1"># write the res0.dat needed for starting resistivity</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iForward</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span> <span class="c1"># we will invert results from forward</span>
            <span class="c1"># inversion so we need to start from a homogeneous model</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;All non fixed parameters reset to 100 Ohm.m and 0 mrad, &#39;</span>
                  <span class="s1">&#39;as the survey to be inverted is from a forward model.&#39;</span><span class="p">)</span>
            <span class="n">ifixed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;param&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="n">res0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;res0&#39;</span><span class="p">])</span>
            <span class="c1"># res0 = np.zeros(self.mesh.numel)+100</span>
            <span class="n">phase0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;phase0&#39;</span><span class="p">])</span>
            <span class="n">phase0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">numel</span><span class="p">)</span>
            <span class="n">res0f</span> <span class="o">=</span> <span class="n">res0</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">phase0f</span> <span class="o">=</span> <span class="n">phase0</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">res0f</span><span class="p">[</span><span class="o">~</span><span class="n">ifixed</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span>
            <span class="n">phase0f</span><span class="p">[</span><span class="o">~</span><span class="n">ifixed</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;res0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">res0f</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;phase0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">phase0f</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;cR2&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;cR3t&#39;</span><span class="p">):</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;res0&#39;</span><span class="p">])</span>
            <span class="n">phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;phase0&#39;</span><span class="p">])</span>
            <span class="n">centroids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">elmCentre</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">centroids2</span> <span class="o">=</span> <span class="n">centroids</span><span class="p">[:,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;t&#39;</span> <span class="k">else</span> <span class="n">centroids</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">centroids2</span><span class="p">,</span>
                      <span class="n">r</span><span class="p">,</span>
                      <span class="n">phase</span><span class="p">,</span> <span class="c1"># mrad</span>
                      <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">r</span><span class="p">),</span>
                      <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="o">-</span><span class="n">phase</span><span class="o">/</span><span class="mi">1000</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">r</span><span class="p">)),</span> <span class="c1">#log10(real conductivity)</span>
                      <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="o">-</span><span class="n">phase</span><span class="o">/</span><span class="mi">1000</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">r</span><span class="p">))]</span> <span class="c1">#log10(imaginary conductivity)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="s1">&#39;res0.dat&#39;</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">writeAttr</span><span class="p">(</span><span class="s1">&#39;res0&#39;</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="s1">&#39;res0.dat&#39;</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iForward</span><span class="p">:</span> <span class="c1"># restore initial res0 and phase0 so that user can </span>
        <span class="c1"># rerun the forward model with a different sequence for instance</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;res0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">res0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;phase0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">phase0</span><span class="p">)</span>
            

    <span class="k">def</span> <span class="nf">write2protocol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">err</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">errTot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fm0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Write a protocol.dat file for the inversion code.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        err : bool, optional</span>
<span class="sd">            If `True` error columns will be written in protocol.dat provided</span>
<span class="sd">            an error model has been fitted or errors have been imported.</span>
<span class="sd">        errTot : bool, optional</span>
<span class="sd">            If `True`, it will compute the modelling error due to the mesh and</span>
<span class="sd">            add it to the error from an error model.</span>
<span class="sd">        fm0 : numpy.array of float, optional</span>
<span class="sd">            Only for 3D time-lapse with reg_mode == 2 (difference inversion).</span>
<span class="sd">            Response of the inverted reference survey according to sequence of</span>
<span class="sd">            the reference survey as transfer resistance (Ohm).</span>
<span class="sd">        **kwargs : optional</span>
<span class="sd">            To be passed to `Survey.write2protocol()`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span>
            <span class="n">ipBool</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ipBool</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;R2&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;cR2&#39;</span><span class="p">:</span>
            <span class="n">threed</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">threed</span> <span class="o">=</span> <span class="kc">True</span>
            
        <span class="k">if</span> <span class="n">err</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">err</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">err</span>
        <span class="n">errTyp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">errTyp</span> <span class="c1"># either &#39;global&#39; (default) or &#39;survey&#39;</span>

        <span class="c1"># important changing sign of resistivity and quadrupoles so to work</span>
        <span class="c1"># with complex resistivity</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">:</span>
                <span class="n">ie</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;resist&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">&lt;</span> <span class="mi">0</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;m&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ie</span><span class="p">,</span> <span class="s1">&#39;m&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="n">ie</span><span class="p">]</span>
                <span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ie</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="n">ie</span><span class="p">]</span>
                <span class="c1"># let&#39;s change the sign as cR2 will take the log of it anyway</span>
                <span class="c1"># and we are dealing with a magnitude here, not a resistivity</span>
                <span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ie</span><span class="p">,</span> <span class="s1">&#39;resist&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ie</span><span class="p">,</span> <span class="s1">&#39;resist&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">*-</span><span class="mi">1</span>
                <span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ie</span><span class="p">,</span> <span class="s1">&#39;recipMean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ie</span><span class="p">,</span> <span class="s1">&#39;recipMean&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">*-</span><span class="mi">1</span>
        
        <span class="c1"># check transfer resistance sign</span>
        <span class="k">if</span> <span class="s1">&#39;checkTxSign&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;checkTxSign&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">checkTxSign</span><span class="p">()</span>
            
        <span class="c1"># for time-lapse inversion ------------------------------</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iTimeLapse</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;reg_mode&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;reg_mode&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="c1"># by default it&#39;s timelapse (difference)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;reg_mode&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="c1"># it&#39;s a difference inversion</span>
                <span class="n">indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matchSurveys</span><span class="p">()</span>
                <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;R3t&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;cR3t&#39;</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">fm0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">fm0</span> <span class="o">=</span> <span class="n">fm0</span><span class="p">[</span><span class="n">indexes</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="c1"># we crop it so it has the same</span>
                        <span class="c1"># shape as all quad in common</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">indexes</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">)</span>
            <span class="c1"># a bit simplistic but assign error to all based on Transfer resistance</span>
            <span class="c1"># let&#39;s assume it&#39;s False all the time for now</span>
            <span class="n">content</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="n">df0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">df</span><span class="p">[[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;m&#39;</span><span class="p">,</span><span class="s1">&#39;n&#39;</span><span class="p">,</span><span class="s1">&#39;resist&#39;</span><span class="p">,</span><span class="s1">&#39;recipMean&#39;</span><span class="p">]]</span>
            <span class="n">df0</span> <span class="o">=</span> <span class="n">df0</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;resist&#39;</span><span class="p">:</span><span class="s1">&#39;resist0&#39;</span><span class="p">,</span> <span class="s1">&#39;recipMean&#39;</span><span class="p">:</span><span class="s1">&#39;recipMean0&#39;</span><span class="p">})</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">):</span>
                <span class="k">if</span> <span class="s1">&#39;resist0&#39;</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                    <span class="n">s</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;resist0&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="s1">&#39;recipMean0&#39;</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                    <span class="n">s</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;recipMean0&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">s</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">df0</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;m&#39;</span><span class="p">,</span><span class="s1">&#39;n&#39;</span><span class="p">],</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>
                <span class="c1"># resError and phaseError should already have been populated</span>
                <span class="c1"># handle the case when SOME survey were fitted but not all</span>
                <span class="c1"># then we use the bigSurvey default fit to fullfill them</span>
                <span class="k">if</span> <span class="n">err</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">errTyp</span> <span class="o">==</span> <span class="s1">&#39;global&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;resError&#39;</span><span class="p">]))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># there is some nan</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Survey </span><span class="si">{:s}</span><span class="s1"> has no fitted error model, default to combined fit.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bigSurvey</span><span class="o">.</span><span class="n">errorModel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">bigSurvey</span><span class="o">.</span><span class="n">fitErrorPwl</span><span class="p">()</span> <span class="c1"># default fit</span>
                        <span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;resError&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bigSurvey</span><span class="o">.</span><span class="n">errorModel</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;c&#39;</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;phaseError&#39;</span><span class="p">]))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># there is some nan</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Survey </span><span class="si">{:s}</span><span class="s1"> has no fitted IP error model, default to combined fit.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bigSurvey</span><span class="o">.</span><span class="n">errorModel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">bigSurvey</span><span class="o">.</span><span class="n">fitErrorPwlIP</span><span class="p">()</span>
                        <span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;phaseError&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bigSurvey</span><span class="o">.</span><span class="n">phaseErrorModel</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="p">)</span>
                <span class="c1"># if not it means that the &#39;resError&#39; columns has already</span>
                <span class="c1"># been populated when the files has been imported</span>

                <span class="n">res0Bool</span> <span class="o">=</span> <span class="kc">False</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;reg_mode&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="kc">True</span>
                <span class="n">protocol</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">write2protocol</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">err</span><span class="o">=</span><span class="n">err</span><span class="p">,</span> <span class="n">errTot</span><span class="o">=</span><span class="n">errTot</span><span class="p">,</span> <span class="n">res0</span><span class="o">=</span><span class="n">res0Bool</span><span class="p">,</span>
                                            <span class="n">ip</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="c1"># no IP timelapse possible for now</span>
                                            <span class="n">isubset</span><span class="o">=</span><span class="n">indexes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">threed</span><span class="o">=</span><span class="n">threed</span><span class="p">,</span>
                                            <span class="n">fm0</span><span class="o">=</span><span class="n">fm0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">refdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="s1">&#39;ref&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">refdir</span><span class="p">)</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                        <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">refdir</span><span class="p">)</span>
                    <span class="k">if</span> <span class="s1">&#39;mesh.dat&#39;</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">):</span>
                        <span class="n">shutil</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="s1">&#39;mesh.dat&#39;</span><span class="p">),</span>
                                <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="s1">&#39;ref&#39;</span><span class="p">,</span> <span class="s1">&#39;mesh.dat&#39;</span><span class="p">))</span>
                    <span class="k">if</span> <span class="s1">&#39;mesh3d.dat&#39;</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">):</span>
                        <span class="n">shutil</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="s1">&#39;mesh3d.dat&#39;</span><span class="p">),</span>
                                <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="s1">&#39;ref&#39;</span><span class="p">,</span> <span class="s1">&#39;mesh3d.dat&#39;</span><span class="p">))</span>
                    <span class="n">s</span><span class="o">.</span><span class="n">write2protocol</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">refdir</span><span class="p">,</span> <span class="s1">&#39;protocol.dat&#39;</span><span class="p">),</span> <span class="n">err</span><span class="o">=</span><span class="n">err</span><span class="p">,</span> <span class="n">threed</span><span class="o">=</span><span class="n">threed</span><span class="p">)</span> <span class="c1"># no subset for background, just use all</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">content</span> <span class="o">=</span> <span class="n">content</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">protocol</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
                    <span class="n">content</span> <span class="o">=</span> <span class="n">content</span> <span class="o">+</span> <span class="n">protocol</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">line_terminator</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="s1">&#39;protocol.dat&#39;</span><span class="p">),</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">content</span><span class="p">)</span>

        <span class="c1"># for batch inversion -------------------</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">iBatch</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">content</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">):</span>
                <span class="c1"># resError and phaseError should already have been populated</span>
                <span class="c1"># handle the case when SOME survey were fitted but not all</span>
                <span class="c1"># then we use the bigSurvey default fit to fullfill them</span>
                <span class="k">if</span> <span class="n">err</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">errTyp</span> <span class="o">==</span> <span class="s1">&#39;global&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;resError&#39;</span><span class="p">]))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># there is some nan</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Survey </span><span class="si">{:s}</span><span class="s1"> has no fitted error model, default to combined fit.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bigSurvey</span><span class="o">.</span><span class="n">errorModel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">bigSurvey</span><span class="o">.</span><span class="n">fitErrorPwl</span><span class="p">()</span> <span class="c1"># default fit</span>
                        <span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;resError&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bigSurvey</span><span class="o">.</span><span class="n">errorModel</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;c&#39;</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;phaseError&#39;</span><span class="p">]))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># there is some nan</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Survey </span><span class="si">{:s}</span><span class="s1"> has no fitted IP error model, default to combined fit.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bigSurvey</span><span class="o">.</span><span class="n">phaseErrorModel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">bigSurvey</span><span class="o">.</span><span class="n">fitErrorPwlIP</span><span class="p">()</span>
                        <span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;phaseError&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bigSurvey</span><span class="o">.</span><span class="n">phaseErrorModel</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="p">)</span>
                    <span class="c1"># if not it means that the &#39;resError&#39; columns has already</span>
                    <span class="c1"># been populated when the files has been imported</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">write2protocol</span><span class="p">(</span><span class="n">outputname</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">err</span><span class="o">=</span><span class="n">err</span><span class="p">,</span> <span class="n">ip</span><span class="o">=</span><span class="n">ipBool</span><span class="p">,</span> <span class="n">errTot</span><span class="o">=</span><span class="n">errTot</span><span class="p">,</span> <span class="n">threed</span><span class="o">=</span><span class="n">threed</span><span class="p">)</span>
                <span class="n">content</span> <span class="o">=</span> <span class="n">content</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="n">content</span> <span class="o">=</span> <span class="n">content</span> <span class="o">+</span> <span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">line_terminator</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="s1">&#39;protocol.dat&#39;</span><span class="p">),</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">content</span><span class="p">)</span>

        <span class="c1"># for normal inversion (one survey) --------------------------</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">write2protocol</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="s1">&#39;protocol.dat&#39;</span><span class="p">),</span>
                        <span class="n">err</span><span class="o">=</span><span class="n">err</span><span class="p">,</span> <span class="n">ip</span><span class="o">=</span><span class="n">ipBool</span><span class="p">,</span> <span class="n">errTot</span><span class="o">=</span><span class="n">errTot</span><span class="p">,</span> <span class="n">threed</span><span class="o">=</span><span class="n">threed</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">runR2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dirname</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">dump</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Run the executable in charge of the inversion.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dirname : str, optional</span>
<span class="sd">            Path of the directory where to run the inversion code.</span>
<span class="sd">        dump : function, optional</span>
<span class="sd">            Function to print the output of the invrsion code while running.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dump</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                
        <span class="c1"># run R2.exe</span>
        <span class="n">exeName</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">+</span> <span class="s1">&#39;.exe&#39;</span>
        <span class="k">if</span> <span class="n">dirname</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="n">dirname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dirname</span>

        <span class="c1"># get R2.exe path</span>
        <span class="k">with</span> <span class="n">cd</span><span class="p">(</span><span class="n">dirname</span><span class="p">):</span>
            <span class="n">exePath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">apiPath</span><span class="p">,</span> <span class="s1">&#39;exe&#39;</span><span class="p">,</span> <span class="n">exeName</span><span class="p">)</span>
    
            <span class="k">if</span> <span class="n">OS</span> <span class="o">==</span> <span class="s1">&#39;Windows&#39;</span><span class="p">:</span>
                <span class="n">cmd</span> <span class="o">=</span> <span class="p">[</span><span class="n">exePath</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">OS</span> <span class="o">==</span> <span class="s1">&#39;Darwin&#39;</span><span class="p">:</span>
                <span class="n">winetxt</span> <span class="o">=</span> <span class="s1">&#39;wine&#39;</span>
                <span class="k">if</span> <span class="n">getMacOSVersion</span><span class="p">():</span>
                    <span class="n">winetxt</span> <span class="o">=</span> <span class="s1">&#39;wine64&#39;</span>
                <span class="n">winePath</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">wine_path</span> <span class="o">=</span> <span class="n">Popen</span><span class="p">([</span><span class="s1">&#39;which&#39;</span><span class="p">,</span> <span class="n">winetxt</span><span class="p">],</span> <span class="n">stdout</span><span class="o">=</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">shell</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">universal_newlines</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="c1">#.communicate()[0]</span>
                <span class="k">for</span> <span class="n">stdout_line</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="n">wine_path</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">readline</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">):</span>
                    <span class="n">winePath</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stdout_line</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">winePath</span> <span class="o">!=</span> <span class="p">[]:</span>
                    <span class="n">cmd</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">winePath</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)),</span> <span class="n">exePath</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cmd</span> <span class="o">=</span> <span class="p">[</span><span class="n">wPath</span> <span class="o">+</span> <span class="n">winetxt</span><span class="p">,</span> <span class="n">exePath</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cmd</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;wine&#39;</span><span class="p">,</span><span class="n">exePath</span><span class="p">]</span>
    
            <span class="k">if</span> <span class="n">OS</span> <span class="o">==</span> <span class="s1">&#39;Windows&#39;</span><span class="p">:</span>
                <span class="n">startupinfo</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">STARTUPINFO</span><span class="p">()</span>
                <span class="n">startupinfo</span><span class="o">.</span><span class="n">dwFlags</span> <span class="o">|=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">STARTF_USESHOWWINDOW</span>
    
            <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="n">cmd</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">OS</span> <span class="o">==</span> <span class="s1">&#39;Windows&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">proc</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">Popen</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">stdout</span><span class="o">=</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">shell</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">universal_newlines</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">startupinfo</span><span class="o">=</span><span class="n">startupinfo</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">proc</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">Popen</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">stdout</span><span class="o">=</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">shell</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">universal_newlines</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">stdout_line</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proc</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">readline</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">stdout_line</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">proc</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="n">return_code</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proc</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">return_code</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;error on return_code&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">text</span> <span class="ow">in</span> <span class="n">execute</span><span class="p">(</span><span class="n">cmd</span><span class="p">):</span>
                <span class="n">dump</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">runParallel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dirname</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dump</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">iMoveElec</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">ncores</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rmDirTree</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Run several instances of R2 in parallel according to the number of</span>
<span class="sd">        cores available.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dirname : str, optional</span>
<span class="sd">            Path of the working directory.</span>
<span class="sd">        dump : function, optional</span>
<span class="sd">            Function to be passed to `R2.runR2()` for printing output during</span>
<span class="sd">            inversion.</span>
<span class="sd">        iMoveElec : bool, optional</span>
<span class="sd">            If `True` will move electrodes according to their position in each</span>
<span class="sd">            `Survey` object.</span>
<span class="sd">        ncores : int, optional</span>
<span class="sd">            Number or cores to use. If None, the maximum number of cores</span>
<span class="sd">            available will be used.</span>
<span class="sd">        rmDirTree: bool, optional</span>
<span class="sd">            Remove excess directories and files created during parallel.</span>
<span class="sd">            Default is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dirname</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dirname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dirname</span>
            
        <span class="k">if</span> <span class="n">dump</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iTimeLapse</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">iBatch</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">surveys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">surveys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span>

        <span class="c1"># create R2.exe path</span>
        <span class="n">exeName</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">+</span> <span class="s1">&#39;.exe&#39;</span>
        <span class="n">exePath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">apiPath</span><span class="p">,</span> <span class="s1">&#39;exe&#39;</span><span class="p">,</span> <span class="n">exeName</span><span class="p">)</span>


        <span class="c1"># split the protocol.dat</span>
        <span class="c1"># in pandas &gt;= 1.4.0 header=None with first row with one column (nb of meas)</span>
        <span class="c1"># causes ParseError. to fix it we first read the number of rows from line 2</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="s1">&#39;protocol.dat&#39;</span><span class="p">),</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>  <span class="c1"># first wow, we don&#39;t care</span>
            <span class="n">nline</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">))</span>
        <span class="n">dfall</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="s1">&#39;protocol.dat&#39;</span><span class="p">),</span>
                            <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nline</span><span class="p">))</span>
        
        <span class="c1"># the line where the last column is NaN is a line where a new dataset start</span>
        <span class="n">idf</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dfall</span><span class="p">[</span><span class="n">dfall</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="p">))[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">idf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dfall</span><span class="p">))</span>
        <span class="n">dfs</span> <span class="o">=</span> <span class="p">[</span><span class="n">dfall</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">idf</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">idf</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,:]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">idf</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>

        <span class="c1"># writing all protocol.dat</span>
        <span class="n">files</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">df</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">surveys</span><span class="p">,</span> <span class="n">dfs</span><span class="p">):</span>
            <span class="n">outputname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirname</span><span class="p">,</span> <span class="s1">&#39;protocol_&#39;</span> <span class="o">+</span> <span class="n">s</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;.dat&#39;</span><span class="p">)</span>
            <span class="n">files</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">outputname</span><span class="p">)</span>
            <span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">outputname</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">line_terminator</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="c1"># header with line count already included</span>

        <span class="c1"># if iMoveElec is True, writing different R2.in</span>
        <span class="k">if</span> <span class="n">iMoveElec</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">dump</span><span class="p">(</span><span class="s1">&#39;Electrodes position will be updated for each survey</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">:</span>
                <span class="c1"># print(s.name, &#39;...&#39;, end=&#39;&#39;)</span>
                <span class="n">elec</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">elec</span><span class="p">[[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="s1">&#39;z&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
                <span class="n">e_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">moveElecNodes</span><span class="p">(</span><span class="n">elec</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">elec</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">elec</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;node_elec&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">e_nodes</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1"># WE MUST ADD ONE due indexing differences between python and fortran</span>
                <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">cell_type</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">==</span><span class="mi">8</span> <span class="ow">or</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">cell_type</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">==</span><span class="mi">9</span><span class="p">:</span><span class="c1">#elements are quads</span>
                    <span class="n">colx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">quadMeshNp</span><span class="p">()</span> <span class="c1"># so find x column indexes instead. Wont support change in electrode elevation</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;node_elec&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">colx</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;inverse_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># regularise against a background model</span>
                <span class="c1">#self.param[&#39;reg_mode&#39;] = 1</span>
                <span class="n">write2in</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">)</span>
                <span class="n">r2file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">+</span> <span class="s1">&#39;.in&#39;</span><span class="p">)</span>
                <span class="n">shutil</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">r2file</span><span class="p">,</span> <span class="n">r2file</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.in&#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">s</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;.in&#39;</span><span class="p">))</span>
                <span class="c1"># print(&#39;done&#39;)</span>

        <span class="c1"># create workers directory</span>
        <span class="n">ncoresAvailable</span> <span class="o">=</span> <span class="n">sysinfo</span><span class="p">[</span><span class="s1">&#39;cpuCount&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">ncores</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># and self.ncores is None:</span>
            <span class="n">ncores</span> <span class="o">=</span> <span class="n">sysinfo</span><span class="p">[</span><span class="s1">&#39;physicalCpuCount&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ncores</span> <span class="o">&gt;</span> <span class="n">ncoresAvailable</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Number of cores larger than available&#39;</span><span class="p">)</span>
        <span class="n">dump</span><span class="p">(</span><span class="s1">&#39;Using </span><span class="si">%i</span><span class="s1"> logical processors&#39;</span><span class="o">%</span><span class="n">ncores</span><span class="p">)</span>


        <span class="k">def</span> <span class="nf">prepare</span><span class="p">(</span><span class="n">wd</span><span class="p">,</span> <span class="n">fname</span><span class="p">):</span>
            <span class="c1"># copying usefull files from the main directory</span>
            <span class="n">toMove</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;mesh.dat&#39;</span><span class="p">,</span> <span class="s1">&#39;mesh3d.dat&#39;</span><span class="p">,</span><span class="s1">&#39;R2.in&#39;</span><span class="p">,</span><span class="s1">&#39;cR2.in&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;R3t.in&#39;</span><span class="p">,</span> <span class="s1">&#39;cR3t.in&#39;</span><span class="p">,</span> <span class="s1">&#39;res0.dat&#39;</span><span class="p">,</span><span class="s1">&#39;resistivity.dat&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;Start_res.dat&#39;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">toMove</span><span class="p">:</span>
                <span class="n">file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirname</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">file</span><span class="p">):</span>
                    <span class="n">shutil</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">wd</span><span class="p">,</span> <span class="n">f</span><span class="p">))</span>

            <span class="c1"># copy the protocol.dat</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">wd</span><span class="p">,</span> <span class="s1">&#39;protocol.dat&#39;</span><span class="p">))</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.dat&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;protocol_&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">iMoveElec</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">r2inFile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">fname</span><span class="p">),</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;.in&#39;</span><span class="p">)</span>
                <span class="n">shutil</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">r2inFile</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">wd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">+</span> <span class="s1">&#39;.in&#39;</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">OS</span> <span class="o">==</span> <span class="s1">&#39;Windows&#39;</span><span class="p">:</span>
            <span class="n">cmd</span> <span class="o">=</span> <span class="p">[</span><span class="n">exePath</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">OS</span> <span class="o">==</span> <span class="s1">&#39;Darwin&#39;</span><span class="p">:</span>
            <span class="n">winetxt</span> <span class="o">=</span> <span class="s1">&#39;wine&#39;</span>
            <span class="k">if</span> <span class="n">getMacOSVersion</span><span class="p">():</span>
                <span class="n">winetxt</span> <span class="o">=</span> <span class="s1">&#39;wine64&#39;</span>
            <span class="n">winePath</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">wine_path</span> <span class="o">=</span> <span class="n">Popen</span><span class="p">([</span><span class="s1">&#39;which&#39;</span><span class="p">,</span> <span class="n">winetxt</span><span class="p">],</span> <span class="n">stdout</span><span class="o">=</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">shell</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">universal_newlines</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="c1">#.communicate()[0]</span>
            <span class="k">for</span> <span class="n">stdout_line</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="n">wine_path</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">readline</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">):</span>
                <span class="n">winePath</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stdout_line</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">winePath</span> <span class="o">!=</span> <span class="p">[]:</span>
                <span class="n">cmd</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">winePath</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)),</span> <span class="n">exePath</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cmd</span> <span class="o">=</span> <span class="p">[</span><span class="n">wPath</span> <span class="o">+</span> <span class="n">winetxt</span><span class="p">,</span> <span class="n">exePath</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cmd</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;wine&#39;</span><span class="p">,</span><span class="n">exePath</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">OS</span> <span class="o">==</span> <span class="s1">&#39;Windows&#39;</span><span class="p">:</span>
            <span class="n">startupinfo</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">STARTUPINFO</span><span class="p">()</span>
            <span class="n">startupinfo</span><span class="o">.</span><span class="n">dwFlags</span> <span class="o">|=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">STARTF_USESHOWWINDOW</span>

        <span class="k">def</span> <span class="nf">retrieve</span><span class="p">(</span><span class="n">wd</span><span class="p">,</span> <span class="n">fname</span><span class="p">):</span>
            <span class="c1"># moving inversion results back</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.dat&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;protocol_&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="n">originalDir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dirname</span>
            <span class="n">toMove</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;f001_res.dat&#39;</span><span class="p">,</span> <span class="s1">&#39;f001_res.vtk&#39;</span><span class="p">,</span> <span class="s1">&#39;f001_err.dat&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;f001_sen.dat&#39;</span><span class="p">,</span> <span class="s1">&#39;f001_diffres.dat&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;f001.dat&#39;</span><span class="p">,</span> <span class="s1">&#39;f001.sen&#39;</span><span class="p">,</span> <span class="s1">&#39;f001.err&#39;</span><span class="p">,</span> <span class="s1">&#39;f001.vtk&#39;</span><span class="p">]</span> <span class="c1"># all 3D stuff</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">toMove</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">wd</span><span class="p">,</span> <span class="n">f</span><span class="p">)):</span>
                    <span class="n">shutil</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">wd</span><span class="p">,</span> <span class="n">f</span><span class="p">),</span>
                                <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">originalDir</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;f001&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">)))</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">wd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">+</span> <span class="s1">&#39;.out&#39;</span><span class="p">),</span>
                        <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">originalDir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;.out&#39;</span><span class="p">))</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">wd</span><span class="p">,</span> <span class="s1">&#39;electrodes.dat&#39;</span><span class="p">),</span>
                        <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">originalDir</span><span class="p">,</span> <span class="s1">&#39;electrodes_&#39;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;.dat&#39;</span><span class="p">))</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">wd</span><span class="p">,</span> <span class="s1">&#39;electrodes.vtk&#39;</span><span class="p">),</span>
                        <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">originalDir</span><span class="p">,</span> <span class="s1">&#39;electrodes_&#39;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;.vtk&#39;</span><span class="p">))</span>

        <span class="c1"># create all the working directories</span>
        <span class="n">wds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">files</span><span class="p">):</span>
            <span class="n">wd</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">wd</span><span class="p">):</span>
                <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">wd</span><span class="p">)</span>
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">wd</span><span class="p">)</span>
            <span class="n">prepare</span><span class="p">(</span><span class="n">wd</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
            <span class="n">wds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wd</span><span class="p">)</span>
        <span class="n">wds2</span> <span class="o">=</span> <span class="n">wds</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># run them all in parallel as child processes</span>
        <span class="k">def</span> <span class="nf">dumpOutput</span><span class="p">(</span><span class="n">out</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">readline</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">):</span>
                <span class="n">dump</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="c1"># create essential attribute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irunParallel2</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">procs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># kill management</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proc</span> <span class="o">=</span> <span class="n">ProcsManagement</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># run in // (http://code.activestate.com/recipes/577376-simple-way-to-execute-multiple-process-in-parallel/)</span>
        <span class="c1"># In an infinite loop, will run an number of process (according to the number of cores)</span>
        <span class="c1"># the loop will check when they finish and start new ones.</span>
        <span class="k">def</span> <span class="nf">done</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="n">poll</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">dump</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\r</span><span class="si">{:.0f}</span><span class="s1">/</span><span class="si">{:.0f}</span><span class="s1"> inversions completed&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">wds2</span><span class="p">)))</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">irunParallel2</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">wds</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">procs</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">ncores</span><span class="p">:</span>
                <span class="n">wd</span> <span class="o">=</span> <span class="n">wds</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="c1">#print(&#39;------task&#39;, wd)</span>
                <span class="k">if</span> <span class="n">OS</span> <span class="o">==</span> <span class="s1">&#39;Windows&#39;</span><span class="p">:</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">Popen</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">cwd</span><span class="o">=</span><span class="n">wd</span><span class="p">,</span> <span class="n">shell</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">universal_newlines</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">startupinfo</span><span class="o">=</span><span class="n">startupinfo</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">Popen</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">cwd</span><span class="o">=</span><span class="n">wd</span><span class="p">,</span> <span class="n">shell</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">universal_newlines</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">procs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="c1">#                t = Thread(target=dumpOutput, args=(p.stdout,))</span>
<span class="c1">#                t.daemon = True # thread dies with the program</span>
<span class="c1">#                t.start()</span>
<span class="c1">#                ts.append(t)</span>

            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">procs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">done</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
                    <span class="c1">#print(&#39;------done!!&#39;, p)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">procs</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">+</span><span class="mi">1</span>
                    <span class="c1"># TODO get RMS and iteration number here ?</span>
                    <span class="n">dump</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\r</span><span class="si">{:.0f}</span><span class="s1">/</span><span class="si">{:.0f}</span><span class="s1"> inversions completed&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">wds2</span><span class="p">)))</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">procs</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">wds</span><span class="p">:</span>
                <span class="n">dump</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.05</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">wd</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">wds2</span><span class="p">,</span> <span class="n">files</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">retrieve</span><span class="p">(</span><span class="n">wd</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error retrieving for &#39;</span><span class="p">,</span> <span class="n">wd</span><span class="p">,</span> <span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
                <span class="k">pass</span>


        <span class="c1"># get the files as it was a sequential inversion</span>
        <span class="c1"># TODO should now be consistent</span>
        <span class="c1"># if self.typ==&#39;R3t&#39; or self.typ==&#39;cR3t&#39;:</span>
            <span class="c1"># toRename = [&#39;.dat&#39;, &#39;.vtk&#39;, &#39;.err&#39;, &#39;.sen&#39;, &#39;_diffres.dat&#39;]</span>
        <span class="c1"># else:</span>
        <span class="n">toRename</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;_res.dat&#39;</span><span class="p">,</span> <span class="s1">&#39;_res.vtk&#39;</span><span class="p">,</span> <span class="s1">&#39;_err.dat&#39;</span><span class="p">,</span> <span class="s1">&#39;_sen.dat&#39;</span><span class="p">,</span> <span class="s1">&#39;_diffres.dat&#39;</span><span class="p">]</span>
        <span class="n">r2outText</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">surveys</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">ext</span> <span class="ow">in</span> <span class="n">toRename</span><span class="p">:</span>
                <span class="n">originalFile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirname</span><span class="p">,</span>  <span class="n">s</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="n">ext</span><span class="p">)</span>
                <span class="n">newFile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirname</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="n">ext</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">originalFile</span><span class="p">):</span>
                    <span class="n">shutil</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">originalFile</span><span class="p">,</span> <span class="n">newFile</span><span class="p">)</span>
            <span class="n">r2outFile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">s</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;.out&#39;</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">r2outFile</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">r2outText</span> <span class="o">=</span> <span class="n">r2outText</span> <span class="o">+</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">r2outFile</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">+</span> <span class="s1">&#39;.out&#39;</span><span class="p">),</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">r2outText</span><span class="p">)</span>
        
        <span class="c1"># remove electrodes files if iMoveElec is False</span>
        <span class="k">if</span> <span class="n">iMoveElec</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">surveys</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirname</span><span class="p">,</span> <span class="s1">&#39;electrodes_&#39;</span> <span class="o">+</span> <span class="n">s</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;.vtk&#39;</span><span class="p">))</span>
                <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirname</span><span class="p">,</span> <span class="s1">&#39;electrodes_&#39;</span> <span class="o">+</span> <span class="n">s</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;.dat&#39;</span><span class="p">))</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirname</span><span class="p">,</span> <span class="s1">&#39;electrodes_&#39;</span> <span class="o">+</span> <span class="n">surveys</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;.vtk&#39;</span><span class="p">),</span>
                        <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirname</span><span class="p">,</span> <span class="s1">&#39;electrodes.vtk&#39;</span><span class="p">))</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirname</span><span class="p">,</span> <span class="s1">&#39;electrodes_&#39;</span> <span class="o">+</span> <span class="n">surveys</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;.dat&#39;</span><span class="p">),</span>
                        <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirname</span><span class="p">,</span> <span class="s1">&#39;electrodes.dat&#39;</span><span class="p">))</span>      

        <span class="c1"># delete the dirs and the files</span>
        <span class="k">if</span> <span class="n">rmDirTree</span><span class="p">:</span>
            <span class="p">[</span><span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">wds2</span><span class="p">]</span>
            <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">files</span><span class="p">]</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;----------- END OF INVERSION IN // ----------&#39;</span><span class="p">)</span>



    <span class="k">def</span> <span class="nf">invert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="o">=</span><span class="p">{},</span> <span class="n">iplot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dump</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">modErr</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">iMoveElec</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ncores</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">rmDirTree</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">modelDOI</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Invert the data, first generate R2.in file, then run</span>
<span class="sd">        inversion using appropriate wrapper, then return results.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        param : dict, optional</span>
<span class="sd">            Dictionary of parameters for inversion. Will be passed to</span>
<span class="sd">            `R2.write2in()`.</span>
<span class="sd">        iplot : bool, optional</span>
<span class="sd">            If `True`, will plot the results of the inversion using</span>
<span class="sd">            `R2.showResults()`.</span>
<span class="sd">        dump : function, optinal</span>
<span class="sd">            Function to print the output of the inversion. To be passed to</span>
<span class="sd">            `R2.runR2()`.</span>
<span class="sd">        modErr : bool, optional</span>
<span class="sd">            If `True`, the model error will be compute and added before</span>
<span class="sd">            inversion.</span>
<span class="sd">        parallel : bool, optional</span>
<span class="sd">            If `True`, batch and time-lapse survey will be inverted in //. No</span>
<span class="sd">            output will be display during inversion.</span>
<span class="sd">        iMoveElec : bool, optional</span>
<span class="sd">            If `True`, then different electrode location will be used for</span>
<span class="sd">            the different surveys. Electrodes location are specified in the</span>
<span class="sd">            `Survey` object. Only for parallel inversion for now.</span>
<span class="sd">        ncores : int, optional</span>
<span class="sd">            If `parallel==True` then ncores is the number of cores to use (by</span>
<span class="sd">            default all the cores available are used).</span>
<span class="sd">        rmDirTree : bool, optional</span>
<span class="sd">            Remove excess directories and files created during parallel inversion</span>
<span class="sd">        modelDOI : bool, optional</span>
<span class="sd">            If `True`, the Depth of Investigation will be model by reinverting</span>
<span class="sd">            the data on with an initial res0 different of an order of magnitude.</span>
<span class="sd">            Note that this option is only available for *single* survey.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dump</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                
        <span class="c1"># clean meshResults list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meshResults</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="c1"># create mesh if not already done</span>
        <span class="k">if</span> <span class="s1">&#39;mesh&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">createMesh</span><span class="p">()</span>
            
        <span class="c1"># clean previous iterations</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">f</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;f00&#39;</span><span class="p">:</span>
                <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="n">f</span><span class="p">))</span>
            
        <span class="c1"># run Oldenburg and Li DOI estimation</span>
        <span class="k">if</span> <span class="n">modelDOI</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">sensScaled</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">modelDOI</span><span class="p">(</span><span class="n">dump</span><span class="o">=</span><span class="n">dump</span><span class="p">)</span>

        <span class="c1"># compute modelling error if selected</span>
        <span class="k">if</span> <span class="n">modErr</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">fwdErrModel</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span> <span class="c1">#check no error model exists</span>
            <span class="n">dump</span><span class="p">(</span><span class="s1">&#39;Computing error model... &#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">computeModelError</span><span class="p">()</span>
            <span class="n">dump</span><span class="p">(</span><span class="s1">&#39;done</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">errTot</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">modErr</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">fwdErrModel</span><span class="p">:</span>
            <span class="c1"># avoid computing error model again if it has already been run.</span>
            <span class="n">errTot</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">errTot</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># write configuration file</span>
        <span class="n">dump</span><span class="p">(</span><span class="s1">&#39;Writing .in file and protocol.dat... &#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write2in</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="n">param</span><span class="p">)</span> <span class="c1"># R2.in</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write2protocol</span><span class="p">(</span><span class="n">errTot</span><span class="o">=</span><span class="n">errTot</span><span class="p">)</span> <span class="c1"># protocol.dat</span>
        <span class="n">dump</span><span class="p">(</span><span class="s1">&#39;done</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="c1"># runs inversion</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iTimeLapse</span> <span class="o">==</span> <span class="kc">True</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">referenceMdl</span><span class="o">==</span><span class="kc">False</span><span class="p">:</span>
            <span class="n">dump</span><span class="p">(</span><span class="s1">&#39;------------ INVERTING REFERENCE SURVEY ---------------</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">refdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="s1">&#39;ref&#39;</span><span class="p">)</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span><span class="s1">&#39;res0.dat&#39;</span><span class="p">),</span>
                        <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">refdir</span><span class="p">,</span> <span class="s1">&#39;res0.dat&#39;</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write2in</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="n">param</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">runR2</span><span class="p">(</span><span class="n">refdir</span><span class="p">,</span> <span class="n">dump</span><span class="o">=</span><span class="n">dump</span><span class="p">)</span> <span class="c1"># this line actually runs R2</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">refdir</span><span class="p">,</span> <span class="s1">&#39;f001_res.dat&#39;</span><span class="p">),</span>
                        <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="s1">&#39;Start_res.dat&#39;</span><span class="p">))</span>
            <span class="k">if</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;R3t&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;cR3t&#39;</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;reg_mode&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
                <span class="n">dump</span><span class="p">(</span><span class="s1">&#39;----------------- Computing d-d0+f(m0) ---------------</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="c1"># as per v3.2 of R3t we need to compute MANUALLY d-d0+f(m0)</span>
                <span class="c1"># this is done automatically in R2 and cR2</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sequence</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">df</span><span class="p">[[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;m&#39;</span><span class="p">,</span><span class="s1">&#39;n&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
                <span class="n">surveysBackup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">res0Backup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;res0&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">iForwardBackup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iForward</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">forward</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">iForward</span> <span class="o">=</span> <span class="n">iForwardBackup</span>
                <span class="n">fm0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;resist&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sequence</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span> <span class="o">=</span> <span class="n">surveysBackup</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">write2protocol</span><span class="p">(</span><span class="n">errTot</span><span class="o">=</span><span class="n">errTot</span><span class="p">,</span> <span class="n">fm0</span><span class="o">=</span><span class="n">fm0</span><span class="p">)</span> <span class="c1"># rewrite them with d-d0+f(m0)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">iTimeLapse</span> <span class="o">==</span> <span class="kc">True</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">referenceMdl</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Note: Skipping reference inversion, as reference model has already been assigned&#39;</span><span class="p">)</span>

        <span class="n">dump</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">--------------------- MAIN INVERSION ------------------</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">parallel</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iTimeLapse</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">iBatch</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">runParallel</span><span class="p">(</span><span class="n">dump</span><span class="o">=</span><span class="n">dump</span><span class="p">,</span> <span class="n">iMoveElec</span><span class="o">=</span><span class="n">iMoveElec</span><span class="p">,</span> <span class="n">ncores</span><span class="o">=</span><span class="n">ncores</span><span class="p">,</span> <span class="n">rmDirTree</span><span class="o">=</span><span class="n">rmDirTree</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">runR2</span><span class="p">(</span><span class="n">dump</span><span class="o">=</span><span class="n">dump</span><span class="p">)</span>
            
        <span class="c1"># extract inversion errors</span>
        <span class="k">try</span><span class="p">:</span> <span class="c1"># this is in the case getInvError() is called after the file .err is</span>
            <span class="c1"># created by R2 but before it is populated (when killing the run)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getInvError</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getResults</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">modelDOI</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshResults</span><span class="p">:</span>
                    <span class="n">m</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;doiSens&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sensScaled</span>
            
            <span class="c1"># read final R2.out</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">+</span> <span class="s1">&#39;.out&#39;</span><span class="p">),</span><span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">invLog</span> <span class="o">+=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
                
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Could not retrieve files maybe inversion failed&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error: &#39;</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">iplot</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iForward</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">showResults</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">showResults</span><span class="p">()</span>
                
                


    <span class="k">def</span> <span class="nf">modelDOI</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dump</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Will rerun the inversion with a background constrain (alpha_s) with</span>
<span class="sd">        the normal background and then a background 10 times more resistive.</span>
<span class="sd">        From the two different inversion a senstivity limit will be computed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dump</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                
        <span class="c1"># backup for normal inversion (0 : original, 1 : normal background, 2: background *10)</span>
        <span class="n">res0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;res0&#39;</span><span class="p">])</span>
        <span class="n">param0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;reg_mode&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># we need constrain to background</span>
        <span class="n">typ0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">iTimeLapse0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iTimeLapse</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iTimeLapse</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">surveys0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span> <span class="o">=</span> <span class="p">[</span><span class="n">surveys0</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="c1"># just use first survey</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write2in</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write2protocol</span><span class="p">()</span>
        
        <span class="c1"># build the cropping polygon</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;num_xz_poly&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;xz_poly_table&#39;</span><span class="p">])</span>
            <span class="n">iselect</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">contains_points</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">elmCentre</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">elmCentre</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">iselect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">elmCentre</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            
        <span class="c1"># clean function</span>
        <span class="k">def</span> <span class="nf">cleandir</span><span class="p">():</span>
            <span class="n">dirname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dirname</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirname</span><span class="p">,</span> <span class="s1">&#39;res0.dat&#39;</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">dirname</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">f</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;f00&#39;</span><span class="p">:</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirname</span><span class="p">,</span> <span class="n">f</span><span class="p">))</span>
        
        <span class="c1"># run first background constrained inversion</span>
        <span class="n">dump</span><span class="p">(</span><span class="s1">&#39;===== modelDOI: Running background constrained inversion with initial resistivity =====</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">res1</span> <span class="o">=</span> <span class="n">res0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;res0b&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">res1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">writeAttr</span><span class="p">(</span><span class="s1">&#39;res0b&#39;</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span><span class="s1">&#39;res0.dat&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">runR2</span><span class="p">(</span><span class="n">dump</span><span class="o">=</span><span class="n">dump</span><span class="p">)</span> <span class="c1"># re-run inversion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">getResults</span><span class="p">()</span>
        <span class="n">mesh1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshResults</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">cleandir</span><span class="p">()</span>
        
        <span class="c1"># run second background constrained inversion</span>
        <span class="n">dump</span><span class="p">(</span><span class="s1">&#39;===== modelDOI: Running background constrained inversion with initial resistivity * 10 =====</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">res2</span> <span class="o">=</span> <span class="n">res0</span> <span class="o">*</span> <span class="mi">10</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;res0b&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">res2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">writeAttr</span><span class="p">(</span><span class="s1">&#39;res0b&#39;</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span><span class="s1">&#39;res0.dat&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">runR2</span><span class="p">(</span><span class="n">dump</span><span class="o">=</span><span class="n">dump</span><span class="p">)</span> <span class="c1"># re-run inversion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">getResults</span><span class="p">()</span>
        <span class="n">mesh2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshResults</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">cleandir</span><span class="p">()</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="s1">&#39;R2.in&#39;</span><span class="p">))</span>
        
        <span class="c1"># sensitivity = difference between final inversion / difference init values</span>
        <span class="n">res_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;Resistivity&#39;</span><span class="p">,</span><span class="s1">&#39;Resistivity(Ohm-m)&#39;</span><span class="p">,</span><span class="s1">&#39;Resistivity(ohm.m)&#39;</span><span class="p">])</span>
        <span class="n">res_name</span> <span class="o">=</span> <span class="n">res_names</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">res_names</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meshResults</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">keys</span><span class="p">()))][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">invValues1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mesh1</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="n">res_name</span><span class="p">])</span>
        <span class="n">invValues2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mesh2</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="n">res_name</span><span class="p">])</span>
        <span class="n">sens</span> <span class="o">=</span> <span class="p">(</span><span class="n">invValues1</span> <span class="o">-</span> <span class="n">invValues2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">res1</span><span class="p">[</span><span class="n">iselect</span><span class="p">]</span><span class="o">-</span><span class="n">res2</span><span class="p">[</span><span class="n">iselect</span><span class="p">])</span>
        <span class="n">sensScaled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sens</span><span class="p">)</span>
<span class="c1">#        mesh0.df[&#39;doiSens&#39;] = sensScaled # add attribute to original mesh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">doiComputed</span> <span class="o">=</span> <span class="kc">True</span>
        
        <span class="c1"># restore</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meshResults</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param</span> <span class="o">=</span> <span class="n">param0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">=</span> <span class="n">typ0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span> <span class="o">=</span> <span class="n">surveys0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iTimeLapse</span> <span class="o">=</span> <span class="n">iTimeLapse0</span>
        <span class="c1"># .in and protocol will be written again in R2.invert()</span>
        
        <span class="k">return</span> <span class="n">sensScaled</span>
        
    <span class="k">def</span> <span class="nf">_clipContour</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">collections</span><span class="p">,</span> <span class="n">cropMaxDepth</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">clipCorners</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Clip contours using mesh bound and surface if available.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ax : matplotlib.Axes</span>
<span class="sd">            Axis.</span>
<span class="sd">        collections : matplotlib.collections</span>
<span class="sd">            Matplotlib collection.</span>
<span class="sd">        cropMaxDepth : bool, optional</span>
<span class="sd">            If &#39;True&#39;, area below fmd will be cropped out.</span>
<span class="sd">        clipCorners : bool, optional</span>
<span class="sd">            If &#39;True&#39;, triangles from bottom corners will be cropped (only if the whole mesh is not shown).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">def</span> <span class="nf">patcher</span><span class="p">(</span><span class="n">verts</span><span class="p">):</span>
            <span class="c1"># cliping using a patch (https://stackoverflow.com/questions/25688573/matplotlib-set-clip-path-requires-patch-to-be-plotted)</span>
            <span class="n">poly_codes</span> <span class="o">=</span> <span class="p">[</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="o">.</span><span class="n">MOVETO</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">verts</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="o">.</span><span class="n">LINETO</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="o">.</span><span class="n">CLOSEPOLY</span><span class="p">]</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="n">poly_codes</span><span class="p">)</span>
            <span class="n">patch</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">PathPatch</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">patch</span><span class="p">)</span> <span class="c1"># need to add so it knows the transform</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">collections</span><span class="p">:</span>
                <span class="n">col</span><span class="o">.</span><span class="n">set_clip_path</span><span class="p">(</span><span class="n">patch</span><span class="p">)</span>
        
        <span class="c1"># mask outer region</span>
        <span class="n">node_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">node</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">node_z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">node</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">xmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">node_x</span><span class="p">)</span>
        <span class="n">xmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">node_x</span><span class="p">)</span>
        <span class="n">zmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">node_z</span><span class="p">)</span>
        <span class="n">zmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">node_z</span><span class="p">)</span>
        
        <span class="p">(</span><span class="n">xsurf</span><span class="p">,</span> <span class="n">zsurf</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">extractSurface</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">cropMaxDepth</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">fmd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">xfmd</span><span class="p">,</span> <span class="n">zfmd</span> <span class="o">=</span> <span class="n">xsurf</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">zsurf</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">fmd</span>
            <span class="n">verts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xsurf</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">xfmd</span><span class="p">,</span> <span class="n">xmin</span><span class="p">],</span>
                          <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">zmin</span><span class="p">,</span> <span class="n">zmax</span><span class="p">,</span> <span class="n">zsurf</span><span class="p">,</span> <span class="n">zmax</span><span class="p">,</span> <span class="n">zmin</span><span class="p">,</span> <span class="n">zfmd</span><span class="p">,</span> <span class="n">zmin</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">verts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xsurf</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">xmin</span><span class="p">],</span>
                          <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">zmin</span><span class="p">,</span> <span class="n">zmax</span><span class="p">,</span> <span class="n">zsurf</span><span class="p">,</span> <span class="n">zmax</span><span class="p">,</span> <span class="n">zmin</span><span class="p">,</span> <span class="n">zmin</span><span class="p">]]</span>
        <span class="n">patcher</span><span class="p">(</span><span class="n">verts</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">clipCorners</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;num_xz_poly&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># not clipping the corners of a mesh outside of the survey area!</span>
            <span class="n">elec_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">elec</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">elec_z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">elec</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">elec_xmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">elec_x</span><span class="p">)</span>
            <span class="n">elec_xmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">elec_x</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cropMaxDepth</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">fmd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">zminl</span> <span class="o">=</span> <span class="n">elec_z</span><span class="p">[</span><span class="n">elec_x</span><span class="o">.</span><span class="n">argmin</span><span class="p">()]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">fmd</span>
                <span class="n">zminr</span> <span class="o">=</span> <span class="n">elec_z</span><span class="p">[</span><span class="n">elec_x</span><span class="o">.</span><span class="n">argmax</span><span class="p">()]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">fmd</span>
            <span class="k">elif</span> <span class="n">cropMaxDepth</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">fmd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">zminl</span> <span class="o">=</span> <span class="n">zminr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">elec_z</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">fmd</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">zminl</span> <span class="o">=</span> <span class="n">zminr</span> <span class="o">=</span> <span class="n">zmin</span>
            <span class="n">zmaxl</span> <span class="o">=</span> <span class="n">elec_z</span><span class="p">[</span><span class="n">elec_x</span><span class="o">.</span><span class="n">argmin</span><span class="p">()]</span>
            <span class="n">zmaxr</span> <span class="o">=</span> <span class="n">elec_z</span><span class="p">[</span><span class="n">elec_x</span><span class="o">.</span><span class="n">argmax</span><span class="p">()]</span>
            <span class="n">ll</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">zmaxl</span> <span class="o">-</span> <span class="n">zminl</span><span class="p">)</span>
            <span class="n">lr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">zmaxr</span> <span class="o">-</span> <span class="n">zminr</span><span class="p">)</span>
            <span class="n">lx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">elec_xmin</span> <span class="o">-</span> <span class="n">elec_xmax</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ll</span> <span class="o">&gt;=</span> <span class="n">lx</span><span class="o">/</span><span class="mi">4</span><span class="p">:</span>
                <span class="n">ll</span> <span class="o">=</span> <span class="n">lx</span><span class="o">/</span><span class="mi">4</span>
            <span class="k">if</span> <span class="n">lr</span> <span class="o">&gt;=</span> <span class="n">lx</span><span class="o">/</span><span class="mi">4</span><span class="p">:</span>
                <span class="n">lr</span> <span class="o">=</span> <span class="n">lx</span><span class="o">/</span><span class="mi">4</span>

            <span class="c1"># surf bound to elecs</span>
            <span class="n">elec_surf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">xsurf</span><span class="p">,</span> <span class="n">zsurf</span><span class="p">][(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">xsurf</span> <span class="o">-</span> <span class="n">elec_xmin</span><span class="p">))</span><span class="o">.</span><span class="n">argmin</span><span class="p">():</span>
                                            <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">xsurf</span> <span class="o">-</span> <span class="n">elec_xmax</span><span class="p">))</span><span class="o">.</span><span class="n">argmin</span><span class="p">(),:]</span>
            <span class="n">idxl</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">elec_surf</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">ll</span><span class="p">))</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
            <span class="n">idxr</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">elec_surf</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">elec_xmax</span> <span class="o">-</span> <span class="n">lr</span><span class="p">)))</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>       
            <span class="n">xtrapbot</span> <span class="o">=</span> <span class="n">elec_surf</span><span class="p">[</span><span class="n">idxl</span><span class="p">:</span><span class="n">idxr</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">cropMaxDepth</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">fmd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ztrapbot</span> <span class="o">=</span> <span class="n">elec_surf</span><span class="p">[</span><span class="n">idxl</span><span class="p">:</span><span class="n">idxr</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">fmd</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ztrapbot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">xtrapbot</span><span class="p">)</span> <span class="o">*</span> <span class="n">zminl</span>
                
            <span class="bp">self</span><span class="o">.</span><span class="n">trapeziod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">elec_xmin</span><span class="p">,</span> <span class="n">xsurf</span><span class="p">,</span> <span class="n">elec_xmax</span><span class="p">,</span> <span class="n">xtrapbot</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">elec_xmin</span><span class="p">],</span>
                                   <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">zmaxl</span><span class="p">,</span> <span class="n">zsurf</span><span class="p">,</span> <span class="n">zmaxr</span><span class="p">,</span> <span class="n">ztrapbot</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">zmaxl</span><span class="p">]]</span>
            <span class="n">patcher</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trapeziod</span><span class="p">)</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trapeziod</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># make sure trapeziod mask is clear</span>
     

    <span class="k">def</span> <span class="nf">showResults</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">edge_color</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">attr</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
                    <span class="n">sens</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">color_map</span><span class="o">=</span><span class="s1">&#39;viridis&#39;</span><span class="p">,</span> <span class="n">zlim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">clabel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">doi</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">doiSens</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">contour</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cropMaxDepth</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">clipContour</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">clipCorners</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">use_pyvista</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">background_color</span><span class="o">=</span><span class="p">(</span><span class="mf">0.8</span><span class="p">,</span><span class="mf">0.8</span><span class="p">,</span><span class="mf">0.8</span><span class="p">),</span>
                    <span class="n">pvslices</span><span class="o">=</span><span class="p">([],[],[]),</span> <span class="n">pvspline</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pvthreshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pvgrid</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">pvcontour</span><span class="o">=</span><span class="p">[],</span> <span class="n">pvdelaunay3d</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Show the inverteds section.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int, optional</span>
<span class="sd">            Index of the inverted section (mainly in the case of time-lapse</span>
<span class="sd">            inversion). If index == -1, then all 2D survey will be plotted</span>
<span class="sd">            on a 3D grid.</span>
<span class="sd">        ax : matplotlib axis, optional</span>
<span class="sd">            If specified, the inverted graph will be plotted agains `ax`.</span>
<span class="sd">        edge_color : str, optional</span>
<span class="sd">            Color of the edges of the mesh.</span>
<span class="sd">        attr : str, optional</span>
<span class="sd">            Name of the attribute to be plotted.</span>
<span class="sd">        sens : bool, optional</span>
<span class="sd">            If `True` and if sensitivity is available, it will be plotted as</span>
<span class="sd">            a white transparent shade on top of the inverted section.</span>
<span class="sd">        color_map : str, optional</span>
<span class="sd">            Name of the colormap to be used.</span>
<span class="sd">        clabel : str, optional</span>
<span class="sd">            Label of the colorbar (by default the label is the value of `attr`).</span>
<span class="sd">        doi : bool, optional</span>
<span class="sd">            If True, it will draw a dotted red line corresponding to 0.02 from the</span>
<span class="sd">            Oldenburg and Li method. Note that `R2.modeDOI()` needs to be run</span>
<span class="sd">            for that.</span>
<span class="sd">        doiSens : bool, optional</span>
<span class="sd">            If True, it will draw a dashed line corresponding to 0.001 of the maximum</span>
<span class="sd">            of the log10 sensitivity.</span>
<span class="sd">        contour : bool, optional</span>
<span class="sd">            If True, contours will be plotted.</span>
<span class="sd">        cropMaxDepth : bool, optional</span>
<span class="sd">            If True, the mesh will be clipped with at a depth following the surface.</span>
<span class="sd">            If False, the mesh will be clipped at the maximum depth available.</span>
<span class="sd">            This doesn&#39;t have any effect if clipContour is False.</span>
<span class="sd">        clipContour : bool, optional</span>
<span class="sd">            If True, the contour of the area of interest will be clipped (default).</span>
<span class="sd">        clipCorners : bool, optional</span>
<span class="sd">            If &#39;True&#39;, triangles from bottom corners will be cropped (only if the whole mesh is not shown).</span>
<span class="sd">        use_pyvista : bool, optional</span>
<span class="sd">            (3D only) Use visual toolkit backend for displaying 3D mesh, note that pyvista</span>
<span class="sd">            must be installed for this to work. </span>
<span class="sd">        background_color : tuple, optional </span>
<span class="sd">            (3D only) Background color assigned to pyvista plotter object when created. Not yet</span>
<span class="sd">            supported for matplotlib axis handles. </span>
<span class="sd">        pvslices : tuple of list of float, optional</span>
<span class="sd">            (3D only) Determine the X, Y, Z slices. e.g.: ([3], [], [-3, -4]) will add</span>
<span class="sd">            a slice normal to X in 3 and two slices normal to Z in -3 and -4.</span>
<span class="sd">        pvspline : &#39;elec&#39; or numpy array, optional</span>
<span class="sd">            (3D only) If &#39;elec&#39; mesh will be sliced along the electrodes path otherwise </span>
<span class="sd">            an array of X, Y, Z of points on a path to slice the mesh along that path is needed.</span>
<span class="sd">        pvthreshold : list of two floats, optional</span>
<span class="sd">            (3D only) Keep values between pvthreshold[0] and pvthreshold[1].</span>
<span class="sd">        pvgrid : bool, optional</span>
<span class="sd">            (3D only) Show grid or not.</span>
<span class="sd">        pvcontour: list of float, optional</span>
<span class="sd">            (3D only) Values of the isosurface to be plotted.</span>
<span class="sd">        pvdelaunay3d : bool, optional</span>
<span class="sd">            If `True` a &quot;Delaunay 3D&quot; triangulation filter will be applied on the mesh.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meshResults</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getResults</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">attr</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;c&#39;</span><span class="p">):</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="s1">&#39;Resistivity(log10)&#39;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">attr</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;c&#39;</span><span class="p">):</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="s1">&#39;Sigma_real(log10)&#39;</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meshResults</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">attr</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="n">keys</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Attribute not found, revert to </span><span class="si">{:s}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">attr</span><span class="p">))</span>
            
        <span class="c1">#check for clipping </span>
        <span class="k">if</span> <span class="s1">&#39;typ&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshParams</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="ow">and</span> <span class="s1">&#39;clipping&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;tank&#39;</span><span class="p">,</span> <span class="s1">&#39;cylinder&#39;</span><span class="p">,</span> <span class="s1">&#39;prism&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshParams</span><span class="p">[</span><span class="s1">&#39;typ&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">a</span><span class="p">:</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;clipping&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span> 
            
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meshResults</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshResults</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;2&#39;</span> <span class="ow">and</span> <span class="n">index</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="c1"># 2D case</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudo3DSurvey</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">projs</span> <span class="o">!=</span> <span class="p">[]:</span> <span class="c1"># we have pseudo 3D survey</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;num_xz_poly&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">projs</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;num_xz_poly&#39;</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span> <span class="c1"># should update this based on current mesh to get right limits</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">zlim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">projs</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">zlim</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">fmd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">projs</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">fmd</span>
                <span class="k">if</span> <span class="n">zlim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">zlim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zlim</span>
                <span class="n">mesh</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">edge_color</span><span class="o">=</span><span class="n">edge_color</span><span class="p">,</span> <span class="n">darkMode</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">darkMode</span><span class="p">,</span>
                            <span class="n">attr</span><span class="o">=</span><span class="n">attr</span><span class="p">,</span> <span class="n">sens</span><span class="o">=</span><span class="n">sens</span><span class="p">,</span> <span class="n">color_map</span><span class="o">=</span><span class="n">color_map</span><span class="p">,</span>
                            <span class="n">zlim</span><span class="o">=</span><span class="n">zlim</span><span class="p">,</span> <span class="n">clabel</span><span class="o">=</span><span class="n">clabel</span><span class="p">,</span> <span class="n">contour</span><span class="o">=</span><span class="n">contour</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">doi</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span> <span class="c1"># DOI based on Oldenburg and Li</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">doiComputed</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span> 
                        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;doiSens&#39;</span><span class="p">])</span>
                        <span class="n">levels</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">]</span>
                        <span class="n">linestyle</span> <span class="o">=</span> <span class="s1">&#39;:&#39;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Rerun the inversion with `modelDOI=True` first or use `doiSens`.&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">doiSens</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span> <span class="c1"># DOI based on log10(sensitivity)</span>
                    <span class="k">if</span> <span class="s1">&#39;Sensitivity(log10)&#39;</span> <span class="ow">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;Sensitivity(log10)&#39;</span><span class="p">])</span>
                        <span class="n">levels</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mf">0.001</span><span class="o">*</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">z</span><span class="p">)))]</span>
                        <span class="n">linestyle</span> <span class="o">=</span> <span class="s1">&#39;--&#39;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">doiSens</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">clipContour</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">topo</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;buried&#39;</span><span class="p">])):</span>
                    <span class="c1"># it&#39;s a whole space mesh, clipContour is not needed for that but contour can be drawn</span>
                    <span class="n">cropMaxDepth</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="n">doi</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">or</span> <span class="n">doiSens</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">xc</span><span class="p">,</span> <span class="n">yc</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">elmCentre</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">mesh</span><span class="o">.</span><span class="n">elmCentre</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span>
                    <span class="n">triang</span> <span class="o">=</span> <span class="n">tri</span><span class="o">.</span><span class="n">Triangulation</span><span class="p">(</span><span class="n">xc</span><span class="p">,</span> <span class="n">yc</span><span class="p">)</span>
                    <span class="n">cont</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">tricontour</span><span class="p">(</span><span class="n">triang</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="n">levels</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linestyles</span><span class="o">=</span><span class="n">linestyle</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">clipContour</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_clipContour</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">ax</span><span class="p">,</span> <span class="n">cont</span><span class="o">.</span><span class="n">collections</span><span class="p">,</span> <span class="n">clipCorners</span><span class="o">=</span><span class="n">clipCorners</span><span class="p">)</span>
                <span class="n">colls</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">cax</span><span class="o">.</span><span class="n">collections</span> <span class="k">if</span> <span class="n">contour</span> <span class="o">==</span> <span class="kc">True</span> <span class="k">else</span> <span class="p">[</span><span class="n">mesh</span><span class="o">.</span><span class="n">cax</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">clipContour</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_clipContour</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">ax</span><span class="p">,</span> <span class="n">colls</span><span class="p">,</span> <span class="n">cropMaxDepth</span><span class="o">=</span><span class="n">cropMaxDepth</span><span class="p">,</span> <span class="n">clipCorners</span><span class="o">=</span><span class="n">clipCorners</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;2&#39;</span> <span class="ow">and</span> <span class="n">index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="c1"># 3D grid of 2D surveys (pseudo 3D)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">showPseudo3DResults</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">edge_color</span><span class="o">=</span><span class="n">edge_color</span><span class="p">,</span>
                    <span class="n">attr</span><span class="o">=</span><span class="n">attr</span><span class="p">,</span> <span class="n">color_map</span><span class="o">=</span><span class="n">color_map</span><span class="p">,</span> <span class="n">clabel</span><span class="o">=</span><span class="n">clabel</span><span class="p">,</span> <span class="n">returnMesh</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">use_pyvista</span><span class="o">=</span><span class="n">use_pyvista</span><span class="p">,</span> <span class="n">background_color</span><span class="o">=</span><span class="n">background_color</span><span class="p">,</span>
                    <span class="n">pvslices</span><span class="o">=</span><span class="n">pvslices</span><span class="p">,</span> <span class="n">pvspline</span><span class="o">=</span><span class="n">pvspline</span><span class="p">,</span> <span class="n">pvthreshold</span><span class="o">=</span><span class="n">pvthreshold</span><span class="p">,</span> <span class="n">pvgrid</span><span class="o">=</span><span class="n">pvgrid</span><span class="p">,</span>
                    <span class="n">pvcontour</span><span class="o">=</span><span class="n">pvcontour</span><span class="p">,</span> <span class="n">cropMaxDepth</span><span class="o">=</span><span class="n">cropMaxDepth</span><span class="p">,</span> <span class="n">clipCorners</span><span class="o">=</span><span class="n">clipCorners</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># 3D case</span>
                <span class="k">if</span> <span class="n">zlim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">zlim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zlim</span>
                    <span class="c1"># zlim = [np.min(mesh.node[:,2]), np.max(mesh.node[:,2])]</span>
                <span class="k">if</span> <span class="n">cropMaxDepth</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">fmd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">zlim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">zlim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;remote&#39;</span><span class="p">]][</span><span class="s1">&#39;z&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">fmd</span> <span class="c1"># TODO not sure about that</span>
                <span class="n">mesh</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">edge_color</span><span class="o">=</span><span class="n">edge_color</span><span class="p">,</span>
                        <span class="n">attr</span><span class="o">=</span><span class="n">attr</span><span class="p">,</span> <span class="n">color_map</span><span class="o">=</span><span class="n">color_map</span><span class="p">,</span> <span class="n">clabel</span><span class="o">=</span><span class="n">clabel</span><span class="p">,</span>
                        <span class="n">zlim</span><span class="o">=</span><span class="n">zlim</span><span class="p">,</span> <span class="n">use_pyvista</span><span class="o">=</span><span class="n">use_pyvista</span><span class="p">,</span> <span class="n">background_color</span><span class="o">=</span><span class="n">background_color</span><span class="p">,</span>
                        <span class="n">pvslices</span><span class="o">=</span><span class="n">pvslices</span><span class="p">,</span> <span class="n">pvspline</span><span class="o">=</span><span class="n">pvspline</span><span class="p">,</span> <span class="n">pvthreshold</span><span class="o">=</span><span class="n">pvthreshold</span><span class="p">,</span> <span class="n">pvgrid</span><span class="o">=</span><span class="n">pvgrid</span><span class="p">,</span>
                        <span class="n">pvcontour</span><span class="o">=</span><span class="n">pvcontour</span><span class="p">,</span> <span class="n">pvdelaunay3d</span><span class="o">=</span><span class="n">pvdelaunay3d</span><span class="p">,</span> <span class="n">darkMode</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">darkMode</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;len(R2.meshResults) == 0, no inversion results parsed.&#39;</span><span class="p">)</span>



    <span class="k">def</span> <span class="nf">getResults</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dirname</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Collect inverted results after running the inversion and adding</span>
<span class="sd">        them to `R2.meshResults` list.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dirname : str, optional</span>
<span class="sd">            If specified, dirname will be used as the working directory (this</span>
<span class="sd">            is needed for R2.loadResults()). Default is self.dirname.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dirname</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dirname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dirname</span>
        <span class="n">idone</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">ifailed</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meshResults</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># make sure we empty the list first</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iTimeLapse</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirname</span><span class="p">,</span> <span class="s1">&#39;ref&#39;</span><span class="p">,</span> <span class="s1">&#39;f001_res.vtk&#39;</span><span class="p">)</span>
            <span class="n">mesh0</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">vtk_import</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">order_nodes</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">mesh0</span><span class="o">.</span><span class="n">mesh_title</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span>
            <span class="n">elec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">elec</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">mesh0</span><span class="o">.</span><span class="n">setElec</span><span class="p">(</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">elec</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">elec</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            <span class="n">mesh0</span><span class="o">.</span><span class="n">iremote</span> <span class="o">=</span> <span class="n">elec</span><span class="p">[</span><span class="s1">&#39;remote&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meshResults</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mesh0</span><span class="p">)</span>
            <span class="n">idone</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iForward</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">initMesh</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">vtk_import</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirname</span><span class="p">,</span> <span class="s1">&#39;fwd&#39;</span><span class="p">,</span><span class="s1">&#39;forward_model.vtk&#39;</span><span class="p">),</span> <span class="n">order_nodes</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">elec_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
            <span class="n">elec_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
            <span class="n">elec_z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
            <span class="n">initMesh</span><span class="o">.</span><span class="n">setElec</span><span class="p">(</span><span class="n">elec_x</span><span class="p">,</span> <span class="n">elec_y</span><span class="p">,</span> <span class="n">elec_z</span><span class="p">)</span>
            <span class="n">initMesh</span><span class="o">.</span><span class="n">mesh_title</span> <span class="o">=</span> <span class="s1">&#39;Forward Model&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meshResults</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">initMesh</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">)):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iTimeLapse</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirname</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_res.vtk&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">mesh</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">vtk_import</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">order_nodes</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">mesh</span><span class="o">.</span><span class="n">mesh_title</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">name</span>
                    <span class="n">elec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">elec</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">mesh</span><span class="o">.</span><span class="n">setElec</span><span class="p">(</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">elec</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">elec</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
                    <span class="n">mesh</span><span class="o">.</span><span class="n">iremote</span> <span class="o">=</span> <span class="n">elec</span><span class="p">[</span><span class="s1">&#39;remote&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">meshResults</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span> <span class="c1"># this will be very memory intensive to put all meshes into a list for long time lapse surveys</span>
                    <span class="c1">#TODO : Rethink storage of timelapse results </span>
                    <span class="n">idone</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="n">ifailed</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="c1"># if inversion fails in time-lapse it&#39;s that the initial</span>
                    <span class="c1"># model is good enough to explain the data (a_wgt/b_wgt</span>
                    <span class="c1"># error too low) so we can replace it by the initial model</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iTimeLapse</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">meshResults</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mesh0</span><span class="p">)</span> <span class="c1"># TODO not sure</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\r</span><span class="si">{:d}</span><span class="s1">/</span><span class="si">{:d}</span><span class="s1"> results parsed (</span><span class="si">{:d}</span><span class="s1"> ok; </span><span class="si">{:d}</span><span class="s1"> failed)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">),</span> <span class="n">idone</span><span class="p">,</span> <span class="n">ifailed</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span>
                <span class="c1">#break</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

        <span class="c1"># compute conductivity in mS/m</span>
        <span class="n">res_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;Resistivity&#39;</span><span class="p">,</span><span class="s1">&#39;Resistivity(Ohm-m)&#39;</span><span class="p">,</span><span class="s1">&#39;Resistivity(ohm.m)&#39;</span><span class="p">,</span> <span class="s1">&#39;Magnitude(ohm.m)&#39;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">mesh</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshResults</span><span class="p">:</span>
            <span class="n">res_name</span> <span class="o">=</span> <span class="n">res_names</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">res_names</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">keys</span><span class="p">()))][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;Conductivity(mS/m)&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1000</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="n">res_name</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;c&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">kFactor</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># if kFactor is 1 then probably phase is provided and we shouldn&#39;t estimate chargeability</span>
            <span class="k">for</span> <span class="n">mesh</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshResults</span><span class="p">:</span>
                <span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;Chargeability(mV/V)&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;Phase(mrad)&#39;</span><span class="p">])</span><span class="o">/-</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">kFactor</span>
        <span class="c1"># compute difference in percent in case of reg_mode == 1</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iTimeLapse</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">):</span><span class="c1"># and (self.param[&#39;reg_mode&#39;] == 1):</span>
            <span class="c1"># even with reg_mode == 2 when the inversion converged by overshooting</span>
            <span class="c1"># it won&#39;t output &#39;difference(percent)&#39; attribute, so let&#39;s compute for all TL</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">computeDiff</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;failed to compute difference: &#39;</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
                <span class="k">pass</span>
    
    
    
    <span class="k">def</span> <span class="nf">loadResults</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">invdir</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Given working directory, will attempt to load the results of an</span>
<span class="sd">        already run inversion.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        invdir : str</span>
<span class="sd">            Path to the inversion directory.</span>
<span class="sd">        </span>
<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        This does not load the data files neither the mesh nor the settings so</span>
<span class="sd">        you can&#39;t run another inversion with that. It&#39;s just for display.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get all files </span>
        <span class="n">files</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">invdir</span><span class="p">)</span>
        
        <span class="c1"># get typ</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">files</span> <span class="k">if</span> <span class="n">f</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span> <span class="o">==</span> <span class="s1">&#39;.in&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># detect if time-lapse and assume reg_mode == 0</span>
        <span class="k">if</span> <span class="s1">&#39;ref&#39;</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">iTimeLapse</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;reg_mode&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            
        <span class="c1"># load surveys</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;cR2&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;cR3t&#39;</span><span class="p">):</span>
            <span class="n">ftype</span> <span class="o">=</span> <span class="s1">&#39;ProtocolIP&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ftype</span> <span class="o">=</span> <span class="s1">&#39;ProtocolDC&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iTimeLapse</span><span class="p">:</span>
            <span class="c1"># split the protocol.dat</span>
            <span class="c1"># in pandas &gt;= 1.4.0 header=None with first row with one column (nb of meas)</span>
            <span class="c1"># causes ParseError. to fix it we first read the number of rows from line 2</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">invdir</span><span class="p">,</span> <span class="s1">&#39;protocol.dat&#39;</span><span class="p">),</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>  <span class="c1"># first wow, we don&#39;t care</span>
                <span class="n">nline</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">))</span>
            <span class="n">dfall</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">invdir</span><span class="p">,</span> <span class="s1">&#39;protocol.dat&#39;</span><span class="p">),</span>
                                <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nline</span><span class="p">))</span>
            <span class="n">idf</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dfall</span><span class="p">[</span><span class="n">dfall</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="p">))[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">idf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dfall</span><span class="p">))</span>
            <span class="n">dfs</span> <span class="o">=</span> <span class="p">[</span><span class="n">dfall</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">idf</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">idf</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,:]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">idf</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
    
            <span class="c1"># writing all protocol.dat</span>
            <span class="n">files</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">df</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dfs</span><span class="p">):</span>
                <span class="n">outputname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="s1">&#39;survey</span><span class="si">{:03d}</span><span class="s1">.dat&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
                <span class="n">files</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">outputname</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;t&#39;</span><span class="p">:</span>
                    <span class="n">df2</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">astype</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span>
                                         <span class="mi">3</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="mi">5</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span>
                                         <span class="mi">6</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="mi">7</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="mi">8</span><span class="p">:</span><span class="nb">int</span><span class="p">})</span>
                    <span class="n">df2</span> <span class="o">=</span> <span class="n">df2</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># discard res0 as parser doesn&#39;t support it</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">df2</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">astype</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span>
                                         <span class="mi">3</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span><span class="nb">int</span><span class="p">})</span>
                    <span class="n">df2</span> <span class="o">=</span> <span class="n">df2</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># discard res0</span>

                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">outputname</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:d}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                    <span class="n">df2</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">line_terminator</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="c1"># header with line count already included</span>
            
            <span class="n">fnames</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">invdir</span><span class="p">,</span> <span class="s1">&#39;ref&#39;</span><span class="p">,</span> <span class="s1">&#39;protocol.dat&#39;</span><span class="p">)]</span> <span class="o">+</span> <span class="n">files</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">createTimeLapseSurvey</span><span class="p">(</span><span class="n">fnames</span><span class="p">,</span> <span class="n">ftype</span><span class="o">=</span><span class="n">ftype</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;reg_mode&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># assumed</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">createSurvey</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">invdir</span><span class="p">,</span> <span class="s1">&#39;protocol.dat&#39;</span><span class="p">),</span> <span class="n">ftype</span><span class="o">=</span><span class="n">ftype</span><span class="p">)</span>

        <span class="c1"># get electrodes</span>
        <span class="n">elec</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">invdir</span><span class="p">,</span> <span class="s1">&#39;electrodes.dat&#39;</span><span class="p">),</span> <span class="n">delim_whitespace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setElec</span><span class="p">(</span><span class="n">elec</span><span class="o">.</span><span class="n">values</span><span class="p">)</span> <span class="c1"># assuming none are buried</span>
 
        <span class="c1"># load mesh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">importMesh</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">invdir</span><span class="p">,</span> <span class="s1">&#39;mesh.msh&#39;</span><span class="p">))</span>
        <span class="c1"># self.mesh = mt.vtk_import(os.path.join(invdir, &#39;f001_res.vtk&#39;))</span>
        
        <span class="c1"># get results</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">getResults</span><span class="p">(</span><span class="n">invdir</span><span class="p">)</span>
    
    
    
    <span class="k">def</span> <span class="nf">getR2out</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reat the .out file and parse its content.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Dataframe with the dataset name, and the RMS decrease for each iteration.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">+</span> <span class="s1">&#39;.out&#39;</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="n">idataset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">iiter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">resRMS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">phaseRMS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">read</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">rejected</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">irow</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;dataset&#39;</span><span class="p">,</span> <span class="s1">&#39;iteration&#39;</span><span class="p">,</span> <span class="s1">&#39;resRMS&#39;</span><span class="p">,</span>
                                   <span class="s1">&#39;phaseRMS&#39;</span><span class="p">,</span> <span class="s1">&#39;read&#39;</span><span class="p">,</span> <span class="s1">&#39;rejected&#39;</span><span class="p">,</span> <span class="s1">&#39;success&#39;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
            <span class="n">success</span> <span class="o">=</span> <span class="s1">&#39;N/A&#39;</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Iteration&#39;</span><span class="p">:</span>
                    <span class="n">iiter</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Measurements&#39;</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;read:&#39;</span><span class="p">):</span>
                    <span class="n">read</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                    <span class="n">rejected</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Final&#39;</span><span class="p">:</span>
                    <span class="n">resRMS</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
                    <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">irow</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span><span class="p">,</span> <span class="n">idataset</span><span class="p">,</span> <span class="n">iiter</span><span class="p">,</span> <span class="n">resRMS</span><span class="p">,</span> <span class="n">phaseRMS</span><span class="p">,</span>
                                       <span class="n">read</span><span class="p">,</span> <span class="n">rejected</span><span class="p">,</span> <span class="n">success</span><span class="p">]</span>
                    <span class="n">irow</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;FATAL:&#39;</span><span class="p">:</span>
                    <span class="n">resRMS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">elif</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Processing&#39;</span><span class="p">:</span>
                    <span class="n">iiter</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">idataset</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">idataset</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">):</span>
                        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="n">idataset</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">name</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;dataset</span><span class="si">{:03.0f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">idataset</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">df</span>


    <span class="k">def</span> <span class="nf">showRMS</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Show the RMS decrease for each iteration.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int, optional</span>
<span class="sd">            Index of the dataset for which to plot the RMS.</span>
<span class="sd">        ax : matplotlib axis, optional</span>
<span class="sd">            If provided, the graph will be plotted against it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getR2out</span><span class="p">()</span>
        <span class="n">idatasets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;dataset&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">idatasets</span><span class="p">:</span>
            <span class="n">ie</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;dataset&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="n">ie</span><span class="p">][</span><span class="s1">&#39;iteration&#39;</span><span class="p">],</span> <span class="n">df</span><span class="p">[</span><span class="n">ie</span><span class="p">][</span><span class="s1">&#39;resRMS&#39;</span><span class="p">],</span> <span class="s1">&#39;.-&#39;</span><span class="p">)</span>
            <span class="n">offset</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ie</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Iterations&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;RMS misfit&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>
        

    <span class="c1"># def showSection(self, fname=&#39;&#39;, ax=None, ilog10=True, isen=False, figsize=(8,3)):</span>
    <span class="c1">#     &quot;&quot;&quot;Show inverted section based on the `_res.dat``file instead of the</span>
    <span class="c1">#     `.vtk`.</span>

    <span class="c1">#     Parameters</span>
    <span class="c1">#     ----------</span>
    <span class="c1">#     fname : str, optional</span>
    <span class="c1">#         Name of the inverted `.dat` file produced by the inversion.</span>
    <span class="c1">#     ax : matplotlib axis, optional</span>
    <span class="c1">#         If specified, the graph will be plotted along `ax`.</span>
    <span class="c1">#     ilog10 : bool, optional</span>
    <span class="c1">#         If `True`, the log10 of the resistivity will be used.</span>
    <span class="c1">#     isen : bool, optional</span>
    <span class="c1">#         If `True`, sensitivity will be displayed as white transparent</span>
    <span class="c1">#         shade on top of the inverted section.</span>
    <span class="c1">#     figsize : tuple, optional</span>
    <span class="c1">#         Size of the figure.</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     print(&#39;showSection called (to be discarded in the futur)&#39;)</span>
    <span class="c1">#     if fname == &#39;&#39;:</span>
    <span class="c1">#         fname = os.path.join(self.dirname, &#39;f001.dat&#39;)</span>
    <span class="c1">#     res = pd.read_csv(fname, delimiter=&#39; *&#39;, header=None, engine=&#39;python&#39;).values</span>
    <span class="c1">#     lenx = len(np.unique(res[:,0]))</span>
    <span class="c1">#     leny = len(np.unique(res[:,1]))</span>
    <span class="c1">#     x = res[:,0].reshape((leny, lenx), order=&#39;F&#39;)</span>
    <span class="c1">#     y = res[:,1].reshape((leny, lenx), order=&#39;F&#39;)</span>
    <span class="c1">#     z = res[:,2].reshape((leny, lenx), order=&#39;F&#39;)</span>
    <span class="c1">#     if isen:</span>
    <span class="c1">#         sen = pd.read_csv(fname.replace(&#39;res&#39;,&#39;sen&#39;), delimiter=&#39; *&#39;, header=None, engine=&#39;python&#39;).values</span>
    <span class="c1">#         lenx = len(np.unique(sen[:,0]))</span>
    <span class="c1">#         leny = len(np.unique(sen[:,1]))</span>
    <span class="c1">#         zs = sen[:,2].reshape((leny, lenx), order=&#39;F&#39;)</span>
    <span class="c1">#         zs = np.log10(zs)</span>
    <span class="c1">#         zs -= np.min(zs)</span>
    <span class="c1">#         alpha = zs/np.max(zs)</span>
    <span class="c1">#         print(np.max(alpha), np.min(alpha))</span>
    <span class="c1">#     if ilog10:</span>
    <span class="c1">#         z = np.log10(z)</span>
    <span class="c1">#     if ax is None:</span>
    <span class="c1">#         fig, ax = plt.subplots(figsize=figsize)</span>
    <span class="c1">#     else:</span>
    <span class="c1">#         fig = ax.get_figure()</span>
    <span class="c1">#     cax = ax.pcolormesh(x, y, z)</span>
    <span class="c1">#     ax.plot(self.elec[:,0], self.elec[:,2], &#39;ko&#39;)</span>
    <span class="c1">#     cbar = fig.colorbar(cax, ax=ax)</span>
    <span class="c1">#     if ilog10:</span>
    <span class="c1">#         cbar.set_label(r&#39;$\log_{10}(\rho) [\Omega.m]$&#39;)</span>
    <span class="c1">#     else:</span>
    <span class="c1">#         cbar.set_label(r&#39;$\rho [\Omega.m]$&#39;)</span>
    <span class="c1">#     ax.set_ylabel(&#39;Depth [m]&#39;)</span>
    <span class="c1">#     ax.set_xlabel(&#39;Distance [m]&#39;)</span>


    <span class="k">def</span> <span class="nf">addRegion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xz</span><span class="p">,</span> <span class="n">res0</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">phase0</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">blocky</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fixed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                  <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">iplot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add region according to a polyline defined by `xz` and assign it</span>
<span class="sd">        the starting resistivity `res0`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xz : array</span>
<span class="sd">            Array with two columns for the x and y coordinates.</span>
<span class="sd">        res0 : float, optional</span>
<span class="sd">            Resistivity values of the defined area.</span>
<span class="sd">        phase0 : float, optional</span>
<span class="sd">            Read only if you choose the cR2 option. Phase value of the defined</span>
<span class="sd">            area in mrad</span>
<span class="sd">        blocky : bool, optional</span>
<span class="sd">            If `True` the boundary of the region will be blocky if inversion</span>
<span class="sd">            is block inversion.</span>
<span class="sd">        fixed : bool, optional</span>
<span class="sd">            If `True`, the inversion will keep the starting resistivity of this</span>
<span class="sd">            region.</span>
<span class="sd">        ax : matplotlib.axes.Axes</span>
<span class="sd">            If not `None`, the region will be plotted against this axes.</span>
<span class="sd">        iplot : bool, optional</span>
<span class="sd">            If `True` , the updated mesh with the region will be plotted.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">centroids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">elmCentre</span><span class="p">[:,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]]</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xz</span><span class="p">))</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">contains_points</span><span class="p">(</span><span class="n">centroids</span><span class="p">)</span>

        <span class="n">region</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;region&#39;</span><span class="p">])</span>
        <span class="n">regid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">region</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">region</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">regid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;region&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">region</span>
        <span class="n">resist0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;res0&#39;</span><span class="p">])</span>
        <span class="n">resist0</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">res0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;res0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">resist0</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;phase0&#39;</span><span class="p">])</span>
        <span class="n">phase</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">phase0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;phase0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">phase</span>

        <span class="c1"># define zone</span>
        <span class="k">if</span> <span class="n">blocky</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">zones</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;zones&#39;</span><span class="p">])</span>
            <span class="n">zones</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">regid</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;zones&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">zones</span>

        <span class="c1"># define fixed area</span>
        <span class="k">if</span> <span class="n">fixed</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">paramFixed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;param&#39;</span><span class="p">])</span>
            <span class="n">paramFixed</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;param&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">paramFixed</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;fixed </span><span class="si">{:d}</span><span class="s1"> elements&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">paramFixed</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)))</span>

        <span class="k">if</span> <span class="n">iplot</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">showMesh</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">resetRegions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Just reset all regions already drawn. Shouldn&#39;t be needed as</span>
<span class="sd">        the `self.runR2()` automatically use a homogenous model when starting</span>
<span class="sd">        for inversion. The only purpose of this is to use an inhomogeous</span>
<span class="sd">        starting model to invert data from forward modelling.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;region&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">numel</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;res0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">numel</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span> <span class="c1"># set back as default</span>


    <span class="k">def</span> <span class="nf">computeAttribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">formula</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">dump</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute a new attribute for each meshResults.</span>
<span class="sd">        </span>
<span class="sd">        NOTE: this function present a security risk as it allows execution</span>
<span class="sd">        of python code inputed by the user. It should be used with caution.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        formula : str</span>
<span class="sd">            Formula as a string. All attribute already in the mesh object are</span>
<span class="sd">            available from the x dictionary and can be sed as x[&#39;nameOfAttribute&#39;].</span>
<span class="sd">            e.g. : &quot;1/x[&#39;Resistivity&#39;]&quot; will compute the inverse of the &#39;Resistivity&#39;</span>
<span class="sd">            attribute if this attribute exists.</span>
<span class="sd">            Operators available are addition (+), soustraction (-), division (/)</span>
<span class="sd">            multiplication (*) and exponent (**). Parenthesis are also taken into account.</span>
<span class="sd">            numpy function such as np.sqrt() or np.cos() are also available.</span>
<span class="sd">            e.g. : &quot;(np.sqrt(x[&#39;Resistivity&#39;]) + 100)*1000&quot;</span>
<span class="sd">            Note: use a mixture of double and single quote such as double for</span>
<span class="sd">            the entire string and single for indexing the dictionnary x[&#39;keyName&#39;].</span>
<span class="sd">        name : str</span>
<span class="sd">            Name of the new attribute computed.</span>
<span class="sd">        dump : function, optional</span>
<span class="sd">            Function to write stdout.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dump</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meshResults</span><span class="p">):</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">]</span>
            <span class="n">x</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">cols</span><span class="p">,</span> <span class="n">vals</span><span class="p">))</span>
            <span class="c1"># DANGER ZONE =================================</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">m</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">formula</span><span class="p">)</span>
                <span class="n">dump</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:s}</span><span class="s1"> computation successful on meshResults[</span><span class="si">{:d}</span><span class="s1">]</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">dump</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:s}</span><span class="s1"> computation failed on meshResults[</span><span class="si">{:d}</span><span class="s1">]: </span><span class="si">{:s}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)))</span>
                <span class="k">pass</span>
            <span class="c1"># DANGER ZONE =================================</span>
            


    <span class="k">def</span> <span class="nf">createModel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dump</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">typ</span><span class="o">=</span><span class="s1">&#39;poly&#39;</span><span class="p">,</span> <span class="n">addAction</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Interactive model creation for forward modelling.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ax : matplotlib.axes.Axes, optional</span>
<span class="sd">            Axes to which the graph will be plotted.</span>
<span class="sd">        dump : function, optional</span>
<span class="sd">            Function that outputs messages from the interactive model creation.</span>
<span class="sd">        typ : str</span>
<span class="sd">            Type of selection either `poly` for polyline or `rect` for</span>
<span class="sd">            rectangle.</span>
<span class="sd">        addAction : function</span>
<span class="sd">            Function to be called once the selection is finished (design for</span>
<span class="sd">            GUI purpose).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fig : matplotlib.figure</span>
<span class="sd">            If `ax` is `None`, will return a figure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dump</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;will create a mesh before&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">createMesh</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">figure</span>

        <span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
            <span class="n">region</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;region&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">regid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">region</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;nb elements selected:&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span> <span class="s1">&#39;in region&#39;</span><span class="p">,</span> <span class="n">regid</span><span class="p">)</span>
            <span class="n">region</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">regid</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;region&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">region</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">attr</span><span class="o">=</span><span class="s1">&#39;region&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">addAction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">addAction</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">atribute_title</span> <span class="o">=</span> <span class="s1">&#39;Regions&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">zlim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_defineZlim</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">attr</span><span class="o">=</span><span class="s1">&#39;region&#39;</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">zlim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">zlim</span><span class="p">,</span> <span class="n">darkMode</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">darkMode</span><span class="p">)</span>
        <span class="c1"># we need to assign a selector to self otherwise it&#39;s not used</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selector</span> <span class="o">=</span> <span class="n">SelectPoints</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">elmCentre</span><span class="p">[:,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]],</span>
                                     <span class="n">typ</span><span class="o">=</span><span class="n">typ</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fig</span>



    <span class="k">def</span> <span class="nf">designModel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dump</span><span class="o">=</span><span class="nb">print</span><span class="p">,</span> <span class="n">typ</span><span class="o">=</span><span class="s1">&#39;poly&#39;</span><span class="p">,</span> <span class="n">addAction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fmd</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Interactive model design for forward modelling (triangular only).</span>
<span class="sd">        As opposite to R2.createModel(). R2.designModel() allows to draw mesh</span>
<span class="sd">        region **before** meshing. This allows to have straight boundaries for</span>
<span class="sd">        triangular mesh.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ax : matplotlib.axes.Axes, optional</span>
<span class="sd">            Axes to which the graph will be plotted.</span>
<span class="sd">        dump : function, optional</span>
<span class="sd">            Function that outputs messages from the interactive model creation.</span>
<span class="sd">        typ : str</span>
<span class="sd">            Type of selection either `poly` for polyline or `rect` for</span>
<span class="sd">            rectangle.</span>
<span class="sd">        addAction : function</span>
<span class="sd">            Function to be called once the selection is finished (design for</span>
<span class="sd">            GUI purpose).</span>
<span class="sd">        fmd : float, optional</span>
<span class="sd">            Depth of of interest specifies as a relative positive number from the surface.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fig : matplotlib.figure</span>
<span class="sd">            If `ax` is `None`, will return a figure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">fmd</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">computeFineMeshDepth</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fmd</span> <span class="o">=</span> <span class="n">fmd</span>

        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">figure</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">geom_input</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">elecColor</span> <span class="o">=</span> <span class="s1">&#39;ko&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">darkMode</span> <span class="ow">is</span> <span class="kc">False</span> <span class="k">else</span> <span class="s1">&#39;wo&#39;</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">],</span> <span class="n">elecColor</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;electrode&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">])</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">fmd</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">])])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Distance [m]&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Elevation [m]&#39;</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">callback</span><span class="p">():</span>
            <span class="n">vert</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">geom_input</span><span class="p">[</span><span class="s1">&#39;polygon&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geom_input</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[</span><span class="n">vert</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">vert</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()]</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">vert</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">vert</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;.-&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">addAction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">addAction</span><span class="p">()</span>
        <span class="c1"># we need to assign a selector to self otherwise it&#39;s not used</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selector</span> <span class="o">=</span> <span class="n">SelectPoints</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">typ</span><span class="o">=</span><span class="n">typ</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">)</span>
<span class="c1">#        surveyLength = np.max(self.elec[:,0]) - np.min(self.elec[:,0])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="o">.</span><span class="n">xmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">])</span><span class="c1"># - 10 * surveyLength</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="o">.</span><span class="n">xmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">])</span><span class="c1"># + 10 * surveyLength</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fig</span>


    <span class="k">def</span> <span class="nf">createModelMesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a triangular mesh given the designed geometry by</span>
<span class="sd">        R2.designModel().</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        All parameters to be passed are similar to `R2.createMesh()`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">geom_input</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom_input</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">createMesh</span><span class="p">(</span><span class="n">typ</span><span class="o">=</span><span class="s1">&#39;trian&#39;</span><span class="p">,</span> <span class="n">geom_input</span><span class="o">=</span><span class="n">geom_input</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>



    <span class="k">def</span> <span class="nf">setStartingRes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">regionValues</span><span class="o">=</span><span class="p">{},</span> <span class="n">zoneValues</span><span class="o">=</span><span class="p">{},</span> <span class="n">fixedValues</span><span class="o">=</span><span class="p">{},</span> <span class="n">ipValues</span><span class="o">=</span><span class="p">{}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Assign starting resitivity values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        regionValues : dict, optional</span>
<span class="sd">            Dictionnary with key being the region number and the value being</span>
<span class="sd">            the resistivity in [Ohm.m].</span>
<span class="sd">        zoneValues : dict, optional</span>
<span class="sd">            Dictionnary with key being the region number and the zone number.</span>
<span class="sd">            There would be no smoothing between the zones if &#39;block inversion&#39;</span>
<span class="sd">            is selected (`inversion_type` = 4).</span>
<span class="sd">        fixedValues : dict, optional</span>
<span class="sd">            Dictionnary with key being the region number and a boolean value if</span>
<span class="sd">            we want to fix the resistivity of the zone to the starting one.</span>
<span class="sd">            Note that it only works for triangular mesh for now.</span>
<span class="sd">        ipValues : dict, optional</span>
<span class="sd">            Dictionnary with key being the region number and the values beeing</span>
<span class="sd">            the phase [mrad].</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        Region 0 is the background region. It has zone=1, and fixed=False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">regions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;region&#39;</span><span class="p">])</span>
        <span class="n">res0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;res0&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">regionValues</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">regions</span> <span class="o">==</span> <span class="nb">int</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="n">res0</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">regionValues</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;res0File&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;res0.dat&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span><span class="s1">&#39;res0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">res0</span>
        <span class="c1"># print(&#39;regionValues:&#39;,regionValues)</span>

        <span class="n">zones</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;zones&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">zoneValues</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">regions</span> <span class="o">==</span> <span class="nb">int</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="n">zones</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">zoneValues</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span><span class="s1">&#39;zones&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">zones</span>

        <span class="n">fixed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;param&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">fixedValues</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">regions</span> <span class="o">==</span> <span class="nb">int</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">fixedValues</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">fixed</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span><span class="s1">&#39;param&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fixed</span>

        <span class="n">phase0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;phase0&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">ipValues</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">regions</span> <span class="o">==</span> <span class="nb">int</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="n">phase0</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">ipValues</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span><span class="s1">&#39;phase0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">phase0</span>


    <span class="k">def</span> <span class="nf">setRefModel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">res0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the reference model according to a previous inversion, avoids</span>
<span class="sd">        the need to invert reference model again for timelapse workflows.</span>
<span class="sd">        In contrast to `R2.setStartingRes()` which assign resistivity to group</span>
<span class="sd">        of elements, this method requires a vector of the same length as the </span>
<span class="sd">        number of elements. This enables, notably to manually perform consecutive</span>
<span class="sd">        background constrained inversion.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -------------</span>
<span class="sd">        res0: array like</span>
<span class="sd">            Array of resistivity values, ideally from a previous inversion. The</span>
<span class="sd">            length of this array should be the same as the number of elements.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">addAttribute</span><span class="p">(</span><span class="n">res0</span><span class="p">,</span><span class="s1">&#39;res0&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Cant set reference model without first assigning/creating a mesh&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;reg_mode&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># ensure inversion is background regularised</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span><span class="s1">&#39;t&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;inverse_type&#39;</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;res0File&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Start_res.dat&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;num_regions&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">writeAttr</span><span class="p">(</span><span class="s1">&#39;res0&#39;</span><span class="p">,</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span><span class="s1">&#39;Start_res.dat&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">referenceMdl</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Reference model successfully assigned&#39;</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_seqIdxFromLabel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">]</span>
        <span class="n">uline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
        <span class="n">nline</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">uline</span><span class="p">)</span>
        <span class="n">seqIdx</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nline</span><span class="p">):</span>
            <span class="n">lidx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">lines</span><span class="o">==</span><span class="n">uline</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">lidx</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lidx</span><span class="p">)):</span>
                <span class="n">idx</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">lidx</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">seqIdx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">seqIdx</span>
        
    <span class="k">def</span> <span class="nf">createSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;dpdp1&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">)],</span> <span class="n">seqIdx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="o">*</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates a forward modelling sequence, see examples below for usage.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : list of tuple, optional</span>
<span class="sd">            Each tuple is the form (&lt;array_name&gt;, param1, param2, ...)</span>
<span class="sd">            Types of sequences available are : &#39;dpdp1&#39;,&#39;dpdp2&#39;,&#39;wenner_alpha&#39;,</span>
<span class="sd">            &#39;wenner_beta&#39;, &#39;wenner_gamma&#39;, &#39;schlum1&#39;, &#39;schlum2&#39;, &#39;multigrad&#39;,</span>
<span class="sd">            &#39;custSeq&#39;.</span>
<span class="sd">            if &#39;custSeq&#39; is chosen, param1 should be a string of file path to a .csv</span>
<span class="sd">            file containing a custom sequence with 4 columns (a, b, m, n) containing </span>
<span class="sd">            forward model sequence.</span>
<span class="sd">        seqIdx: list of array like, optional</span>
<span class="sd">            Each entry in list contains electrode indices (not label and string)</span>
<span class="sd">            for a given electrode string which is to be sequenced. The advantage</span>
<span class="sd">            of a list means that sequences can be of different lengths. </span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; k = Project()</span>
<span class="sd">        &gt;&gt;&gt; k.setElec(np.c_[np.linspace(0,5.75, 24), np.zeros((24, 2))])</span>
<span class="sd">        &gt;&gt;&gt; k.createMesh(typ=&#39;trian&#39;)</span>
<span class="sd">        &gt;&gt;&gt; k.createSequence([(&#39;dpdp1&#39;, 1, 8), (&#39;wenner_alpha&#39;, 1), (&#39;wenner_alpha&#39;, 2)]) # dipole-dipole sequence</span>
<span class="sd">        &gt;&gt;&gt; k.createSequence([(&#39;custSeq&#39;, &#39;&lt;path to sequence file&gt;/sequence.csv&#39;)]) # importing a custom sequence</span>
<span class="sd">        &gt;&gt;&gt; seqIdx = [[0,1,2,3],[4,5,6,7],[8,9,10,11,12]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">addCustSeq</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span> <span class="c1"># add custom sequence </span>
            <span class="n">seq</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">seq</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The file should be a CSV file with headers with exactly 4 columns &#39;</span>
                                 <span class="s1">&#39;(a, b, m, n) with electrode numbers.&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">seq</span><span class="o">.</span><span class="n">values</span>
        
        <span class="n">fdico</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;dpdp1&#39;</span><span class="p">:</span> <span class="n">dpdp1</span><span class="p">,</span> <span class="c1"># dict referencing the seqeunce gen functions </span>
              <span class="s1">&#39;dpdp2&#39;</span><span class="p">:</span> <span class="n">dpdp2</span><span class="p">,</span>
              <span class="s1">&#39;wenner&#39;</span><span class="p">:</span> <span class="n">wenner</span><span class="p">,</span>
              <span class="s1">&#39;wenner_alpha&#39;</span><span class="p">:</span> <span class="n">wenner_alpha</span><span class="p">,</span>
              <span class="s1">&#39;wenner_beta&#39;</span><span class="p">:</span> <span class="n">wenner_beta</span><span class="p">,</span>
              <span class="s1">&#39;wenner_gamma&#39;</span><span class="p">:</span> <span class="n">wenner_gamma</span><span class="p">,</span>
              <span class="s1">&#39;schlum1&#39;</span><span class="p">:</span> <span class="n">schlum1</span><span class="p">,</span>
              <span class="s1">&#39;schlum2&#39;</span><span class="p">:</span> <span class="n">schlum2</span><span class="p">,</span>
              <span class="s1">&#39;multigrad&#39;</span><span class="p">:</span> <span class="n">multigrad</span><span class="p">,</span>
              <span class="s1">&#39;custSeq&#39;</span><span class="p">:</span> <span class="n">addCustSeq</span><span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">custSeq</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># reset the flag</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;R3t&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;cR3t&#39;</span><span class="p">):</span> <span class="c1">#its 3D</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;custSeq&#39;</span> <span class="ow">and</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">custSeq</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># we can&#39;t have custom sequence mixed with auto generated sequences in 3D - too complicated!</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Custom sequence detected. Skipping auto sequence generation...&#39;</span><span class="p">)</span>
                    <span class="n">sequence</span> <span class="o">=</span> <span class="n">addCustSeq</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequence</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># no string, so let&#39;s add them</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sequence</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sequence</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                                <span class="n">sequence</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;1 &#39;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">sequence</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span>
                    <span class="k">break</span> <span class="c1"># only one custom sequence allowed? </span>
                
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">custSeq</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>                    
                <span class="c1">#determine sequence index if not already given </span>
                <span class="k">if</span> <span class="n">seqIdx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1">#(not been set, so use electrode strings)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasElecString</span><span class="p">():</span><span class="c1">#then find it automatically </span>
                        <span class="n">seqIdx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">detectStrings</span><span class="p">(</span><span class="o">*</span><span class="n">kwargs</span><span class="p">)</span>
                        <span class="c1">#raise ValueError(&#39;Electrode strings have not been set&#39;)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">seqIdx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_seqIdxFromLabel</span><span class="p">()</span><span class="c1">#use electrode strings </span>
    
                <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">seqIdx</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">:</span> <span class="c1"># check we have a list </span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Expected list type argument for seqIdx&#39;</span><span class="p">)</span>
                
                <span class="c1">#sequentially go through and create sequences for each electrode string</span>
                <span class="n">qs</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">nseq</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seqIdx</span><span class="p">)</span> <span class="c1"># number of sequences (ie num of lines strings)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nseq</span><span class="p">):</span>
                    <span class="n">nelec</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seqIdx</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">slabels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">seqIdx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="c1"># string sequence labels</span>
                    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;custSeq&#39;</span><span class="p">:</span> <span class="c1"># ignore custSeq as already dealt with</span>
                            <span class="n">pok</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">))]</span> <span class="c1"># make sure all are int</span>
                            <span class="n">str_seq</span> <span class="o">=</span> <span class="n">fdico</span><span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]](</span><span class="n">nelec</span><span class="p">,</span> <span class="o">*</span><span class="n">pok</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="c1"># return np array </span>
                            <span class="n">qs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slabels</span><span class="p">[</span><span class="n">str_seq</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                            
                <span class="n">sequence</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">qs</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasElecString</span><span class="p">():</span>
                    <span class="c1"># if it&#39;s 3D, we need the line number for the sequence </span>
                    <span class="c1"># (so all electrode on line 1)</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sequence</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sequence</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                            <span class="n">sequence</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;1 &#39;</span><span class="o">+</span> <span class="n">sequence</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
   
                    
        <span class="k">else</span><span class="p">:</span> <span class="c1"># it&#39;s 2D </span>
            <span class="n">nelec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> 
            <span class="n">qs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;custSeq&#39;</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">qs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">addCustSeq</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;error when importing custom sequence:&#39;</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pok</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">))]</span> <span class="c1"># make sure all are int</span>
                    <span class="n">qs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fdico</span><span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]](</span><span class="n">nelec</span><span class="p">,</span> <span class="o">*</span><span class="n">pok</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
            <span class="n">sequence</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">qs</span><span class="p">)</span>
            
            <span class="c1"># detecing quadrupoles using out of bound electrodes</span>
            <span class="n">iabove</span> <span class="o">=</span> <span class="p">(</span><span class="n">sequence</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">sequence</span> <span class="o">=</span> <span class="n">sequence</span><span class="p">[</span><span class="o">~</span><span class="n">iabove</span><span class="p">,:]</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">sequence</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:d}</span><span class="s1"> quadrupoles generated.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sequence</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">seqIdx</span>
    
    <span class="k">def</span> <span class="nf">createSequenceXBH</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Custom scheme for boreholes (not yet developed)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>


    <span class="k">def</span> <span class="nf">saveSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Save sequence as .csv file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fname : str, optional</span>
<span class="sd">            Path where to save the sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sequence</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;m&#39;</span><span class="p">,</span><span class="s1">&#39;n&#39;</span><span class="p">])</span>
            <span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">line_terminator</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            

    <span class="k">def</span> <span class="nf">importElec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Import electrodes positions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fname : str</span>
<span class="sd">            Path of the CSV  (or file containing the electrodes positions. It </span>
<span class="sd">            should contains 3 columns maximum with the X, Y, Z positions </span>
<span class="sd">            of the electrodes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">fname</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.geom&#39;</span><span class="p">):</span> <span class="c1"># read in geometry file (special case) </span>
            <span class="n">elec</span> <span class="o">=</span> <span class="n">geomParser</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setElec</span><span class="p">(</span><span class="n">elec</span><span class="p">)</span>
            <span class="k">return</span> 
        
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="nb">float</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">header</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="n">header</span> <span class="o">=</span> <span class="s1">&#39;infer&#39;</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">header</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">elec</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">values</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">elec</span> <span class="o">=</span> <span class="n">df</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setElec</span><span class="p">(</span><span class="n">elec</span><span class="p">)</span>
                

    <span class="k">def</span> <span class="nf">importSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Import sequence for forward modelling.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fname : str</span>
<span class="sd">            Path of the CSV file to be imported. The file must have 4 columns with headers (a, b, m, n) containing 4 electrodes numbers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        
        <span class="c1">#check for headers </span>
        <span class="n">trigger</span> <span class="o">=</span> <span class="kc">False</span> 
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;m&#39;</span><span class="p">,</span><span class="s1">&#39;n&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Column &quot;</span><span class="si">%s</span><span class="s1">&quot; not in sequence file&#39;</span><span class="o">%</span><span class="n">a</span><span class="p">)</span>
                <span class="n">trigger</span> <span class="o">=</span><span class="kc">True</span> 
        <span class="k">if</span> <span class="n">trigger</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Missing headers in sequence file!&#39;</span><span class="p">)</span>
                
        <span class="k">if</span> <span class="n">seq</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The file should be a CSV file with headers (a, b, m, n) with exactly 4 columns with electrode numbers.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">seq</span>
            
        <span class="c1">#do check for electrode line numbers in the case of 3D </span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;t&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sequence</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="nb">str</span><span class="p">):</span> <span class="c1"># then add line numbers </span>
                <span class="c1"># print(&#39;adding line numbers&#39;)</span>
                <span class="n">surrogate</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
                <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
                <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
                <span class="n">m</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
                <span class="n">n</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)):</span>
                    <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;1 &#39;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;1 &#39;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;1 &#39;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="s1">&#39;m&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;1 &#39;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
                <span class="n">surrogate</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>
                <span class="n">surrogate</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>
                <span class="n">surrogate</span><span class="p">[</span><span class="s1">&#39;m&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span>
                <span class="n">surrogate</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">surrogate</span> 


    <span class="k">def</span> <span class="nf">saveErrorData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Save quadruople, resistance, phase and their respective reciprocal</span>
<span class="sd">        errors as .csv file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fname : str</span>
<span class="sd">            Path where to save the file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;m&#39;</span><span class="p">,</span><span class="s1">&#39;n&#39;</span><span class="p">,</span><span class="s1">&#39;resist&#39;</span><span class="p">,</span><span class="s1">&#39;recipMean&#39;</span><span class="p">,</span><span class="s1">&#39;recipError&#39;</span><span class="p">,</span><span class="s1">&#39;resError&#39;</span><span class="p">,</span>
                         <span class="s1">&#39;phase&#39;</span><span class="p">,</span><span class="s1">&#39;reci_IP_err&#39;</span><span class="p">,</span><span class="s1">&#39;phaseError&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iTimeLapse</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bigSurvey</span><span class="o">.</span><span class="n">df</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">df</span>
        <span class="n">ie</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">]</span>
        <span class="n">dff</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">cols</span><span class="p">[</span><span class="n">ie</span><span class="p">]]</span>
        <span class="n">dff</span> <span class="o">=</span> <span class="n">dff</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;resist&#39;</span><span class="p">:</span><span class="s1">&#39;Resistance [ohm]&#39;</span><span class="p">,</span> <span class="s1">&#39;recipError&#39;</span><span class="p">:</span><span class="s1">&#39;Resistance_err [ohm]&#39;</span><span class="p">,</span>
                                    <span class="s1">&#39;resError&#39;</span><span class="p">:</span><span class="s1">&#39;Fit Resistance_err [ohm]&#39;</span><span class="p">,</span><span class="s1">&#39;phase&#39;</span><span class="p">:</span><span class="s1">&#39;Phase [mRad]&#39;</span><span class="p">,</span>
                                    <span class="s1">&#39;reci_IP_err&#39;</span><span class="p">:</span><span class="s1">&#39;Phase_err [mRad]&#39;</span><span class="p">,</span><span class="s1">&#39;phaseError&#39;</span><span class="p">:</span><span class="s1">&#39;Fit Phase_err [mRad]&#39;</span><span class="p">})</span>
        <span class="n">dff</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">line_terminator</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">saveFilteredData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">savetyp</span><span class="o">=</span><span class="s1">&#39;Res2DInv (*.dat)&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Save filtered data in formats to be used outside ResIPy (e.g. Res2DInv).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fname : str</span>
<span class="sd">            Path where to save the file.</span>
<span class="sd">        savetyp : str, optional</span>
<span class="sd">            Saving format. To be determined in GUI. Default: Res2DInv (.dat)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">elec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="s1">&#39;z&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">spacing</span> <span class="o">=</span> <span class="n">elec</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">elec</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># TODO (gb) not sure if this is needed</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">))):</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s1">&#39;irecip &gt;=0&#39;</span><span class="p">)</span> <span class="c1"># not saving reciprocal data</span>
            <span class="c1"># if spacing == None:</span>
            <span class="c1">#     spacing = elec[1,0]-elec[0,0] # for batch surveys the spacing can differ and not follow user input</span>
            <span class="c1"># else:</span>
            <span class="c1">#     spacing = spacing</span>
            <span class="c1"># df[[&#39;a&#39;,&#39;b&#39;,&#39;m&#39;,&#39;n&#39;]] *= spacing</span>
            <span class="n">lookupDict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">))</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;m&#39;</span><span class="p">,</span><span class="s1">&#39;n&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">lookupDict</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;m&#39;</span><span class="p">,</span><span class="s1">&#39;n&#39;</span><span class="p">]):</span>
                <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="c1"># this way should avoid warnings </span>
            <span class="c1"># df.loc[:,[&#39;a&#39;,&#39;b&#39;,&#39;m&#39;,&#39;n&#39;]] = data</span>
            <span class="k">if</span> <span class="n">savetyp</span> <span class="o">==</span> <span class="s1">&#39;Res2DInv (*.dat)&#39;</span><span class="p">:</span>
                <span class="n">param</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;num_meas&#39;</span><span class="p">:</span> <span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                         <span class="s1">&#39;lineTitle&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;lineTitle&#39;</span><span class="p">],</span>
                         <span class="s1">&#39;spacing&#39;</span><span class="p">:</span> <span class="n">spacing</span><span class="p">}</span>
                <span class="n">write2Res2DInv</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">savetyp</span> <span class="o">==</span> <span class="s1">&#39;Comma Separated Values (*.csv)&#39;</span><span class="p">:</span>
                <span class="n">write2csv</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">savetyp</span> <span class="o">==</span> <span class="s1">&#39;E4D survey file (*.srv)&#39;</span><span class="p">:</span>
                <span class="n">writeSrv</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">elec</span><span class="p">)</span>

            <span class="n">fname</span> <span class="o">=</span> <span class="n">fname</span><span class="p">[:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="n">fname</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span> <span class="c1"># to iterate file numbers in case of timelapse survey</span>


    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">noise</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">noiseIP</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">iplot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dump</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Operates forward modelling.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        noise : float, optional 0% &lt;= noise &lt;= 100%</span>
<span class="sd">            Noise level in percent from a Gaussian distribution that should be</span>
<span class="sd">            applied on the forward apparent resistivities obtained.</span>
<span class="sd">        noiseIP : float, optional</span>
<span class="sd">            Absolute noise level in mrad from a Gaussian distribution that should be applied</span>
<span class="sd">            on the forward phase values obtained.</span>
<span class="sd">        iplot : bool, optional</span>
<span class="sd">            If `True` will plot the pseudo section after the forward modelling.</span>
<span class="sd">        dump : function, optional</span>
<span class="sd">            Function to print information messages when running the forward model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dump</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                
        <span class="n">fwdDir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="s1">&#39;fwd&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">fwdDir</span><span class="p">):</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">fwdDir</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">fwdDir</span><span class="p">)</span>

        <span class="c1"># no need to order the mesh in forward as zone and param are not read</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;res0&#39;</span><span class="p">])</span>
            <span class="n">phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;phase0&#39;</span><span class="p">])</span>
            <span class="n">centroids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">elmCentre</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">centroids2</span> <span class="o">=</span> <span class="n">centroids</span><span class="p">[:,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;t&#39;</span> <span class="k">else</span> <span class="n">centroids</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">centroids2</span><span class="p">,</span>
                      <span class="n">r</span><span class="p">,</span>
                      <span class="n">phase</span><span class="p">,</span> <span class="c1"># mrad</span>
                      <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">r</span><span class="p">),</span>
                      <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="o">-</span><span class="n">phase</span><span class="o">/</span><span class="mi">1000</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">r</span><span class="p">)),</span> <span class="c1">#log10(real conductivity)</span>
                      <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="o">-</span><span class="n">phase</span><span class="o">/</span><span class="mi">1000</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">r</span><span class="p">))]</span> <span class="c1">#log10(imaginary conductivity)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">fwdDir</span><span class="p">,</span> <span class="s1">&#39;resistivity.dat&#39;</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">writeAttr</span><span class="p">(</span><span class="s1">&#39;res0&#39;</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">fwdDir</span><span class="p">,</span><span class="s1">&#39;resistivity.dat&#39;</span><span class="p">))</span>

        <span class="c1"># write mesh.dat (no ordering of elements needed in forward mode)</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;R2&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;cR2&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">dat</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">fwdDir</span><span class="p">,</span> <span class="s1">&#39;mesh.dat&#39;</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">datAdv</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">fwdDir</span><span class="p">,</span> <span class="s1">&#39;mesh3d.dat&#39;</span><span class="p">),</span> <span class="n">iadvanced</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">iadvanced</span><span class="p">)</span>
            
        <span class="c1"># write the forward .in file</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">custSeq</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span> <span class="c1"># only in case of 3D custom sequence</span>
            <span class="c1"># replacing labels with &lt;1 elec_num&gt; for simplicity - ignoring the initial self.elec[&#39;label&#39;] values</span>
            <span class="n">ones</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">))</span>
            <span class="n">newLabels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">char</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">char</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">ones</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;1 &#39;</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ones</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">newLabels</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;node_elec&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">newLabels</span>
            
        <span class="n">dump</span><span class="p">(</span><span class="s1">&#39;Writing .in file and mesh.dat... &#39;</span><span class="p">)</span>
        <span class="n">fparam</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">fparam</span><span class="p">[</span><span class="s1">&#39;job_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">fparam</span><span class="p">[</span><span class="s1">&#39;num_regions&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">fparam</span><span class="p">[</span><span class="s1">&#39;res0File&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;resistivity.dat&#39;</span> <span class="c1"># just starting resistivity</span>
        
        <span class="n">write2in</span><span class="p">(</span><span class="n">fparam</span><span class="p">,</span> <span class="n">fwdDir</span><span class="p">,</span> <span class="n">typ</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">)</span>
        <span class="n">dump</span><span class="p">(</span><span class="s1">&#39;done</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="c1"># write the protocol.dat (that contains the sequence)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dump</span><span class="p">(</span><span class="s1">&#39;Creating sequence... &#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">createSequence</span><span class="p">()</span>
            <span class="n">dump</span><span class="p">(</span><span class="s1">&#39;done</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">dump</span><span class="p">(</span><span class="s1">&#39;Writing protocol.dat... &#39;</span><span class="p">)</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence</span>

        <span class="c1"># let&#39;s check if IP that we have a positive geometric factor</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="c1"># NOTE this doesn&#39;t work for borehole</span>
            <span class="n">lookupDict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
            <span class="n">seqdf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="s1">&#39;n&#39;</span><span class="p">})</span>
            <span class="n">array</span> <span class="o">=</span> <span class="n">seqdf</span><span class="p">[[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;m&#39;</span><span class="p">,</span><span class="s1">&#39;n&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">lookupDict</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">elec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="s1">&#39;z&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            
            <span class="n">aposx</span> <span class="o">=</span> <span class="n">elec</span><span class="p">[:,</span><span class="mi">0</span><span class="p">][</span><span class="n">array</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">aposy</span> <span class="o">=</span> <span class="n">elec</span><span class="p">[:,</span><span class="mi">1</span><span class="p">][</span><span class="n">array</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">aposz</span> <span class="o">=</span> <span class="n">elec</span><span class="p">[:,</span><span class="mi">2</span><span class="p">][</span><span class="n">array</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]]</span>
            
            <span class="n">bposx</span> <span class="o">=</span> <span class="n">elec</span><span class="p">[:,</span><span class="mi">0</span><span class="p">][</span><span class="n">array</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">bposy</span> <span class="o">=</span> <span class="n">elec</span><span class="p">[:,</span><span class="mi">1</span><span class="p">][</span><span class="n">array</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">bposz</span> <span class="o">=</span> <span class="n">elec</span><span class="p">[:,</span><span class="mi">2</span><span class="p">][</span><span class="n">array</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]]</span>
            
            <span class="n">mposx</span> <span class="o">=</span> <span class="n">elec</span><span class="p">[:,</span><span class="mi">0</span><span class="p">][</span><span class="n">array</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]]</span>
            <span class="n">mposy</span> <span class="o">=</span> <span class="n">elec</span><span class="p">[:,</span><span class="mi">1</span><span class="p">][</span><span class="n">array</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]]</span>
            <span class="n">mposz</span> <span class="o">=</span> <span class="n">elec</span><span class="p">[:,</span><span class="mi">2</span><span class="p">][</span><span class="n">array</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]]</span>
            
            <span class="n">nposx</span> <span class="o">=</span> <span class="n">elec</span><span class="p">[:,</span><span class="mi">0</span><span class="p">][</span><span class="n">array</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]]</span>
            <span class="n">nposy</span> <span class="o">=</span> <span class="n">elec</span><span class="p">[:,</span><span class="mi">1</span><span class="p">][</span><span class="n">array</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]]</span>
            <span class="n">nposz</span> <span class="o">=</span> <span class="n">elec</span><span class="p">[:,</span><span class="mi">2</span><span class="p">][</span><span class="n">array</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]]</span>
            
            <span class="n">AM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">aposx</span><span class="o">-</span><span class="n">mposx</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">aposy</span><span class="o">-</span><span class="n">mposy</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">aposz</span><span class="o">-</span><span class="n">mposz</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">BM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">bposx</span><span class="o">-</span><span class="n">mposx</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">bposy</span><span class="o">-</span><span class="n">mposy</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">bposz</span><span class="o">-</span><span class="n">mposz</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">AN</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">aposx</span><span class="o">-</span><span class="n">nposx</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">aposy</span><span class="o">-</span><span class="n">nposy</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">aposz</span><span class="o">-</span><span class="n">nposz</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">BN</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">bposx</span><span class="o">-</span><span class="n">nposx</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">bposy</span><span class="o">-</span><span class="n">nposy</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">bposz</span><span class="o">-</span><span class="n">nposz</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            
            <span class="n">K</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="p">((</span><span class="mi">1</span><span class="o">/</span><span class="n">AM</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">BM</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">AN</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">BN</span><span class="p">))</span> <span class="c1"># geometric factor</span>
            
            <span class="n">ie</span> <span class="o">=</span> <span class="n">K</span> <span class="o">&lt;</span> <span class="mi">0</span>
            <span class="n">seq2</span> <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">seq</span><span class="p">[</span><span class="n">ie</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">seq2</span><span class="p">[</span><span class="n">ie</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="c1"># swap if K is &lt; 0</span>
            <span class="n">seq</span><span class="p">[</span><span class="n">ie</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">seq2</span><span class="p">[</span><span class="n">ie</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
            
        <span class="n">protocol</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="mi">1</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">seq</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="n">seq</span><span class="p">],</span>
                                <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;m&#39;</span><span class="p">,</span><span class="s1">&#39;n&#39;</span><span class="p">])</span>
        
        <span class="c1"># if it&#39;s 3D, we add the line number (all electrode on line 1)</span>
        <span class="k">if</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;R3t&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;cR3t&#39;</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">protocol</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">())</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># we don&#39;t have string number</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;m&#39;</span><span class="p">,</span><span class="s1">&#39;n&#39;</span><span class="p">]:</span> 
                    <span class="n">protocol</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;1 &#39;</span> <span class="o">+</span> <span class="n">protocol</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
        
        <span class="n">outputname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">fwdDir</span><span class="p">,</span> <span class="s1">&#39;protocol.dat&#39;</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">outputname</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">protocol</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">outputname</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">protocol</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">line_terminator</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">dump</span><span class="p">(</span><span class="s1">&#39;done</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="c1"># fun the inversion</span>
        <span class="n">dump</span><span class="p">(</span><span class="s1">&#39;Running forward model... &#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">runR2</span><span class="p">(</span><span class="n">fwdDir</span><span class="p">,</span> <span class="n">dump</span><span class="o">=</span><span class="n">dump</span><span class="p">)</span> <span class="c1"># this will copy the R2.exe inside as well</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iForward</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># create a protocol.dat file (overwrite the method)</span>
        <span class="k">def</span> <span class="nf">addnoise</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mf">0.05</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">level</span>

        <span class="k">def</span> <span class="nf">addnoiseIP</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">level</span>

        <span class="n">addnoise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">addnoise</span><span class="p">)</span>
        <span class="n">addnoiseIP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">addnoiseIP</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">noise</span> <span class="o">=</span> <span class="n">noise</span> <span class="c1"># percentage noise e.g. 5 -&gt; 5% noise</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">noiseIP</span> <span class="o">=</span> <span class="n">noiseIP</span> <span class="c1">#absolute noise in mrad, following convention of cR2</span>
        
        <span class="n">fmd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fmd</span><span class="c1">#.copy()</span>
        <span class="n">elec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;t&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasElecString</span><span class="p">():</span>
            <span class="c1">#need to add elec strings to labels if in 3D</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">elec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">elec</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s1">&#39;label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;1 &#39;</span> <span class="o">+</span> <span class="n">elec</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># need to flush it (so no timeLapse forward)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">createSurvey</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">fwdDir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">+</span> <span class="s1">&#39;_forward.dat&#39;</span><span class="p">),</span> 
                              <span class="n">ftype</span><span class="o">=</span><span class="s1">&#39;forwardProtocolIP&#39;</span><span class="p">,</span>
                              <span class="n">compRecip</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="c1"># dont compute reciprocals as that will be done after adding noise (see lines below)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">createSurvey</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">fwdDir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">+</span> <span class="s1">&#39;_forward.dat&#39;</span><span class="p">),</span> 
                              <span class="n">ftype</span><span class="o">=</span><span class="s1">&#39;forwardProtocolDC&#39;</span><span class="p">,</span>
                              <span class="n">compRecip</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            
        <span class="c1"># NOTE the &#39;ip&#39; columns here is in PHASE not in chargeability</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">kFactor</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># kFactor by default is = 1 now, though wouldn&#39;t hurt to have this here!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;resist&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">addnoise</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;resist&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="o">/</span><span class="mi">100</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;ip&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">addnoiseIP</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;ip&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">noiseIP</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">computeReciprocal</span><span class="p">()</span> <span class="c1"># to recreate the other columns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setElec</span><span class="p">(</span><span class="n">elec</span><span class="p">)</span> <span class="c1"># using R2.createSurvey() overwrite self.elec so we need to set it back</span>
        <span class="c1"># self.fmd = fmd      </span>

        <span class="c1"># recompute doi (don&#39;t actually otherwise zlim is jumping)</span>
        <span class="c1"># self.computeFineMeshDepth()</span>
        <span class="c1"># self.zlim[0] = np.min(elec[&#39;z&#39;]) - self.fmd</span>
        <span class="k">if</span> <span class="n">iplot</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">showPseudo</span><span class="p">()</span>
        <span class="n">dump</span><span class="p">(</span><span class="s1">&#39;Forward modelling done.&#39;</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">saveForwardModelResult</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">fname</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the result of a forward model run to a specific file name/ </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fname : str</span>
<span class="sd">            path to file. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iForward</span><span class="p">:</span> 
            <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">write2protocol</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;No forward model has been run!&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">createModelErrorMesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create an homogeneous mesh to compute modelling error.</span>

<span class="sd">        Same arguments as `R2.createMesh()`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># backup</span>
        <span class="n">elecZ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">zlim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zlim</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># create FLAT homogeneous mesh </span>
        <span class="k">if</span> <span class="s1">&#39;2&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">:</span> <span class="c1"># normalise to flat surface if 2D            </span>
            <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;remote&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">==</span> <span class="kc">False</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;buried&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">==</span> <span class="kc">False</span><span class="p">)</span>
            <span class="n">ez</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">ex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">ez_tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span><span class="n">ex</span><span class="p">,</span><span class="n">ez</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ez_tmp</span>
            
        <span class="c1"># self.elec[&#39;z&#39;] = 0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">createMesh</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">modErrMesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">modErrMeshNE</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;node_elec&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;num_regions&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="c1"># restore</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">elecZ</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zlim</span> <span class="o">=</span> <span class="n">zlim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param</span> <span class="o">=</span> <span class="n">param</span>
        

    <span class="k">def</span> <span class="nf">estimateError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a_wgt</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">b_wgt</span><span class="o">=</span><span class="mf">0.02</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Estimate reciprocal error data for data with no reciprocals for each</span>
<span class="sd">        survey, using the same routine present in R2. This allows for the </span>
<span class="sd">        additional inclusion of modelling errors. It could be used when the user</span>
<span class="sd">        want to assign invidual errors based on a_wgt/b_wgt. This action is irreversable.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        a_wgt: float, optional</span>
<span class="sd">            a_wgt documented in the R2 documentation</span>
<span class="sd">        b_wgt: float, optional</span>
<span class="sd">            b_wgt documented in the R2 documentation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">:</span>
            <span class="n">s</span><span class="o">.</span><span class="n">estimateError</span><span class="p">(</span><span class="n">a_wgt</span><span class="o">=</span><span class="n">a_wgt</span><span class="p">,</span> <span class="n">b_wgt</span><span class="o">=</span><span class="n">b_wgt</span><span class="p">)</span>
            

    <span class="k">def</span> <span class="nf">addFlatError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">percent</span><span class="o">=</span><span class="mf">2.5</span><span class="p">):</span><span class="c1"># TODO (gb) why would we want that? - see below (jb)</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add a flat percentage error to resistivity data (for each survey in</span>
<span class="sd">        the class). This action is irreversable. Use case is for simulating </span>
<span class="sd">        modelling errors in unconventional surveys. </span>

<span class="sd">        resError = res*(percent/100) + resError</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        percent : float</span>
<span class="sd">            Error in percent.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">:</span>
            <span class="n">s</span><span class="o">.</span><span class="n">addPerError</span><span class="p">(</span><span class="n">percent</span><span class="p">)</span>
            

    <span class="k">def</span> <span class="nf">computeModelError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rmTree</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute modelling error associated with the mesh.</span>
<span class="sd">        This is computed on a flat triangular or tetrahedral mesh.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rmTree : bool</span>
<span class="sd">            Remove the working directory used for the error modelling. Default</span>
<span class="sd">            is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node_elec</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># we need this as the node_elec with topo and without might be different</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span> <span class="c1"># so we have topography</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;New mesh created with flat topo...&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="n">meshParams</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshParams</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="s1">&#39;3&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">:</span><span class="c1">#change interp method </span>
                <span class="n">meshParams</span><span class="p">[</span><span class="s1">&#39;interp_method&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># dont do any interpolation </span>
            <span class="k">if</span> <span class="s1">&#39;geom_input&#39;</span> <span class="ow">in</span> <span class="n">meshParams</span><span class="p">:</span> <span class="c1"># dont use geometry from here because it&#39;ll likley be incompatible on the flat mesh</span>
                <span class="n">meshParams</span><span class="p">[</span><span class="s1">&#39;geom_input&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">createModelErrorMesh</span><span class="p">(</span><span class="o">**</span><span class="n">meshParams</span><span class="p">)</span>
            <span class="n">node_elec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">modErrMeshNE</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">modErrMesh</span> <span class="c1"># create flat mesh</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="c1"># use same mesh</span>

        <span class="c1"># create working directory</span>
        <span class="n">fwdDir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="s1">&#39;err&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">fwdDir</span><span class="p">):</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">fwdDir</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">fwdDir</span><span class="p">)</span>

        <span class="c1"># write the resistivity.dat and fparam</span>
        <span class="n">fparam</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">fparam</span><span class="p">[</span><span class="s1">&#39;job_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">centroids</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">elmCentre</span>
        
        <span class="c1">#below block not needed now R2 reads in .dat files for quad mesh </span>
        <span class="c1"># if self.param[&#39;mesh_type&#39;] == 6:</span>
        <span class="c1">#     fparam[&#39;num_regions&#39;] = 1</span>
        <span class="c1">#     maxElem = centroids.shape[0]</span>
        <span class="c1">#     fparam[&#39;regions&#39;] = np.array([[1, maxElem, 100]])</span>
        <span class="c1"># else:</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;R2&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;cR2&#39;</span><span class="p">):</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;mesh.dat&#39;</span>
            <span class="n">file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">fwdDir</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="n">mesh</span><span class="o">.</span><span class="n">dat</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">3</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;mesh3d.dat&#39;</span>
            <span class="n">file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">fwdDir</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="n">mesh</span><span class="o">.</span><span class="n">datAdv</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">iadvanced</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">iadvanced</span><span class="p">)</span> <span class="c1"># use advanced mesh format if 3D </span>
        <span class="c1">#make starting resistivity file </span>
        <span class="n">resFile</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">centroids</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="c1"># centroid x, y, z, res0</span>
        <span class="n">resFile</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span>
        <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">fwdDir</span><span class="p">,</span> <span class="s1">&#39;resistivity.dat&#39;</span><span class="p">),</span> <span class="n">resFile</span><span class="p">,</span>
                   <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%.3f</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">node_elec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># then we need to overwrite it</span>
            <span class="n">fparam</span><span class="p">[</span><span class="s1">&#39;node_elec&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_elec</span>
        <span class="n">fparam</span><span class="p">[</span><span class="s1">&#39;num_regions&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">fparam</span><span class="p">[</span><span class="s1">&#39;res0File&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;resistivity.dat&#39;</span>
        
        <span class="n">write2in</span><span class="p">(</span><span class="n">fparam</span><span class="p">,</span> <span class="n">fwdDir</span><span class="p">,</span> <span class="n">typ</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">)</span>

        <span class="c1"># write the protocol.dat based on measured sequence</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">df</span><span class="p">[[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;m&#39;</span><span class="p">,</span><span class="s1">&#39;n&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># multiple survey here</span>
            <span class="n">seq</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">:</span>
                <span class="n">seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="p">[[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;m&#39;</span><span class="p">,</span><span class="s1">&#39;n&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            <span class="n">seq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
            <span class="n">seq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">protocol</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="mi">1</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">seq</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="n">seq</span><span class="p">],</span>
                                <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;m&#39;</span><span class="p">,</span><span class="s1">&#39;n&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;R3t&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;cR3t&#39;</span><span class="p">):</span> <span class="c1"># it&#39;s a 3D survey</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">protocol</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">())</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># we don&#39;t have string number</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;m&#39;</span><span class="p">,</span><span class="s1">&#39;n&#39;</span><span class="p">]:</span> 
                    <span class="n">protocol</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;1 &#39;</span> <span class="o">+</span> <span class="n">protocol</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
            <span class="c1"># protocol.insert(1, &#39;sa&#39;, 1)</span>
            <span class="c1"># protocol.insert(3, &#39;sb&#39;, 1)</span>
            <span class="c1"># protocol.insert(5, &#39;sm&#39;, 1)</span>
            <span class="c1"># protocol.insert(7, &#39;sn&#39;, 1)</span>
        <span class="n">outputname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">fwdDir</span><span class="p">,</span> <span class="s1">&#39;protocol.dat&#39;</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">outputname</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">protocol</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">outputname</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">protocol</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">line_terminator</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="c1"># run the inversion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">runR2</span><span class="p">(</span><span class="n">fwdDir</span><span class="p">)</span> <span class="c1"># this will copy the R2.exe inside as well</span>

        <span class="c1"># get error model</span>
        <span class="c1"># if (self.typ == &#39;R3t&#39;) | (self.typ == &#39;cR3t&#39;):</span>
        <span class="c1">#     try:</span>
            <span class="c1"># x = np.genfromtxt(os.path.join(fwdDir, self.typ + &#39;_forward.dat&#39;), skip_header=0)</span>
        <span class="c1">#     except:#try just reading in the last 2 columns instead</span>
        <span class="c1">#         fh = open(os.path.join(fwdDir, self.typ + &#39;.fwd&#39;))</span>
        <span class="c1">#         no_meas = len(protocol)</span>
        <span class="c1">#         trans_res = [0]*no_meas</span>
        <span class="c1">#         app_res = [0]*no_meas</span>
        <span class="c1">#         for i in range(no_meas):</span>
        <span class="c1">#             line = fh.readline().split()</span>
        <span class="c1">#             trans_res[i] = float(line[-2])</span>
        <span class="c1">#             app_res[i] = float(line[-1])</span>
        <span class="c1">#         x = np.array((trans_res,app_res)).T</span>
        <span class="c1">#         fh.close()</span>

        <span class="c1"># else:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">fwdDir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">+</span> <span class="s1">&#39;_forward.dat&#39;</span><span class="p">),</span> <span class="n">skip_header</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">modErr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="mi">100</span><span class="o">-</span><span class="n">x</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mi">100</span>
        <span class="n">dferr</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;m&#39;</span><span class="p">,</span><span class="s1">&#39;n&#39;</span><span class="p">])</span>
        <span class="n">dferr</span><span class="p">[</span><span class="s1">&#39;modErr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">modErr</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;modErr&#39;</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="p">:</span>
                <span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;modErr&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">s</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">dferr</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;m&#39;</span><span class="p">,</span><span class="s1">&#39;n&#39;</span><span class="p">],</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;inner&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">rmTree</span><span class="p">:</span><span class="c1"># eventually delete the directory to spare space</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">fwdDir</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fwdErrModel</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># class now has a forward error model.</span>



    <span class="k">def</span> <span class="nf">showIter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">modelDOI</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cropMaxDepth</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Dispay temporary inverted section after each iteration.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int, optional</span>
<span class="sd">            Iteration number to show.</span>
<span class="sd">        ax : matplotib axis, optional</span>
<span class="sd">            If specified, the graph will be plotted along `ax`.</span>
<span class="sd">        modelDOI : bool, optional</span>
<span class="sd">            As modelDOI() is always computed using R2 (not cR2), this tells the</span>
<span class="sd">            method to look for an R2 looking iteration file.</span>
<span class="sd">        cropMaxDepth : bool, optional</span>
<span class="sd">            if True, below max depth will be cropped</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">figure</span>
        <span class="n">files</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">)</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="o">-</span><span class="mi">8</span><span class="p">:]</span> <span class="o">==</span> <span class="s1">&#39;_res.dat&#39;</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">==</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">==</span> <span class="mi">12</span><span class="p">)):</span>
                <span class="n">fs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

        <span class="n">fs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># the last file is always open and not filled with data</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="n">fs</span><span class="p">[</span><span class="n">index</span><span class="p">]),</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">delim_whitespace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;t&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;buried&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="c1"># if 3D get the iteration mesh - and no buried electrodes [HOT FIX] #TODO: extract 3D xbh top surface</span>
                <span class="k">try</span><span class="p">:</span> <span class="c1"># let it pass if surface extraction failed for showing iteration plot</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">surfaceIdx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># no surface index</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">iterMesh</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">readMesh</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="n">fs</span><span class="p">[</span><span class="n">index</span><span class="p">])</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.dat&#39;</span><span class="p">,</span><span class="s1">&#39;.vtk&#39;</span><span class="p">))</span> 
                        <span class="n">_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">surfaceIdx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterMesh</span><span class="o">.</span><span class="n">extractSurface</span><span class="p">(</span><span class="n">return_idx</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># get surface index </span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">surfaceIdx</span><span class="p">,:]</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">pass</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span> <span class="c1"># sometimes i have this part to fail, not sure why</span>
                    <span class="n">triang</span> <span class="o">=</span> <span class="n">tri</span><span class="o">.</span><span class="n">Triangulation</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Failed to plot iteration mesh&#39;</span><span class="p">)</span>
                    <span class="k">return</span> <span class="c1"># if the triangulation fails then fall out of function </span>
                
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;c&#39;</span> <span class="ow">and</span> <span class="n">modelDOI</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="n">z</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span><span class="mi">4</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">z</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]</span> <span class="c1"># modelDOI is always computed with R2 not cR2</span>

                <span class="n">cax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">tricontourf</span><span class="p">(</span><span class="n">triang</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">extend</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;R2&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;cR2&#39;</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;topot&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">topo</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;elec&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;buried&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
                    <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">topo</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;buried&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                        <span class="c1"># just checking we don&#39;t have a whole space mesh</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_clipContour</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">cax</span><span class="o">.</span><span class="n">collections</span><span class="p">,</span> <span class="n">cropMaxDepth</span><span class="p">)</span>
                <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">cax</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$\log_</span><span class="si">{10}</span><span class="s1">\rho$ [$\Omega$.m]&#39;</span><span class="p">)</span>
                <span class="n">elec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">[</span><span class="s1">&#39;remote&#39;</span><span class="p">]][[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="s1">&#39;z&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;t&#39;</span><span class="p">:</span> <span class="c1"># adjust for 3D </span>
                    <span class="n">yelec</span> <span class="o">=</span> <span class="n">elec</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">ylabel</span> <span class="o">=</span> <span class="s1">&#39;Distance [m]&#39;</span>
                    <span class="n">ylim</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">elec</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">elec</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">yelec</span> <span class="o">=</span> <span class="n">elec</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span>
                    <span class="n">ylabel</span> <span class="o">=</span> <span class="s1">&#39;Elevation [m]&#39;</span>
                    <span class="n">ylim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zlim</span>
                    
                <span class="n">elecColor</span> <span class="o">=</span> <span class="s1">&#39;ko&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">darkMode</span> <span class="ow">is</span> <span class="kc">False</span> <span class="k">else</span> <span class="s1">&#39;wo&#39;</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">elec</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">yelec</span><span class="p">,</span> <span class="n">elecColor</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Distance [m]&#39;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">ylabel</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">elec</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">elec</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])])</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">ylim</span><span class="p">)</span>



    <span class="k">def</span> <span class="nf">saveInvPlots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outputdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Save all plots to output (or working directory). Parameters</span>
<span class="sd">        are passed to the `showResults()` method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        outputdir : str, optional</span>
<span class="sd">            Path of the output directory. Default is the working directory.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">outputdir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">outputdir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dirname</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meshResults</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getResults</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meshResults</span><span class="p">)):</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">showResults</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshResults</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">mesh_title</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outputdir</span><span class="p">,</span> <span class="n">fname</span> <span class="o">+</span> <span class="s1">&#39;.png&#39;</span><span class="p">))</span>
        
    
    <span class="k">def</span> <span class="nf">getInvError</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iTimeLapse</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;cR2&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;R2&#39;</span><span class="p">:</span>
                <span class="n">dfs</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iTimeLapse</span><span class="p">:</span>
                    <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="s1">&#39;ref/f001_err.dat&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>                    
                        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">delim_whitespace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="n">dfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">)</span><span class="o">-</span><span class="n">a</span><span class="p">):</span>
                    <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="s1">&#39;f</span><span class="si">{:03.0f}</span><span class="s1">_err.dat&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
                        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">delim_whitespace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="n">dfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;R3t&#39;</span><span class="p">:</span>
                <span class="n">dfs</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iTimeLapse</span><span class="p">:</span>
                    <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="s1">&#39;ref/f001_err.dat&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
                        <span class="n">err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">skip_header</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">err</span><span class="p">[:,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">]],</span>
                                          <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;sa&#39;</span><span class="p">,</span><span class="s1">&#39;P+&#39;</span><span class="p">,</span><span class="s1">&#39;sb&#39;</span><span class="p">,</span><span class="s1">&#39;P-&#39;</span><span class="p">,</span><span class="s1">&#39;sm&#39;</span><span class="p">,</span><span class="s1">&#39;C+&#39;</span><span class="p">,</span><span class="s1">&#39;sn&#39;</span><span class="p">,</span><span class="s1">&#39;C-&#39;</span><span class="p">,</span> <span class="s1">&#39;Normalised_Error&#39;</span><span class="p">])</span>
                        <span class="n">dfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">)</span><span class="o">-</span><span class="n">a</span><span class="p">):</span>
                    <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="s1">&#39;f</span><span class="si">{:03.0f}</span><span class="s1">_err.dat&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
                        <span class="n">err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">skip_header</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">err</span><span class="p">[:,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">]],</span>
                                          <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;sa&#39;</span><span class="p">,</span><span class="s1">&#39;P+&#39;</span><span class="p">,</span><span class="s1">&#39;sb&#39;</span><span class="p">,</span><span class="s1">&#39;P-&#39;</span><span class="p">,</span><span class="s1">&#39;sm&#39;</span><span class="p">,</span><span class="s1">&#39;C+&#39;</span><span class="p">,</span><span class="s1">&#39;sn&#39;</span><span class="p">,</span><span class="s1">&#39;C-&#39;</span><span class="p">,</span> <span class="s1">&#39;Normalised_Error&#39;</span><span class="p">])</span>
                        <span class="n">dfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="p">);</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># TODO cR3t header needs to be standardized</span>
                <span class="n">dfs</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iTimeLapse</span><span class="p">:</span>
                    <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="s1">&#39;ref/f001_err.dat&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
                        <span class="n">err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">skip_header</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">err</span><span class="p">[:,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">]],</span>
                                          <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;sa&#39;</span><span class="p">,</span><span class="s1">&#39;P+&#39;</span><span class="p">,</span><span class="s1">&#39;sb&#39;</span><span class="p">,</span><span class="s1">&#39;P-&#39;</span><span class="p">,</span><span class="s1">&#39;sm&#39;</span><span class="p">,</span><span class="s1">&#39;C+&#39;</span><span class="p">,</span><span class="s1">&#39;sn&#39;</span><span class="p">,</span><span class="s1">&#39;C-&#39;</span><span class="p">,</span> <span class="s1">&#39;Normalised_Error&#39;</span><span class="p">,</span> <span class="s1">&#39;Observed_Phase&#39;</span><span class="p">,</span> <span class="s1">&#39;Calculated_Phase&#39;</span><span class="p">])</span>
                        <span class="n">dfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">)</span><span class="o">-</span><span class="n">a</span><span class="p">):</span>
                    <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="s1">&#39;f</span><span class="si">{:03.0f}</span><span class="s1">_err.dat&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
                        <span class="n">err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">skip_header</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">err</span><span class="p">[:,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">]],</span>
                                          <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;sa&#39;</span><span class="p">,</span><span class="s1">&#39;P+&#39;</span><span class="p">,</span><span class="s1">&#39;sb&#39;</span><span class="p">,</span><span class="s1">&#39;P-&#39;</span><span class="p">,</span><span class="s1">&#39;sm&#39;</span><span class="p">,</span><span class="s1">&#39;C+&#39;</span><span class="p">,</span><span class="s1">&#39;sn&#39;</span><span class="p">,</span><span class="s1">&#39;C-&#39;</span><span class="p">,</span> <span class="s1">&#39;Normalised_Error&#39;</span><span class="p">,</span> <span class="s1">&#39;Observed_Phase&#39;</span><span class="p">,</span> <span class="s1">&#39;Calculated_Phase&#39;</span><span class="p">])</span>
                        <span class="n">dfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
                        
            <span class="n">dfs2</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">check</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># check if first value of survey frames are in line number and electrode fmt </span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">())</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">check</span> <span class="o">=</span> <span class="kc">False</span> 
            <span class="k">for</span> <span class="n">df</span> <span class="ow">in</span> <span class="n">dfs</span><span class="p">:</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">astype</span><span class="p">({</span><span class="s1">&#39;P+&#39;</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;P-&#39;</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;C+&#39;</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;C-&#39;</span><span class="p">:</span><span class="nb">int</span><span class="p">})</span>
                <span class="k">if</span> <span class="n">check</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;R3t&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;cR3t&#39;</span><span class="p">):</span>
                    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">astype</span><span class="p">({</span><span class="s1">&#39;sa&#39;</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;sb&#39;</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;sm&#39;</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;sn&#39;</span><span class="p">:</span><span class="nb">int</span><span class="p">})</span>
                    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;P+&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;sa&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;P+&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
                    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;P-&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;sb&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;P-&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
                    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;C+&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;sm&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;C+&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
                    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;C-&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;sn&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;C-&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">astype</span><span class="p">({</span><span class="s1">&#39;P+&#39;</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="s1">&#39;P-&#39;</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="s1">&#39;C+&#39;</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="s1">&#39;C-&#39;</span><span class="p">:</span><span class="nb">str</span><span class="p">})</span>
                <span class="n">dfs2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
            <span class="n">dfs</span> <span class="o">=</span> <span class="n">dfs2</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">return</span> <span class="c1"># this code is error prone (mainly to empty dataframe error)</span>
        <span class="c1"># merge the columns to each survey dataframe</span>
        <span class="k">if</span>  <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">df</span> <span class="ow">in</span> <span class="n">dfs</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;error in reading error files (do not exists or empty&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="c1"># this check the number of dfs AND the fact that they are not empty</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">df</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">,</span> <span class="n">dfs</span><span class="p">):</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">([</span><span class="s1">&#39;P+&#39;</span><span class="p">,</span><span class="s1">&#39;P-&#39;</span><span class="p">,</span><span class="s1">&#39;C+&#39;</span><span class="p">,</span><span class="s1">&#39;C-&#39;</span><span class="p">,</span> <span class="s1">&#39;Normalised_Error&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;m&#39;</span><span class="p">,</span><span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="s1">&#39;resInvError&#39;</span><span class="p">])))</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;m&#39;</span><span class="p">,</span><span class="s1">&#39;n&#39;</span><span class="p">,</span><span class="s1">&#39;resInvError&#39;</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;cR2&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;cR3t&#39;</span><span class="p">):</span>
                <span class="n">df</span><span class="p">[</span><span class="s1">&#39;phaseInvMisfit&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;Observed_Phase&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;Calculated_Phase&#39;</span><span class="p">])</span>
                <span class="n">cols</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;phaseInvMisfit&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="s1">&#39;resInvError&#39;</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">s</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;resInvError&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;phaseInvMisfit&#39;</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">s</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;phaseInvMisfit&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">s</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">df</span><span class="p">[</span><span class="n">cols</span><span class="p">],</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;m&#39;</span><span class="p">,</span><span class="s1">&#39;n&#39;</span><span class="p">],</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>
            <span class="n">s</span><span class="o">.</span><span class="n">dfInvErrOutputOrigin</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># for being able to reset post processing filters</span>

                    

    <span class="k">def</span> <span class="nf">showPseudoInvError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">elec</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot pseudo section of errors from file `f001_err.dat`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int, optional</span>
<span class="sd">            Index of the survey (if time-lapse or batch). Default `index == 0`.</span>
<span class="sd">        ax : matplotlib axis</span>
<span class="sd">            If specified, the graph will be plotted against `ax`.</span>
<span class="sd">        vmin : float, optional</span>
<span class="sd">            Min value.</span>
<span class="sd">        vmax : float, optional</span>
<span class="sd">            Max value.</span>
<span class="sd">        elec : bool, optional</span>
<span class="sd">            If `True`, the electrodes are displayed and can be used for filtering.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">filterManual</span><span class="p">(</span><span class="n">attr</span><span class="o">=</span><span class="s1">&#39;resInvError&#39;</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">,</span>
                    <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Normalised Error&#39;</span><span class="p">,</span> <span class="n">elec</span><span class="o">=</span><span class="n">elec</span><span class="p">,</span> <span class="n">darkMode</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">darkMode</span><span class="p">)</span>



    <span class="k">def</span> <span class="nf">showPseudoInvErrorIP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Display normalized phase error.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int, optional</span>
<span class="sd">            Index of the survey (if time-lapse or batch). Default `index == 0`.</span>
<span class="sd">        ax : matplotlib axis</span>
<span class="sd">            If specified, the graph will be plotted against `ax`.</span>
<span class="sd">        vmin : float, optional</span>
<span class="sd">            Min value.</span>
<span class="sd">        vmax : float, optional</span>
<span class="sd">            Max value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">filterManual</span><span class="p">(</span><span class="n">attr</span><span class="o">=</span><span class="s1">&#39;phaseInvMisfit&#39;</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">,</span>
                    <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Phase misfit [mrad]&#39;</span><span class="p">,</span> <span class="n">darkMode</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">darkMode</span><span class="p">)</span>
        

    <span class="k">def</span> <span class="nf">showInvError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Display inversion error by measurment numbers.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int, optional</span>
<span class="sd">            Index of survey (if time-lapse or batch). Default `index == 0`.</span>
<span class="sd">        ax : matplotlib axis</span>
<span class="sd">            If provided, the graph will be plotted against this axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">errors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;resInvError&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">errors</span> <span class="o">=</span> <span class="n">errors</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">errors</span><span class="p">)]</span>
        <span class="n">measurement_no</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">errors</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1">#make figure</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">measurement_no</span><span class="p">,</span><span class="n">errors</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Normalised Error&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Measurement Number&quot;</span><span class="p">)</span>
        <span class="c1">#add diagnositic lines</span>
        <span class="n">y_pos_limit</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">y_neg_limit</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">baseline</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">measurement_no</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span><span class="n">y_pos_limit</span><span class="p">,</span><span class="s1">&#39;r--&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">measurement_no</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span><span class="n">y_neg_limit</span><span class="p">,</span><span class="s1">&#39;r--&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">measurement_no</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span><span class="n">baseline</span><span class="p">,</span><span class="s1">&#39;--&#39;</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">filterInvError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove measurements where inversion error is outside of the defined range.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vmin : float, optional</span>
<span class="sd">            minimum value of normalized error below which data will be discarded.</span>
<span class="sd">        vmax : float, optional</span>
<span class="sd">            maximum value of normalized error above which data will be discarded.</span>
<span class="sd">        index : int, optional</span>
<span class="sd">            Index of the survey to process. If `index == -1` (default) then the</span>
<span class="sd">            processing is applied on all survey independantly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">:</span>
                <span class="n">s</span><span class="o">.</span><span class="n">filterInvError</span><span class="p">(</span><span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">filterInvError</span><span class="p">(</span><span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">)</span> 
        
        
    <span class="k">def</span> <span class="nf">saveMeshVtk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outputname</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Save mesh as .vtk to be viewed in paraview.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        outputname : str, optional</span>
<span class="sd">            Output path of the .vtk produced. By default the mesh is saved in</span>
<span class="sd">            the working directory `self.dirname` as `mesh.vtk`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;The function is deprecated, use saveMesh() instead.&#39;</span><span class="p">,</span>
                      <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">outputname</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">outputname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="s1">&#39;mesh.vtk&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vtk</span><span class="p">(</span><span class="n">outputname</span><span class="p">)</span>



    <span class="k">def</span> <span class="nf">saveMesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outputname</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Save mesh as .vtk to be viewed in paraview.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        outputname : str, optional</span>
<span class="sd">            Output path with extension. Available mesh format are:</span>
<span class="sd">                - .vtk (Paraview)</span>
<span class="sd">                - .node (Tetgen)</span>
<span class="sd">                - .dat (R* codes)</span>
<span class="sd">            If not provided the mesh is saved in the working directory</span>
<span class="sd">            as mesh.vtk.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">outputname</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vtk</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="s1">&#39;mesh.vtk&#39;</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">outputname</span><span class="o">.</span><span class="n">lower</span><span class="p">()[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span> <span class="o">==</span> <span class="s1">&#39;.vtk&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vtk</span><span class="p">(</span><span class="n">outputname</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">outputname</span><span class="o">.</span><span class="n">lower</span><span class="p">()[</span><span class="o">-</span><span class="mi">5</span><span class="p">:]</span> <span class="o">==</span> <span class="s1">&#39;.node&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">exportTetgenMesh</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="n">outputname</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.node&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">outputname</span><span class="o">.</span><span class="n">lower</span><span class="p">()[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span> <span class="o">==</span> <span class="s1">&#39;.dat&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">dat</span><span class="p">(</span><span class="n">outputname</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;mesh export format not recognized. Try either .vtk, .node or .dat.&#39;</span><span class="p">)</span>



    <span class="k">def</span> <span class="nf">_toParaview</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span>  <span class="n">paraview_loc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span> <span class="c1"># pragma: no cover</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Open file in paraview (might not work if paraview is not in the PATH,</span>
<span class="sd">        in this case, pass parview location as `paraview_loc`).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fname : str</span>
<span class="sd">            Path of the .vtk file to be opened.</span>
<span class="sd">        paraview_loc: str, optional</span>
<span class="sd">            **Windows ONLY** maps to the executable paraview.exe. The program</span>
<span class="sd">            will attempt to find the location of the paraview install if not given.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">OS</span> <span class="o">==</span> <span class="s2">&quot;Windows&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">paraview_loc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">found</span><span class="p">,</span><span class="n">cmd_line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">findParaview</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cannot find paraview location&quot;</span><span class="p">)</span>
                    <span class="k">return</span>
                <span class="n">cmd_line</span> <span class="o">=</span> <span class="s1">&#39;&quot;&#39;</span> <span class="o">+</span> <span class="n">cmd_line</span> <span class="o">+</span> <span class="s1">&#39;&quot; &#39;</span> <span class="o">+</span> <span class="n">fname</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">paraview_loc</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
                <span class="n">cmd_line</span> <span class="o">=</span> <span class="s1">&#39;&quot;&#39;</span> <span class="o">+</span> <span class="n">paraview_loc</span> <span class="o">+</span> <span class="s1">&#39;&quot; &#39;</span> <span class="o">+</span> <span class="n">fname</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cannot find where paraview is installed&quot;</span><span class="p">)</span>
                <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cmd_line</span> <span class="o">=</span> <span class="s1">&#39;paraview &#39;</span> <span class="o">+</span> <span class="n">fname</span>

        <span class="k">try</span><span class="p">:</span><span class="c1">#try and launch paraview</span>
            <span class="c1">#Popen([cmd_line, os.path.join(self.dirname, fname)])</span>
            <span class="n">os</span><span class="o">.</span><span class="n">popen</span><span class="p">(</span><span class="n">cmd_line</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">PermissionError</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Your operating system has blocked launching Paraview&quot;</span><span class="p">)</span>
            <span class="c1">#windows doesnt like calling paraview from python for some reason</span>
            <span class="c1">#will need to look into this further.</span>


    <span class="k">def</span> <span class="nf">showMeshInParaview</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">paraview_loc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span> <span class="c1"># pragma: no cover</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Show the mesh in paraview (mostly useful for 3D surveys.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        paraview_loc: str, optional</span>
<span class="sd">            **Windows ONLY** maps to the excuatable paraview.exe. The program</span>
<span class="sd">            will attempt to find the location of the paraview install if not given.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Saving mesh as vtk...&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">saveMeshVtk</span><span class="p">()</span> <span class="c1"># save in default dirname</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;done.</span><span class="se">\n</span><span class="s1"> Launching paraview.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_toParaview</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="s1">&#39;mesh.vtk&#39;</span><span class="p">),</span>
                         <span class="n">paraview_loc</span><span class="o">=</span><span class="n">paraview_loc</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">showInParaview</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">paraview_loc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span> <span class="c1"># pragma: no cover</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Open paraview to display the .vtk file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index: int, optional</span>
<span class="sd">            Timestep to be shown in paraview (for an individual survey this 1).</span>
<span class="sd">        paraview_loc: str, optional</span>
<span class="sd">            **Windows ONLY** maps to the excuatable paraview.exe. The program</span>
<span class="sd">            will attempt to find the location of the paraview install if not given.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="s1">&#39;f</span><span class="si">{:03d}</span><span class="s1">_res.vtk&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_toParaview</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="n">fname</span><span class="p">),</span> <span class="n">paraview_loc</span><span class="o">=</span><span class="n">paraview_loc</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">showSlice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">attr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Show slice of 3D mesh interactively.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int, optional</span>
<span class="sd">            Index of the survey. Default is first survey (index == 0).</span>
<span class="sd">        ax : matplotlib.Axes, optional</span>
<span class="sd">            Axis on which to plot the graph.</span>
<span class="sd">        attr : str, optional</span>
<span class="sd">            Attribute to plot. Default is &#39;Resistivity(ohm.m)&#39;.</span>
<span class="sd">        axis : str, optional</span>
<span class="sd">            Either &#39;x&#39;, &#39;y&#39;, or &#39;z&#39; (default).</span>
<span class="sd">        vmin : float, optional</span>
<span class="sd">            Minimum value for colorbar.</span>
<span class="sd">        vmax : float, optional</span>
<span class="sd">            Maximum value for colorbar.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">attr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meshResults</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meshResults</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">showSlice</span><span class="p">(</span>
                <span class="n">attr</span><span class="o">=</span><span class="n">attr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">)</span>

        
    <span class="c1">## Sorting electrode numbers ##</span>
    <span class="c1"># def shuntIndexes(self):</span>
    <span class="c1">#     &quot;&quot;&quot;Shunt electrode indexes to start at 1.</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     debug=True</span>
    <span class="c1">#     if len(self.surveys)&gt;1:</span>
    <span class="c1">#         debug=False</span>
    <span class="c1">#     for i in range(len(self.surveys)):</span>
    <span class="c1">#         self.surveys[i].shuntIndexes(debug=debug)</span>

    <span class="k">def</span> <span class="nf">normElecIdx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="c1"># pragma: no cover</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Normalise electrode indexes to start at 1 in consective and ascending order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">debug</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">debug</span><span class="o">=</span><span class="kc">False</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">normElecIdx</span><span class="p">(</span><span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">)</span>

    <span class="c1">## make 3d coordinates for a 2d line in to 2d ##</span>
    <span class="k">def</span> <span class="nf">elec2distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">yDominant</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">iMoveElec</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert 3D electrode XY coordinates into just X coordinates. Use for</span>
<span class="sd">        2D lines only!</span>
<span class="sd">        If self.elec has been set then each survey will use the electrodes set</span>
<span class="sd">        in the R2 master class. If not then the R2 master class will take on the</span>
<span class="sd">        elec values set for the first survey in a sequence.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        yDominant: bool, optional</span>
<span class="sd">            If electrodes are prodimently spaced in the y direction then set yDominant</span>
<span class="sd">            to True.</span>
<span class="sd">        iMoveElec: bool, optional</span>
<span class="sd">            If moving electrodes are present then set to True, so that the same</span>
<span class="sd">            electrode positions are not given to each survey.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;R3t&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;cR3t&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot compress 3D survey coordinates to 2D for a 3D survey type.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">iMoveElec</span><span class="p">:</span><span class="c1">#check if elec has been assigned already</span>
            <span class="k">try</span><span class="p">:</span> <span class="c1"># if electrodes are set in the R2 class then use these for each survey</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">)):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">elec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elec</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span> <span class="c1">#if not already set then assume the electrodes are set for each survey</span>
                <span class="k">pass</span>

        <span class="k">if</span> <span class="n">yDominant</span><span class="p">:</span> <span class="c1"># swap x and y around in raw coordinates</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">)):</span>
                <span class="n">elec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">elec</span><span class="p">[[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="s1">&#39;z&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">elec</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">elec</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">elec</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">elec</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">elec2distance</span><span class="p">()</span> <span class="c1"># go through each survey and compute electrode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elec</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setElec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">elec</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">topo2distance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">):</span> <span class="c1"># pragma: no cover</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert 3d xy data in pure x lateral distance.</span>
<span class="sd">        Use for 2D data only!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
        
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c1"># sort by x axis</span>
        <span class="n">x_sorted</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">y_sorted</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">z_sorted</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        
        <span class="n">x_abs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="c1">#the first entry should be x = 0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">delta_x</span> <span class="o">=</span> <span class="n">x_sorted</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_sorted</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">delta_y</span> <span class="o">=</span> <span class="n">y_sorted</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">y_sorted</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">sq_dist</span> <span class="o">=</span> <span class="n">delta_x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">delta_y</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">x_abs</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span>  <span class="n">x_abs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sq_dist</span><span class="p">)</span>
        
        <span class="c1"># return values in the order in which they came</span>
        <span class="n">new_topo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)):</span>
            <span class="n">put_back</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="c1"># index to where to the value back again</span>
            <span class="n">new_topo</span><span class="p">[</span><span class="n">put_back</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_abs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">new_topo</span><span class="p">[</span><span class="n">put_back</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span>  <span class="n">z_sorted</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    
        <span class="k">return</span> <span class="n">new_topo</span>

<span class="c1"># WIP</span>
<span class="c1">#    def timelapseErrorModel(self, ax=None):</span>
<span class="c1">#        &quot;&quot;&quot;Fit an power law to time-lapse datasets.</span>
<span class="c1">#</span>
<span class="c1">#        Parameters</span>
<span class="c1">#        ----------</span>
<span class="c1">#        ax : matplotlib axis, optional</span>
<span class="c1">#            If specified, graph will be plotted on the given axis.</span>
<span class="c1">#</span>
<span class="c1">#        Returns</span>
<span class="c1">#        -------</span>
<span class="c1">#        fig : matplotlib figure, optional</span>
<span class="c1">#            If ax is not specified, the function will return a figure object.</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        if ax is None:</span>
<span class="c1">#            fig, ax = plt.subplots()</span>
<span class="c1">#        numbins = 20</span>
<span class="c1">#</span>
<span class="c1">#        if &#39;recipMean&#39; not in self.df.columns:</span>
<span class="c1">#            self.computeReciprocal()</span>
<span class="c1">#        dfg = self.df[self.df[&#39;irecip&#39;] &gt; 0]</span>
<span class="c1">#        binsize = int(len(dfg[&#39;recipMean&#39;])/numbins)</span>
<span class="c1">#        error_input = np.abs(dfg[[&#39;recipMean&#39;, &#39;recipError&#39;]]).sort_values(by=&#39;recipMean&#39;).reset_index(drop=True) # Sorting data based on R_avg</span>
<span class="c1">#        bins = np.zeros((numbins,2))</span>
<span class="c1">#        for i in range(numbins): # bining</span>
<span class="c1">#            ns=i*binsize</span>
<span class="c1">#            ne=ns+binsize-1</span>
<span class="c1">#            bins[i,0] = error_input[&#39;recipMean&#39;].iloc[ns:ne].mean()</span>
<span class="c1">#            bins[i,1] = error_input[&#39;recipError&#39;].iloc[ns:ne].mean()</span>
<span class="c1">##        print(bins)</span>
<span class="c1">##        print(np.sum(np.isnan(bins)))</span>
<span class="c1">##        print(np.sum(np.isinf(bins)))</span>
<span class="c1">##        coefs= np.linalg.lstsq(np.vstack([np.ones(len(bins[:,0])), np.log(bins[:,0])]).T, np.log(bins[:,1]), rcond=None)[0] # calculating fitting coefficients (a,m)</span>
<span class="c1">#        coefs = np.polyfit(np.log(bins[:,0]), np.log(bins[:,1]), 1)[::-1] #order is of coefs is opposite to lstqd</span>
<span class="c1">#        R_error_predict = np.exp(coefs[0])*(bins[:,0]**coefs[1]) # error prediction based of power law model</span>
<span class="c1">#        ax.plot(np.abs(dfg[&#39;recipMean&#39;]),np.abs(dfg[&#39;recipError&#39;]), &#39;+&#39;, label = &quot;Raw&quot;)</span>
<span class="c1">#        ax.plot(bins[:,0],bins[:,1],&#39;o&#39;,label=&quot;Bin Means&quot;)</span>
<span class="c1">#        ax.plot(bins[:,0],R_error_predict,&#39;r&#39;, label=&quot;Power Law Fit&quot;)</span>
<span class="c1">#        ax.set_xscale(&#39;log&#39;)</span>
<span class="c1">#        ax.set_yscale(&#39;log&#39;)</span>
<span class="c1">#        # lines above are work around to https://github.com/matplotlib/matplotlib/issues/5541/</span>
<span class="c1">#        ax.set_ylabel(r&#39;$R_{error} [\Omega]$&#39;)</span>
<span class="c1">#        ax.set_xlabel(r&#39;$R_{avg} [\Omega]$&#39;)</span>
<span class="c1">#        ax.legend(loc=&#39;best&#39;, frameon=True)</span>
<span class="c1">#        R2= self.R_sqr(np.log(bins[:,1]),np.log(R_error_predict))</span>
<span class="c1">#        a1 = np.exp(coefs[0])</span>
<span class="c1">#        a2 = coefs[1]</span>
<span class="c1">##        a3 = np.exp(coefs[0])</span>
<span class="c1">##        a4 = coefs[1]</span>
<span class="c1">#        print(&#39;Error model is R_err = {:.2f} R_avg^{:.3f} (R^2 = {:.4f})&#39;.format(a1,a2,R2))</span>
<span class="c1">#        if a1 &gt; 0.001:</span>
<span class="c1">#            ax.set_title(&#39;Multi bin power-law resistance error plot\n&#39; + r&#39;$R_{{error}}$ = {:.3f}$R_{{avg}}^{{{:.3f}}}$ (R$^2$ = {:.3f})&#39;.format(a1,a2,R2))</span>
<span class="c1">#        else:</span>
<span class="c1">#            ax.set_title(&#39;Multi bin power-law resistance error plot\n&#39; + r&#39;$R_{{error}}$ = {:.2e}$R_{{avg}}^{{{:.3e}}}$ (R$^2$ = {:.3f})&#39;.format(a1,a2,R2))</span>
<span class="c1">#        self.df[&#39;resError&#39;] = a1*(np.abs(self.df[&#39;recipMean&#39;])**a2)</span>
<span class="c1">#        def errorModel(df):</span>
<span class="c1">#            x = df[&#39;recipMean&#39;].values</span>
<span class="c1">#            return a1*(np.abs(x)**a2)</span>
<span class="c1">#        self.errorModel = errorModel</span>
<span class="c1">##        self.errorModel = lambda x : a1*(np.abs(x)**a2)</span>
<span class="c1">#        if ax is None:</span>
<span class="c1">#            return fig</span>



    <span class="c1"># def computeCond(self): # automatically done in getResults()</span>
    <span class="c1">#     &quot;&quot;&quot;Compute conductivities from resistivities for the ERT mesh</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     if self.typ==&#39;R3t&#39; or self.typ==&#39;cR3t&#39;:</span>
    <span class="c1">#         res_name = &#39;Resistivity&#39;</span>
    <span class="c1">#     else:</span>
    <span class="c1">#         res_name = &#39;Resistivity(Ohm-m)&#39;</span>
    <span class="c1">#     for i in range(len(self.meshResults)):</span>
    <span class="c1">#         self.meshResults[i].computeReciprocal(res_name,&#39;Conductivity(S/m)&#39;)</span>


    <span class="k">def</span> <span class="nf">computeDiff</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the absolute and the relative difference in resistivity</span>
<span class="sd">        between inverted surveys.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">iTimeLapse</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Difference calculation only available for time-lapse surveys.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meshResults</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getResults</span><span class="p">()</span>

        <span class="c1"># create an index for the values inside of the zone of interest</span>
        <span class="c1"># needed as the reference survey is not cropped by default</span>
        <span class="n">inside</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meshResults</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">numel</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;R3t&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;cR3t&#39;</span><span class="p">):</span>
            <span class="n">pname</span> <span class="o">=</span> <span class="s1">&#39;num_xy_poly&#39;</span>
            <span class="n">tableName</span> <span class="o">=</span> <span class="s1">&#39;xy_poly_table&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pname</span> <span class="o">=</span> <span class="s1">&#39;num_xz_poly&#39;</span>
            <span class="n">tableName</span> <span class="o">=</span> <span class="s1">&#39;xz_poly_table&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="n">pname</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">meshx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meshResults</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">elmCentre</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">meshy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meshResults</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">elmCentre</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">meshz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meshResults</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">elmCentre</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>
            <span class="c1"># poly = (self.param[&#39;xz_poly_table&#39;][:,0],</span>
                    <span class="c1"># self.param[&#39;xz_poly_table&#39;][:,1])</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="n">tableName</span><span class="p">])</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;3&#39;</span><span class="p">:</span>
                <span class="c1"># inside1 = iip.isinpolygon(meshx, meshy, poly)</span>
                <span class="n">inside1</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">contains_points</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">meshx</span><span class="p">,</span> <span class="n">meshy</span><span class="p">])</span>
                <span class="n">inside2</span> <span class="o">=</span> <span class="p">(</span><span class="n">meshz</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;zmin&#39;</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">meshz</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;zmax&#39;</span><span class="p">])</span>
                <span class="n">inside</span> <span class="o">=</span> <span class="n">inside1</span> <span class="o">&amp;</span> <span class="n">inside2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># inside = iip.isinpolygon(meshx, meshz, poly)</span>
                <span class="n">inside</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">contains_points</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">meshx</span><span class="p">,</span> <span class="n">meshz</span><span class="p">])</span>
                
        <span class="c1"># compute absolute and relative difference in resistivity</span>
        <span class="n">res_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;Resistivity&#39;</span><span class="p">,</span><span class="s1">&#39;Resistivity(Ohm-m)&#39;</span><span class="p">,</span><span class="s1">&#39;Resistivity(ohm.m)&#39;</span><span class="p">])</span>
        <span class="n">res_name</span> <span class="o">=</span> <span class="n">res_names</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">res_names</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meshResults</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">keys</span><span class="p">()))][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">res0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meshResults</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="n">res_name</span><span class="p">])[</span><span class="n">inside</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meshResults</span><span class="p">)):</span>
            <span class="k">if</span> <span class="s1">&#39;difference(percent)&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshResults</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meshResults</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="n">res_name</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">meshResults</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">addAttribute</span><span class="p">(</span><span class="n">res</span> <span class="o">-</span> <span class="n">res0</span><span class="p">,</span> <span class="s1">&#39;diff(Resistivity)&#39;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">meshResults</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">addAttribute</span><span class="p">((</span><span class="n">res</span><span class="o">-</span><span class="n">res0</span><span class="p">)</span><span class="o">/</span><span class="n">res0</span><span class="o">*</span><span class="mi">100</span><span class="p">,</span> <span class="s1">&#39;difference(percent)&#39;</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;error in computing difference:&#39;</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
                    <span class="k">pass</span>
        
        <span class="c1"># num_attr = len(self.meshResults[0].df)</span>
        <span class="c1"># num_elm = self.meshResults[0].numel</span>
        <span class="c1"># baselines = np.zeros((num_attr,num_elm))</span>
        <span class="c1"># for i, key in enumerate(self.meshResults[0].df):</span>
        <span class="c1">#     baselines[i,:] = self.meshResults[0].df[key]</span>
        <span class="c1"># change = np.zeros_like(baselines)</span>
        <span class="c1"># new_keys = []</span>
        <span class="c1"># baseline_keys = []</span>
        <span class="c1"># for j, key in enumerate(self.meshResults[0].df):</span>
        <span class="c1">#     new_keys.append(&#39;Difference(&#39;+key+&#39;)&#39;)</span>
        <span class="c1">#     baseline_keys.append(key)</span>
        <span class="c1"># for j, key in enumerate(new_keys):</span>
        <span class="c1">#     self.meshResults[0].add_attribute(change[j,:],key)</span>

        <span class="c1"># #filter baseline to just the measurements left over after cropping the mesh</span>
        <span class="c1"># if crop:</span>
        <span class="c1">#     baselines = baselines[:,inside]</span>

        <span class="c1"># problem = 0</span>
        <span class="c1"># for i in range(1,len(self.meshResults)):</span>
        <span class="c1">#     step = self.meshResults[i]</span>
        <span class="c1">#     new_keys = []</span>
        <span class="c1">#     count = 0</span>
        <span class="c1">#     change = np.zeros_like(baselines)</span>
        <span class="c1">#     for j, key in enumerate(baseline_keys):</span>
        <span class="c1">#         try:</span>
        <span class="c1">#             change[count,:] = (np.array(step.df[key])-baselines[count,:])/baselines[count,:] * 100</span>
        <span class="c1">#         except KeyError:</span>
        <span class="c1">#             problem+=1</span>
        <span class="c1">#         new_keys.append(&#39;Difference(&#39;+key+&#39;)&#39;)</span>
        <span class="c1">#         count += 1</span>
        <span class="c1">#     count = 0</span>
        <span class="c1">#     for j, key in enumerate(new_keys):</span>
        <span class="c1">#         self.meshResults[i].add_attribute(change[count,:],key)</span>
        <span class="c1">#         count += 1</span>
        <span class="c1"># if problem&gt;0:</span>
        <span class="c1">#     print(&#39;Had a problem computing differences for %i attributes&#39;%problem)</span>



    <span class="k">def</span> <span class="nf">saveVtks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dirname</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Save vtk files of inversion results to a specified directory.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------</span>
<span class="sd">        dirname: str</span>
<span class="sd">            Directory in which results will be saved. Default is the working directory.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dirname</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dirname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dirname</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">dirname</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">dirname</span><span class="p">)</span>
        <span class="n">amtContent</span> <span class="o">=</span> <span class="n">startAnmt</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meshResults</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getResults</span><span class="p">()</span>
        <span class="n">count</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meshResults</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">):</span>
            <span class="n">count</span><span class="o">+=</span><span class="mi">1</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iTimeLapse</span><span class="p">:</span>
                <span class="n">fname</span> <span class="o">=</span> <span class="s1">&#39;time_step</span><span class="si">{:0&gt;4}</span><span class="s1">.vtk&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fname</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">mesh_title</span> <span class="o">+</span> <span class="s1">&#39;.vtk&#39;</span>
            <span class="n">file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirname</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span> 
            <span class="n">meshcopy</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trapeziod</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudo3DMeshResult</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">meshcopy</span> <span class="o">=</span> <span class="n">meshcopy</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trapeziod</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudo3DMeshResult</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">projs</span><span class="p">[</span><span class="n">count</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">trapeziod</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">meshcopy</span> <span class="o">=</span> <span class="n">meshcopy</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">projs</span><span class="p">[</span><span class="n">count</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">trapeziod</span><span class="p">)</span>
            <span class="n">meshcopy</span><span class="o">.</span><span class="n">vtk</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">mesh</span><span class="o">.</span><span class="n">mesh_title</span><span class="p">)</span>
            <span class="n">amtContent</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">annotations.append(&#39;</span><span class="si">%s</span><span class="s2">&#39;)</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">%</span><span class="n">mesh</span><span class="o">.</span><span class="n">mesh_title</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudo3DMeshResultList</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirname</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">mesh_title</span> <span class="o">+</span> <span class="s1">&#39;_3D.vtk&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pseudo3DMeshResultList</span><span class="p">[</span><span class="n">count</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">vtk</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">mesh</span><span class="o">.</span><span class="n">mesh_title</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudo3DMeshResult</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">pseudo3DMeshResult</span><span class="o">.</span><span class="n">mesh_title</span> <span class="o">=</span> <span class="s1">&#39;Pseudo_3D_result&#39;</span>
            <span class="n">file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudo3DMeshResult</span><span class="o">.</span><span class="n">mesh_title</span> <span class="o">+</span> <span class="s1">&#39;.vtk&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pseudo3DMeshResult</span><span class="o">.</span><span class="n">vtk</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Pseudo_3D_result&#39;</span><span class="p">)</span>
            <span class="n">amtContent</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">annotations.append(&#39;</span><span class="si">%s</span><span class="s2">&#39;)</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">pseudo3DMeshResult</span><span class="o">.</span><span class="n">mesh_title</span>
        <span class="n">amtContent</span> <span class="o">+=</span> <span class="n">endAnmt</span>
        <span class="n">fh</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirname</span><span class="p">,</span><span class="s1">&#39;amt_track.py&#39;</span><span class="p">),</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
        <span class="n">fh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">amtContent</span><span class="p">)</span>
        <span class="n">fh</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">saveData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outputdir</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Save all data (_res.dat, .vtk, ...) from the working directory</span>
<span class="sd">        generated during inversion to the designated directory.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        outputdir : str</span>
<span class="sd">            Path to the directory to save the files.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">wd</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outputdir</span><span class="p">,</span> <span class="s1">&#39;wd&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">wd</span><span class="p">):</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">wd</span><span class="p">)</span>
        <span class="n">shutil</span><span class="o">.</span><span class="n">copytree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="n">wd</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">showParam</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Print parameters in `R2.param` dictionary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">[</span><span class="nb">print</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">)]</span>


    <span class="k">def</span> <span class="nf">filterZeroMeasSurveys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Filter out badly behaved surveys, where after all other QC no measurements</span>
<span class="sd">        are actually left.&quot;&quot;&quot;</span>
        <span class="n">count</span><span class="o">=</span><span class="mi">0</span>
        <span class="n">survey_len</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">df</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">))]</span>
        <span class="k">while</span> <span class="nb">min</span><span class="p">(</span><span class="n">survey_len</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">survey_len</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">df</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">))]</span>
            <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">survey_len</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">bad_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">survey_len</span><span class="p">))</span>
                <span class="k">del</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">[</span><span class="n">bad_idx</span><span class="p">])</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%i</span><span class="s2"> surveys removed as they had no measurements!&quot;</span><span class="o">%</span><span class="n">count</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">_estimateMemory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dump</span><span class="o">=</span><span class="nb">print</span><span class="p">,</span> <span class="n">inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;More accurate calculation of the amount of memory required</span>
<span class="sd">        to run a forward model or inversion. </span>
<span class="sd">        </span>
<span class="sd">        Nb: currently only experimental </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dump : function, optional</span>
<span class="sd">            stdout direction, ie where to print outputs </span>
<span class="sd">        inverse : Bool, optional</span>
<span class="sd">            Is the problem to be inverted? The default is True.</span>
<span class="sd">        debug : TYPE, optional</span>
<span class="sd">            If true all the variable values are printed to console. The </span>
<span class="sd">            default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Gb : float</span>
<span class="sd">            Memory needed for problem in gigabytes </span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#NB: using variable names from Andy&#39;s codes </span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dump</span><span class="p">(</span><span class="s1">&#39;A mesh is required before a memory usage estimate can be made&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">dump</span><span class="p">(</span><span class="s1">&#39;A survey needs to imported before a memory usage estimate can be made&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># number of measurements computation </span>
            <span class="n">nmeas</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">:</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">df</span> 
                <span class="n">ie</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;irecip&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="c1"># count the number of measurements actually put to file </span>
                <span class="n">nmeas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">ie</span><span class="p">))</span>
            <span class="n">num_ind_meas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">nmeas</span><span class="p">)</span> <span class="c1"># number of measurements </span>
            <span class="n">mnum_ind_meas</span> <span class="o">=</span> <span class="n">num_ind_meas</span> <span class="c1"># maximum number of measurements</span>
                    
        <span class="c1">#nsize A estimation - describes number of connected nodes </span>
        <span class="n">kxf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="c1"># flattened connection matrix</span>
        <span class="n">uni_node</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">kxf</span><span class="p">,</span><span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">nsizeA</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">numel</span><span class="p">)</span> <span class="c1"># an estimate only of NsizeA</span>
        
        <span class="c1">#other mesh parameters </span>
        <span class="n">numnp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">numnp</span>
        <span class="n">numel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">numel</span>
        <span class="n">npere</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">type2VertsNo</span><span class="p">()</span>
        <span class="k">if</span> <span class="s1">&#39;param&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">num_param</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;param&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num_param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">numel</span>
        <span class="n">nfaces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">type2FaceNo</span><span class="p">()</span>
        
        <span class="c1">#electrodes </span>
        <span class="n">num_electrodes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elec</span><span class="p">)</span>
        
        <span class="c1"># this refers to the roughness matrix in 2D problems</span>
        <span class="k">if</span> <span class="s1">&#39;inverse_type&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;inverse_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">numRterm</span> <span class="o">=</span> <span class="mi">13</span> 
        <span class="k">else</span><span class="p">:</span>
            <span class="n">numRterm</span> <span class="o">=</span> <span class="mi">5</span> 
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;R3t&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span><span class="s1">&#39;cR3t&#39;</span><span class="p">:</span> <span class="c1"># do 3D calculation </span>
            <span class="n">memDP</span><span class="o">=</span><span class="n">numnp</span><span class="o">*</span><span class="p">(</span><span class="mi">8</span><span class="o">+</span><span class="n">num_electrodes</span><span class="p">)</span><span class="o">+</span><span class="n">nsizeA</span><span class="o">+</span><span class="n">numel</span><span class="o">+</span><span class="n">num_ind_meas</span> <span class="o">*</span> <span class="mi">2</span>
            <span class="n">memR</span><span class="o">=</span><span class="mi">0</span>
            <span class="n">memI</span><span class="o">=</span><span class="n">numnp</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">npere</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">numel</span><span class="o">+</span><span class="n">numnp</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="n">nsizeA</span><span class="o">+</span><span class="n">num_electrodes</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="n">num_ind_meas</span><span class="o">*</span><span class="mi">12</span>
            <span class="n">memL</span><span class="o">=</span><span class="n">numel</span><span class="o">*</span><span class="mi">2</span>
              
            <span class="k">if</span> <span class="n">inverse</span><span class="p">:</span> 
                <span class="n">memDP</span><span class="o">=</span><span class="n">memDP</span><span class="o">+</span><span class="n">num_param</span><span class="o">*</span><span class="mi">9</span><span class="o">+</span><span class="n">num_ind_meas</span><span class="o">*</span><span class="p">(</span><span class="n">num_param</span><span class="o">+</span><span class="mi">6</span><span class="p">)</span> 
                <span class="n">memR</span><span class="o">=</span><span class="n">memR</span><span class="o">+</span><span class="p">(</span><span class="n">num_param</span><span class="o">*</span><span class="n">nfaces</span><span class="p">)</span>
                <span class="n">memI</span><span class="o">=</span><span class="n">memI</span><span class="o">+</span><span class="n">num_param</span><span class="o">*</span><span class="n">nfaces</span>    
        <span class="k">else</span><span class="p">:</span> <span class="c1"># do 2D calculation</span>
            <span class="n">memDP</span><span class="o">=</span><span class="p">(</span><span class="n">numnp</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">5</span><span class="o">+</span><span class="n">num_electrodes</span><span class="p">)</span><span class="o">+</span><span class="n">nsizeA</span><span class="o">+</span><span class="n">numel</span><span class="o">+</span><span class="n">mnum_ind_meas</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="n">num_ind_meas</span>       
            <span class="n">memR</span><span class="o">=</span><span class="mi">0</span>
            <span class="n">memI</span><span class="o">=</span><span class="n">nsizeA</span><span class="o">+</span><span class="n">numel</span><span class="o">*</span><span class="mi">6</span><span class="o">+</span><span class="n">numnp</span><span class="o">*</span><span class="mi">4</span><span class="o">+</span><span class="n">mnum_ind_meas</span><span class="o">*</span><span class="mi">8</span>
            <span class="n">memL</span><span class="o">=</span><span class="n">numel</span><span class="o">+</span><span class="n">numnp</span>

            <span class="k">if</span> <span class="n">inverse</span><span class="p">:</span>
                <span class="n">memDP</span><span class="o">=</span><span class="n">memDP</span><span class="o">+</span><span class="n">numel</span><span class="o">+</span><span class="n">num_param</span><span class="o">*</span><span class="mi">10</span><span class="o">+</span><span class="n">num_ind_meas</span><span class="o">*</span><span class="p">(</span><span class="n">num_param</span><span class="o">+</span><span class="mi">7</span><span class="p">)</span> 
                <span class="n">memR</span><span class="o">=</span><span class="n">memR</span><span class="o">+</span><span class="n">num_param</span><span class="o">*</span><span class="n">numRterm</span>
                <span class="n">memI</span><span class="o">=</span><span class="n">memI</span><span class="o">+</span><span class="n">num_param</span><span class="o">*</span><span class="n">numRterm</span>
                <span class="n">memL</span><span class="o">=</span><span class="n">memL</span><span class="o">+</span><span class="n">num_ind_meas</span>
        
        <span class="n">Gb</span><span class="o">=</span><span class="p">(</span><span class="n">memL</span> <span class="o">+</span> <span class="n">memI</span><span class="o">*</span><span class="mi">4</span> <span class="o">+</span> <span class="n">memR</span><span class="o">*</span><span class="mi">4</span> <span class="o">+</span> <span class="n">memDP</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span><span class="o">/</span><span class="mf">1.0e9</span>
        <span class="n">dump</span><span class="p">(</span><span class="s1">&#39;ResIPy Estimated RAM usage = </span><span class="si">%f</span><span class="s1"> Gb&#39;</span><span class="o">%</span><span class="n">Gb</span><span class="p">)</span>
        
        <span class="n">avialMemory</span> <span class="o">=</span> <span class="n">getSysStat</span><span class="p">()[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">Gb</span> <span class="o">&gt;=</span> <span class="n">avialMemory</span><span class="p">:</span>
            <span class="n">dump</span><span class="p">(</span><span class="s1">&#39;*** It is likely that more RAM is required for inversion! ***</span><span class="se">\n</span><span class="s1">&#39;</span>
                 <span class="s1">&#39;*** Make a coarser mesh ***&#39;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span> <span class="c1">#print everything out </span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;numnp = </span><span class="si">%i</span><span class="s1">&#39;</span><span class="o">%</span><span class="n">numnp</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;numel = </span><span class="si">%i</span><span class="s1">&#39;</span><span class="o">%</span><span class="n">numel</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;nsizA = </span><span class="si">%i</span><span class="s1">&#39;</span><span class="o">%</span><span class="n">nsizeA</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;num_param = </span><span class="si">%i</span><span class="s1">&#39;</span><span class="o">%</span><span class="n">num_param</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;num_electrodes = </span><span class="si">%i</span><span class="s1">&#39;</span><span class="o">%</span><span class="n">num_electrodes</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;num_ind_meas = </span><span class="si">%i</span><span class="s1">&#39;</span><span class="o">%</span><span class="n">num_ind_meas</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;npere = </span><span class="si">%i</span><span class="s1">&#39;</span><span class="o">%</span><span class="n">npere</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;nfaces = </span><span class="si">%i</span><span class="s1">&#39;</span><span class="o">%</span><span class="n">nfaces</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;inverse = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="o">%</span><span class="nb">str</span><span class="p">(</span><span class="n">inverse</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;memDP = </span><span class="si">%i</span><span class="s1">&#39;</span><span class="o">%</span><span class="n">memDP</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;memR = </span><span class="si">%i</span><span class="s1">&#39;</span><span class="o">%</span><span class="n">memR</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;memI = </span><span class="si">%i</span><span class="s1">&#39;</span><span class="o">%</span><span class="n">memI</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;memL = </span><span class="si">%i</span><span class="s1">&#39;</span><span class="o">%</span><span class="n">memL</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="n">Gb</span>
    
    <span class="k">def</span> <span class="nf">_estimateMemoryJac</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dump</span><span class="o">=</span><span class="nb">print</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Estimates the memory needed by inversion code to formulate </span>
<span class="sd">        a jacobian matrix</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dump : function, optional</span>
<span class="sd">            stdout direction, ie where to print outputs </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Gb : float</span>
<span class="sd">            Memory needed for jacobian formulation in gigabytes </span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#NB: using variable names from Andy&#39;s codes </span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;A mesh is required before a memory usage estimate can be made&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;A survey needs to imported before a memory usage estimate can be made&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># number of measurements computation </span>
            <span class="n">nmeas</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">surveys</span><span class="p">:</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">df</span> 
                <span class="n">ie</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;irecip&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="c1"># count the number of measurements actually put to file </span>
                <span class="n">nmeas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">ie</span><span class="p">))</span>
            <span class="n">num_ind_meas</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">nmeas</span><span class="p">)</span>
        
        <span class="n">numel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">numel</span>
        
        <span class="n">Gb</span><span class="o">=</span><span class="p">(</span><span class="n">numel</span><span class="o">*</span><span class="n">num_ind_meas</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span><span class="o">/</span><span class="mf">1.0e9</span>
        <span class="n">dump</span><span class="p">(</span><span class="s1">&#39;ResIPy Estimated RAM usage = </span><span class="si">%f</span><span class="s1"> Gb&#39;</span><span class="o">%</span><span class="n">Gb</span><span class="p">)</span>  
        
        <span class="n">avialMemory</span> <span class="o">=</span> <span class="n">sysinfo</span><span class="p">[</span><span class="s1">&#39;availMemory&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">Gb</span> <span class="o">&gt;=</span> <span class="n">avialMemory</span><span class="p">:</span>
            <span class="n">dump</span><span class="p">(</span><span class="s1">&#39;*** It is likely that more RAM is required for inversion! ***</span><span class="se">\n</span><span class="s1">&#39;</span>
                 <span class="s1">&#39;*** Make a coarser mesh ***&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Gb</span>     
    
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">setNcores</span><span class="p">(</span><span class="n">ncores</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the number of cores to use for big calculations, for now </span>
<span class="sd">        this value only to mesh generation and calculations done on 3D meshes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ncores : int</span>
<span class="sd">            Number of cores to use </span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        EnvironmentError</span>
<span class="sd">            Raised if ncores is more than that avialable</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ncores</span><span class="o">&gt;</span><span class="n">sysinfo</span><span class="p">[</span><span class="s1">&#39;cpuCount&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">EnvironmentError</span><span class="p">(</span><span class="s1">&#39;More cores requested than detected/avialable&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">ncores</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Expected ncores as an int, but got </span><span class="si">%s</span><span class="s1">&#39;</span><span class="o">%</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">ncores</span><span class="p">)))</span>
        <span class="n">mt</span><span class="o">.</span><span class="n">ncores</span> <span class="o">=</span> <span class="n">ncores</span>
        
<span class="c1"># for backward compatibility, retain the main class called R2</span>
<div class="viewcode-block" id="R2"><a class="viewcode-back" href="../../content/api/generated/ERT.simulate_ERT.R2.html#ERT.simulate_ERT.R2">[docs]</a><span class="k">class</span> <span class="nc">R2</span><span class="p">(</span><span class="n">Project</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
        
<span class="c1">#%% Resolution matrix calculation</span>
<span class="c1"># compute covariance matrix on Nvidia GPU / multi core processor </span>
<span class="k">def</span> <span class="nf">__readSize</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
    <span class="n">fh</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
    <span class="n">line1</span> <span class="o">=</span> <span class="n">fh</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="n">fh</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">return</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">line1</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">__readJacob</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
    <span class="n">array</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">fh</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
    <span class="n">header</span> <span class="o">=</span> <span class="n">fh</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
    <span class="n">size</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">header</span><span class="o">.</span><span class="n">split</span><span class="p">()]</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="n">fh</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
    <span class="n">fh</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
        <span class="n">array</span> <span class="o">+=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()]</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="n">array</span>

<span class="k">def</span> <span class="nf">__readRm</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">jsize</span><span class="p">,</span> <span class="n">rsize</span><span class="p">):</span>
    <span class="n">Rmap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="n">fname</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;R&#39;</span><span class="p">,</span><span class="s1">&#39;Rindex&#39;</span><span class="p">),</span>
                         <span class="n">skip_header</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
    
    <span class="n">Rvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span>
                          <span class="n">skip_header</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="n">Rn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">jsize</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">jsize</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rsize</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rsize</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">Rmap</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">k</span><span class="o">!=-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">Rn</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">Rvals</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">Rn</span> 

<span class="k">def</span> <span class="nf">__getAlpha</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
    <span class="c1">#return final reported alpha value, file should be the .out file from andy&#39;s code</span>
    <span class="n">fh</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="n">fh</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
    <span class="n">fh</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;Alpha:&#39;</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="n">c</span><span class="o">+=</span><span class="mi">1</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t find alpha line&quot;</span><span class="p">)</span>
        
    <span class="n">fnl</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="n">idx</span><span class="p">)]</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">fnl</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">alpha</span>


<span class="k">def</span> <span class="nf">cudaRm</span><span class="p">(</span><span class="n">invdir</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute Resolution and Covariance matrix for 2D problems using nVIDIA GPU. </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    invdir : string </span>
<span class="sd">        Inversion directory used by R2.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    covar : nd array </span>
<span class="sd">        Values along the diagonal of the coviarance matrix.</span>
<span class="sd">    remat : nd array </span>
<span class="sd">        Values along the diagonal of the Resolution matrix..</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span> <span class="c1"># import cupy (needs cuda enabled pc)</span>
    
    <span class="n">mempool</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">get_default_memory_pool</span><span class="p">()</span>
    <span class="n">pinned_mempool</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">get_default_pinned_memory_pool</span><span class="p">()</span>
    <span class="c1"># read in jacobian</span>
    <span class="n">jsize</span><span class="p">,</span> <span class="n">jdata</span> <span class="o">=</span> <span class="n">__readJacob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">invdir</span><span class="p">,</span><span class="s1">&#39;f001_J.dat&#39;</span><span class="p">))</span>
    <span class="n">Jn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">jdata</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">jsize</span><span class="p">)</span> <span class="c1"># numpy equivalent </span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Jn</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    
    <span class="c1"># read in data Weighting matrix</span>
    <span class="n">protocol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">invdir</span><span class="p">,</span><span class="s1">&#39;f001_err.dat&#39;</span><span class="p">),</span>
                             <span class="n">skip_header</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="n">Wd</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">protocol</span><span class="p">[:,</span><span class="mi">8</span><span class="p">]),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    
    <span class="c1"># read in model roughness matrix </span>
    <span class="n">rsize</span> <span class="o">=</span> <span class="n">__readSize</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">invdir</span><span class="p">,</span><span class="s1">&#39;f001_R.dat&#39;</span><span class="p">))</span>
    
    <span class="n">Rn</span> <span class="o">=</span> <span class="n">__readRm</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">invdir</span><span class="p">,</span><span class="s1">&#39;f001_R.dat&#39;</span><span class="p">),</span> <span class="n">jsize</span><span class="p">,</span> <span class="n">rsize</span><span class="p">)</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Rn</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="c1">#construct A and b on GPU </span>
    <span class="n">files</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">invdir</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.out&#39;</span><span class="p">):</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">__getAlpha</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">invdir</span><span class="p">,</span><span class="n">f</span><span class="p">))</span>
            <span class="k">break</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">Wd</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="n">cp</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">Wd</span><span class="p">,</span><span class="n">J</span><span class="p">))</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">S</span> <span class="o">+</span> <span class="n">alpha</span><span class="o">*</span><span class="n">R</span> <span class="c1">#Form A (Menke et al, 2015)</span>
    
    <span class="c1">#get rid of parameters we dont need anymore to free up memory </span>
    <span class="n">J</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">Wd</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">R</span> <span class="o">=</span> <span class="kc">None</span> 
    <span class="n">mempool</span><span class="o">.</span><span class="n">free_all_blocks</span><span class="p">()</span>
    
    <span class="n">Cm</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="c1"># solve inverse of A to get covariance matrix </span>
    <span class="n">ResM</span> <span class="o">=</span> <span class="n">Cm</span><span class="o">*</span><span class="n">S</span>
    <span class="n">A</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">mempool</span><span class="o">.</span><span class="n">free_all_blocks</span><span class="p">()</span>
    
    <span class="c1"># retrieve outputs as numpy arrays </span>
    <span class="n">covar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">Cm</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>
    <span class="n">remat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">ResM</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>
    
    <span class="c1">#finally clear memory once again </span>
    <span class="n">Cm</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">S</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">ResM</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">mempool</span><span class="o">.</span><span class="n">free_all_blocks</span><span class="p">()</span>
    <span class="n">pinned_mempool</span><span class="o">.</span><span class="n">free_all_blocks</span><span class="p">()</span>
    
    <span class="k">return</span> <span class="n">covar</span><span class="p">,</span> <span class="n">remat</span>

<span class="k">def</span> <span class="nf">parallelRm</span><span class="p">(</span><span class="n">invdir</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute Resolution and Covariance matrix for 2D problems using multicore CPU. </span>
<span class="sd">    Behaves the same as cudaRm but uses numpy / openBlas. </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    invdir : string </span>
<span class="sd">        Inversion directory used by R2.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    covar : nd array </span>
<span class="sd">        Values along the diagonal of the coviarance matrix.</span>
<span class="sd">    remat : nd array </span>
<span class="sd">        Values along the diagonal of the Resolution matrix..</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># read in jacobian</span>
    <span class="n">jsize</span><span class="p">,</span> <span class="n">jdata</span> <span class="o">=</span> <span class="n">__readJacob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">invdir</span><span class="p">,</span><span class="s1">&#39;f001_J.dat&#39;</span><span class="p">))</span>
    <span class="n">Jn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">jdata</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">jsize</span><span class="p">)</span> <span class="c1"># numpy equivalent </span>
    
    <span class="c1"># read in data Weighting matrix</span>
    <span class="n">protocol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">invdir</span><span class="p">,</span><span class="s1">&#39;f001_err.dat&#39;</span><span class="p">),</span>
                             <span class="n">skip_header</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="n">Wd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">protocol</span><span class="p">[:,</span><span class="mi">8</span><span class="p">])</span>
    
    <span class="c1"># read in model roughness matrix </span>
    <span class="n">rsize</span> <span class="o">=</span> <span class="n">__readSize</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">invdir</span><span class="p">,</span><span class="s1">&#39;f001_R.dat&#39;</span><span class="p">))</span>
    
    <span class="n">Rn</span> <span class="o">=</span> <span class="n">__readRm</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">invdir</span><span class="p">,</span><span class="s1">&#39;f001_R.dat&#39;</span><span class="p">),</span> <span class="n">jsize</span><span class="p">,</span> <span class="n">rsize</span><span class="p">)</span>
    <span class="c1">#construct A and b on GPU </span>
    <span class="n">files</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">invdir</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.out&#39;</span><span class="p">):</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">__getAlpha</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">invdir</span><span class="p">,</span><span class="n">f</span><span class="p">))</span>
            <span class="k">break</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">Jn</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">Wd</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">Wd</span><span class="p">,</span><span class="n">Jn</span><span class="p">))</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">S</span> <span class="o">+</span> <span class="n">alpha</span><span class="o">*</span><span class="n">Rn</span> <span class="c1">#Form A (Menke et al, 2015)</span>
    
    <span class="c1">#get rid of parameters we dont need anymore to free up memory </span>
    <span class="n">Jn</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">Wd</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">Rn</span> <span class="o">=</span> <span class="kc">None</span> 
    
    <span class="n">Cm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="c1"># solve inverse of A to get covariance matrix (should use multiple cores)</span>
    <span class="n">ResM</span> <span class="o">=</span> <span class="n">Cm</span><span class="o">*</span><span class="n">S</span>
    <span class="n">A</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="c1"># retrieve outputs as numpy arrays </span>
    <span class="n">covar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">Cm</span><span class="p">)</span>
    <span class="n">remat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">ResM</span><span class="p">)</span>
    
    <span class="c1">#finally clear memory once again </span>
    <span class="n">Cm</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">S</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">ResM</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="k">return</span> <span class="n">covar</span><span class="p">,</span> <span class="n">remat</span>

<span class="c1">#%% deprecated funcions</span>

    <span class="k">def</span> <span class="nf">pseudoIP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span> <span class="c1"># pragma: no cover</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;The function is deprecated, use showPseudoIP() instead.&#39;</span><span class="p">,</span>
                      <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">showPseudoIP</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">plotError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span> <span class="c1"># pragma: no cover</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;This function is deprecated, use showError() instead.&#39;</span><span class="p">,</span>
                      <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">showError</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">errorDist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span> <span class="c1"># pragma: no cover</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;This function is deprecated, use showErrorDist() instead.&#39;</span><span class="p">,</span>
                      <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">showErrorDist</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">removeDummy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span> <span class="c1"># pragma: no cover</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;This function is deprecated, use filterDummy() instead.&#39;</span><span class="p">,</span>
                      <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filterDummy</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">linfit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span> <span class="c1"># pragma: no cover</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;This function is deprecated, use fitErrorLin() instead.&#39;</span><span class="p">,</span>
                      <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitErrorLin</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">pwlfit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span> <span class="c1"># pragma: no cover</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;This function is deprecated, use fitErrorPwl() instead.&#39;</span><span class="p">,</span>
                      <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitErrorPwl</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">lmefit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rpath</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">iplot</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span> <span class="c1"># pragma: no cover</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;This function is deprecated, use fitErrorLME() instead.&#39;</span><span class="p">,</span>
                      <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitErrorLME</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">rpath</span><span class="o">=</span><span class="n">rpath</span><span class="p">,</span> <span class="n">iplot</span><span class="o">=</span><span class="n">iplot</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">phaseplotError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span> <span class="c1"># pragma: no cover</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;This function is deprecated, use showErrorIP() instead.&#39;</span><span class="p">,</span>
                      <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">showErrorIP</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">plotIPFit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span> <span class="c1"># pragma: no cover</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;This function is deprecated, use fitErrorPwlIP() instead.&#39;</span><span class="p">,</span>
                      <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitErrorPwlIP</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">plotIPFitParabola</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span> <span class="c1"># pragma: no cover</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;This function is deprecated, use fitErrorParabolaIP() instead.&#39;</span><span class="p">,</span>
                      <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitErrorParabolaIP</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">heatmap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span> <span class="c1"># pragma: no cover</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;This function is deprecated, use showHeatmap() instead.&#39;</span><span class="p">,</span>
                      <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">showHeatmap</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">removenested</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span> <span class="c1"># pragma: no cover</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;This function is deprecated, use filterNested() instead.&#39;</span><span class="p">,</span>
                      <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filterNested</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dca</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dump</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span> <span class="c1"># pragma: no cover</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;This function is deprecated, use filterDCA() instead.&#39;</span><span class="p">,</span>
                      <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filterDCA</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">dump</span><span class="o">=</span><span class="n">dump</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">removerecip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span> <span class="c1"># pragma: no cover</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;This function is deprecated, use filterRecip() instead.&#39;</span><span class="p">,</span>
                      <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filterRecip</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">iprangefilt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phimin</span><span class="p">,</span> <span class="n">phimax</span><span class="p">,</span> <span class="n">index</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span> <span class="c1"># pragma: no cover</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;This function is deprecated, use filterRangeIP() instead.&#39;</span><span class="p">,</span>
                      <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filterRangeIP</span><span class="p">(</span><span class="n">phimin</span><span class="p">,</span> <span class="n">phimax</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">removeUnpaired</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span> <span class="c1"># pragma: no cover</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;This function is deprecated, use filterUnpaired() instead.&#39;</span><span class="p">,</span>
                      <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filterUnpaired</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">n</span>
    
    <span class="k">def</span> <span class="nf">removeneg</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="c1"># pragma: no cover</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;This function is deprecated, use filterNegative() instead.&#39;</span><span class="p">,</span>
                      <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filterNegative</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">assignRes0</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">regionValues</span><span class="o">=</span><span class="p">{},</span> <span class="n">zoneValues</span><span class="o">=</span><span class="p">{},</span> <span class="n">fixedValues</span><span class="o">=</span><span class="p">{},</span> <span class="n">ipValues</span><span class="o">=</span><span class="p">{}):</span> <span class="c1"># pragma: no cover</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;This function is deprecated, use setStartingRes() instead.&#39;</span><span class="p">,</span>
                      <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setStartingRes</span><span class="p">(</span><span class="n">regionValues</span><span class="o">=</span><span class="n">regionValues</span><span class="p">,</span> <span class="n">zoneValues</span><span class="o">=</span><span class="n">zoneValues</span><span class="p">,</span> <span class="n">fixedValues</span><span class="o">=</span><span class="n">fixedValues</span><span class="p">,</span> <span class="n">ipValues</span><span class="o">=</span><span class="n">ipValues</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">assignRefModel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">res0</span><span class="p">):</span> <span class="c1"># pragma: no cover</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;This function is deprecated, use setRefModel() instead.&#39;</span><span class="p">,</span>
                      <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setRefModel</span><span class="p">(</span><span class="n">res0</span><span class="o">=</span><span class="n">res0</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">createModellingMesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typ</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="n">buried</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">surface</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cl_factor</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                   <span class="n">cl</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dump</span><span class="o">=</span><span class="nb">print</span><span class="p">,</span> <span class="n">res0</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">show_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">doi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span> <span class="c1"># pragma: no cover</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;This function is deprecated, use createModelErrorMesh() instead.&#39;</span><span class="p">,</span>
                      <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">createModelErrorMesh</span><span class="p">(</span><span class="n">typ</span><span class="o">=</span><span class="n">typ</span><span class="p">,</span> <span class="n">buried</span><span class="o">=</span><span class="n">buried</span><span class="p">,</span> <span class="n">surface</span><span class="o">=</span><span class="n">surface</span><span class="p">,</span> <span class="n">cl_factor</span><span class="o">=</span><span class="n">cl_factor</span><span class="p">,</span>
                                  <span class="n">cl</span><span class="o">=</span><span class="n">cl</span><span class="p">,</span> <span class="n">dump</span><span class="o">=</span><span class="n">dump</span><span class="p">,</span> <span class="n">res0</span><span class="o">=</span><span class="n">res0</span><span class="p">,</span> <span class="n">show_output</span><span class="o">=</span><span class="n">show_output</span><span class="p">,</span> <span class="n">doi</span><span class="o">=</span><span class="n">doi</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">estError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a_wgt</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">b_wgt</span><span class="o">=</span><span class="mf">0.02</span><span class="p">):</span> <span class="c1"># pragma: no cover</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;This function is deprecated, use estimateError() instead.&#39;</span><span class="p">,</span>
                      <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">estimateError</span><span class="p">(</span><span class="n">a_wgt</span><span class="o">=</span><span class="n">a_wgt</span><span class="p">,</span> <span class="n">b_wgt</span><span class="o">=</span><span class="n">b_wgt</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pseudoError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span> <span class="c1"># pragma: no cover</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;This function is deprecated, use showPseudInvError() instead.&#39;</span><span class="p">,</span>
                      <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">showPseudoInvError</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">pseudoErrorIP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span> <span class="c1"># pragma: no cover</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;This function is deprecated, use showErrorIP() instead.&#39;</span><span class="p">,</span>
                      <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">showPseudoErrorIP</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">showInversionErrors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span> <span class="c1"># pragma: no cover</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;This function is deprecated, use showInvError() instead.&#39;</span><span class="p">,</span>
                      <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">showInvError</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>


    <span class="c1"># def compCond(self): # pragma: no cover</span>
    <span class="c1">#     warnings.warn(&#39;This function is deprecated, use computeCond() instead.&#39;,</span>
    <span class="c1">#                   DeprecationWarning)</span>
    <span class="c1">#     self.computeCond()</span>

    <span class="k">def</span> <span class="nf">compDiff</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="c1"># pragma: no cover</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;This function is deprecated, use computeDiff() instead.&#39;</span><span class="p">,</span>
                      <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">computeDiff</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">pseudo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;The function is deprecated, use showPseudo() instead.&#39;</span><span class="p">,</span>
                      <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">showPseudo</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

              </div>
              
            
                <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
            
        </div>
    </div>
    <footer class="footer">
  <p>
    
      By B. Mary<br/>
    
        &copy; Copyright 2022, B. Mary.<br/>
      Last updated on Feb 10, 2023.<br/>
  </p>
</footer>
</main>


      </div>
    </div>
  
  <script src="../../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>

  </body>
</html>